{"pages":[{"title":"分类","date":"2023-02-13T02:22:14.742Z","path":"categories/index.html","text":""},{"title":"标签","date":"2023-02-13T02:22:14.743Z","path":"tags/index.html","text":""}],"posts":[{"title":"静态库与动态链接库","date":"2023-03-09T07:00:00.000Z","path":"wiki/CPlusPlus/Windows/静态链接库与动态链接库/","text":"静态库一般是.lib格式，而动态链接库一般是.dll格式 静态库 只能 静态链接，此时静态库的内容将被完全嵌入到程序文件中 动态链接库可以静态链接，此时程序在启动时就需要依赖和加载对应的.dll文件（没有dll程序打不开） 动态链接库可以动态链接，此时程序在执行导入函数后才需要依赖和加载对应的.dll文件（没有dll程序也能打开但功能受限） 静态库 设置编译后的程序格式：需要在项目设置里将“配置类型”改为“静态库(.lib)” 即对应的vcxproj文件内容： 123&lt;PropertyGroup Condition=&quot;&#x27;$(Configuration)|$(Platform)&#x27;==&#x27;Debug|x64&#x27;&quot; Label=&quot;Configuration&quot;&gt; &lt;ConfigurationType&gt;StaticLibrary&lt;/ConfigurationType&gt;&lt;/PropertyGroup&gt; 定义函数和类时无需任何额外的操作 实际上就是在写“库”，与在主程序同文件夹下新建xxx.h和xxx.cc并无使用上的区别 优势：使代码可以跨项目复用 以定义一个类为例，静态库内的代码形式如下： 1234567891011121314// 主程序和库共用的头文件，include/example.h#pragma once// 接口class IExample&#123;public: IExample() = default; virtual ~IExample() = default; virtual int get_A() = 0; virtual std::string get_B() = 0;&#125;; 1234567891011121314151617181920// 库的头文件，static_lib.h#pragma once#include &quot;include/example.h&quot;// 接口实现为类class ExampleClass: public IExample&#123; int m_iA; std::string m_szB;public: ExampleClass(int in_iA, std::string in_szB): m_iA(in_iA), m_szB(in_szB) &#123; &#125;; ~ExampleClass() override = default; int get_A() override; std::string get_B() override;&#125;;// 库内函数IExample* createObject(int in_iA, std::string in_szB); 12345678910111213141516171819202122// 库的代码，static_lib.cc#include &quot;lib.h&quot;int ExampleClass::get_A()&#123; return this-&gt;m_iA;&#125;std::string ExampleClass::get_B()&#123; return this-&gt;m_szB;&#125;// 函数示例：创建一个对象并返回其指针；对象放在堆上，手动管理其作用域IExample* createObject(int in_iA, std::string in_szB)&#123; ExampleClass *newObj = new ExampleClass(in_iA, in_szB); return newObj;&#125;//全局变量示例int TestC = 100; 使用静态库的主程序 需要在链接时指定链接库文件 使用#pragma：#pragma comment(lib, &quot;static_lib.lib&quot;) 编辑项目设置并在其中添加文件：项目设置 -&gt; 配置属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 -&gt; 编辑 -&gt; （添加链接库的文件位置） 即对应的vcxproj文件内容： 123&lt;Link&gt; &lt;AdditionalDependencies&gt;static_lib.lib;%(AdditionalDependencies)&lt;/AdditionalDependencies&gt;&lt;/Link&gt; 需要在主程序中使用extern关键字声明静态库中的函数&#x2F;全局变量 随后调用该函数&#x2F;变量即可 主程序的代码示例如下： 1234567891011121314151617// 引入IExample的定义#include &quot;include/example.h&quot;#include &lt;iostream&gt;// 引入库中的全局变量extern int TestC;// 引入库内的函数extern IExample* createObject(int in_iA, std::string in_szB);// 主函数内就能使用类int main()&#123; std::cout &lt;&lt; TestC &lt;&lt; std::endl; IExample *TestD = createObject(100, &quot;Hello, World!&quot;); return 0;&#125; 以上代码同样演示了一种 主程序和库共享接口定义时传递对象的方法： 主程序和库同时有接口的定义 库内将接口实现为类，可对类进行各种操作，并定义一个初始化函数：在堆上实例化子类，并返回接口的指针类型 主程序调用初始化函数，得到指针，根据接口的定义进行各种操作 示例如下： 12接口定义IExample -&gt; 静态库引入 -&gt; 实例化为CExample（可以添加新成员变量和成员方法） -&gt; 定义createObject，返回IExample*；接口定义IExample -&gt; 主程序引入 -&gt; 设置使用静态库 -&gt; 引入createObject -&gt; 获得IExample*类型变量（CExample中新加的成员变量和成员方法不可用）； 动态链接库","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"},{"name":"Windows","slug":"Windows","permalink":"http://wiki.zhouweitong.site/tags/Windows/"},{"name":"动态链接库","slug":"动态链接库","permalink":"http://wiki.zhouweitong.site/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"静态库","slug":"静态库","permalink":"http://wiki.zhouweitong.site/tags/%E9%9D%99%E6%80%81%E5%BA%93/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"Windows","slug":"C/Windows","permalink":"http://wiki.zhouweitong.site/categories/C/Windows/"}]},{"title":"GCC与G++","date":"2023-03-07T12:00:00.000Z","path":"wiki/CPlusPlus/GCC与GPlusPlus/","text":"一些GCC&#x2F;G++强相关的技巧笔记； 万能头文件1#include &lt;bits/stdc++&gt; 只有g++才有这个文件 相当于把STL所有头文件都include一次，可看代码： gcc&#x2F;stdc++.h at master · gcc-mirror&#x2F;gcc · GitHub _start()在GCC中，程序的实际入口点是__start()函数，而其中又会调用__libc_start_main()，再在其中调用main()； 因此，下面的代码也可以作为独立程序成功编译： 12345void _start()&#123; int a = 0, b = 5; a = b + 1;&#125; objdump输出： 12345678910111213Disassembly of section .text:0000000000000000 &lt;_start&gt;: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: c7 45 fc 00 00 00 00 movl $0x0,-0x4(%rbp) b: c7 45 f8 05 00 00 00 movl $0x5,-0x8(%rbp) 12: 8b 45 f8 mov -0x8(%rbp),%eax 15: 83 c0 01 add $0x1,%eax 18: 89 45 fc mov %eax,-0x4(%rbp) 1b: 90 nop 1c: 5d pop %rbp 1d: c3 ret 可以通过自定义__start()函数实现更复杂的程序启动流程；","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"},{"name":"GCC","slug":"GCC","permalink":"http://wiki.zhouweitong.site/tags/GCC/"},{"name":"G++","slug":"G","permalink":"http://wiki.zhouweitong.site/tags/G/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"}]},{"title":"匈牙利命名法","date":"2023-03-07T08:00:00.000Z","path":"wiki/CPlusPlus/Windows/匈牙利命名法/","text":"匈牙利命名法是Windows程序开发时经常用到&#x2F;见到的变量&#x2F;类型命名方法。 例如：下面是winsock2.h中的一个函数的文档： 1234567INT WSAAPI WSAAddressToStringW( [in] LPSOCKADDR lpsaAddress, [in] DWORD dwAddressLength, [in, optional] LPWSAPROTOCOL_INFOW lpProtocolInfo, [in, out] LPWSTR lpszAddressString, [in, out] LPDWORD lpdwAddressStringLength); 显然，变量名（类型名）具有某中规律，但：lpsz是什么？LPWSTR又是什么类型？DWORD和LPDWORD有什么区别？可以通过学习匈牙利命名法快速解决这些问题； 匈牙利命名法分为“匈牙利应用命名法”和“系统匈牙利命名法”两种，可同时使用； 由 其他前缀（前前缀） + 匈牙利命名法前缀 + 实际变量&#x2F;类名 组成； 大小写规则（不是必须的）： 类（数据类型）的匈牙利命名法前缀大写，类名大写；也即：全部大写；例如：LPWSTR； 变量（对象）的匈牙利命名法前缀小写，变量名只有首字母大写；例如：lpwStr； 不同程序项目中的前缀的含义不一定相同，但同一个项目中的前缀含义一定相同 即：弄懂一个前缀的意思，就能快速了解其他变量或类的类型&#x2F;特征 系统匈牙利命名法 匈牙利命名法的前缀 标识的是数据类型 基础类型 i：int，整型 u：unsigned，无符号的 b：bool，布尔型 l：long，长的 v：void，空类型 n：number，即short，短整型 f、fp：float，单精度浮点数 d、db：double，双精度浮点数 c、ch：char，字符型 uc、cb（char byte）：无符号字符型 p：pointer，指针 np：near pointer，近程指针 fn：function，函数 fs：file stream，文件流 k：const，常量 e：enum，枚举类型 …… 有时可以在类型后加数字，代表类型的位数，如：16位无符号整形ui16 其他类型 s：string，字符串 sz：string (with) zero (endings)，以\\0结尾的字符串 a、rg：range，即array，数组 by：byte，字节 w：word，字 dw：double word，双字 qw：quarter word，四字 S：struct，结构体 C：Class，类 I：Interface，接口 X：Nested Class，嵌套的类 x：Instance of nested class，嵌套的类的实例 123456789// CRocket：类class CRocket &#123;public: // XMotion：类中的类（嵌套的类），IMotion：接口 class XMotion: public IMotion &#123; public: void Fly(); &#125; m_xUnknown; // m_xUnknown：嵌套的类XMotion的一个实例&#125; Windows API中能够见到许多独特的前缀 h：handle，句柄 sa：Socket Address，Socket地址 …… 常见的前前缀 g_：global，全局变量 m_：member，类的成员变量 s_：static，静态变量 …… 匈牙利应用命名法 匈牙利命名法的前缀 标识的是变量特征或用处 一些前缀的例子 ct：counter，计数器 cb：count (of) bytes，字节数 i：index，下标 w：wide，宽字符 row：row，行号 col：column，列号 d：distance，距离 us：unsafe string，不安全的字符串 ……","tags":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"Windows","slug":"Windows","permalink":"http://wiki.zhouweitong.site/tags/Windows/"},{"name":"匈牙利命名法","slug":"匈牙利命名法","permalink":"http://wiki.zhouweitong.site/tags/%E5%8C%88%E7%89%99%E5%88%A9%E5%91%BD%E5%90%8D%E6%B3%95/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"Windows","slug":"C/Windows","permalink":"http://wiki.zhouweitong.site/categories/C/Windows/"}]},{"title":"宏函数","date":"2023-03-07T05:00:00.000Z","path":"wiki/CPlusPlus/基础语法/宏函数/","text":"宏函数类似于函数，包含函数名、参数和实现，与函数定义差别不大（没有返回值和大括号） 可视情况决定函数结尾是否添加分号 1234567// 定义一个宏函数，实现三数相加#define SUM(a, b, c) a + b + c// 使用这个函数int k = SUM(1, 2, 5) + 6;// 等价于int k = 1 + 2 + 5 + 6; 也可以将宏函数的参数作为函数名或类名使用 12345#define STRINGPARAM(func, string) func(string)STRINGPARAM(std::printf, &quot;Hello, World!&quot;);// 等价于std::printf(&quot;Hello, World!&quot;); 甚至可以将宏函数的参数作为宏名使用 12345678// 先定义一个宏#define VECTOR(type, name) std::vector&lt;type&gt; name// 再定义一个宏#define DATACONTAINER(container_type) container_type(int, A); container_type(std::string, B);DATACONTAINER(VECTOR)// 等价于std::vector&lt;int&gt; A; std::vector&lt;std::string&gt; B; 是的，宏函数也可以接受数量可变的参数：只需要配合使用...和__VA_ARGS__即可 123456// 定义宏#define OUTPUT(...) std::printf(__VA_ARGS__)OUTPUT(&quot;%d: %d&quot;, num1, num2);// 等价于std::printf(&quot;%d: %d&quot;, num1, num2); 可变参数可以放在固定参数后面 123456// 定义宏#define NEWARRAY(type, size, name, ...) std::array&lt;type, size&gt; name = &#123; __VA_ARGS__ &#125;NEWARRAY(int, 10, data, 1, 2, 3, 4);// 等价于std::array&lt;int, 10&gt; data = &#123; 1, 2, 3, 4 &#125;; 特殊符号：#，字符串化 #abc会被翻译为&quot;abc&quot; 1234567// 定义宏#define OUTPUT(var) std::cout &lt;&lt; #var &lt;&lt; &quot; &quot; &lt;&lt; var &lt;&lt; std::endlint k = 10;OUTPUT(k);// 等价于std::cout &lt;&lt; &quot;k&quot; &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; std::endl; 特殊符号：##，token粘贴（标记粘贴） A##B会被转换为AB，此后AB可以作为其他宏名&#x2F;变量名等进行替换 12345#define ARRAYS(type, size, name) std::array&lt;type, size&gt; name##_dbg, name##_relARRAYS(int, 10, data);// 等价于std::array&lt;int, 10&gt; data_dbg, data_rel; __VA_ARGS__也支持特殊符号，即#__VA_ARGS__和##__VA_ARGS__ 宏与其定义顺序无关；但为保证可读性，还是建议位于文件上方的宏不要依赖文件下方的宏 宏函数无需写到一行内，复杂的宏可以通过\\分割为多行 注意：\\必须是行内的最后一个字符，即使是后面多了一个空格也不行 注意：给多行的宏函数内添加注释只能使用/* */ 123456#define CHECK_REGULATORY(a, b, res) \\ /* Threshold is 100 */ \\ if (a &gt; 100 || b &gt; 100 || a &lt; 0 || b &lt; 0) \\ res = false; \\ else \\ res = true;","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"宏","slug":"宏","permalink":"http://wiki.zhouweitong.site/tags/%E5%AE%8F/"},{"name":"宏函数","slug":"宏函数","permalink":"http://wiki.zhouweitong.site/tags/%E5%AE%8F%E5%87%BD%E6%95%B0/"},{"name":"Macro","slug":"Macro","permalink":"http://wiki.zhouweitong.site/tags/Macro/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"基础语法","slug":"C/基础语法","permalink":"http://wiki.zhouweitong.site/categories/C/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"array、vector、tuple","date":"2023-03-06T13:00:00.000Z","path":"wiki/CPlusPlus/STL/array、vector、tuple/","text":"array：更高级一些的“数组”；固定长度，类型必须一致； vector：“向量”；可变长度，类型必须一致； tuple：“元组”；固定长度，类型可以不一致； array 特点： 支持随机访问，适合线性搜索； 必须是在编译时确定的大小； 不支持扩容； 如果元素的初始化、移动等开销巨大，则会严重影响性能； 值存放在栈上； 1#include &lt;array&gt; 定义数组时也可以直接初始化； 1std::array&lt;int, 10&gt; arr_int = &#123;1, 2, 4, 8, 16&#125;; 也可以定义二维数组：直接嵌套即可； 1std::array&lt;std::array&lt;int, 10&gt;, 10&gt; a; std::array重载了[]，所以可以像传统数组一样对数组里的某个元素进行赋值； 123456arr_int[0] = 2;a[0][1] = 5;// 等同于（看下文）arr_int.at(0) = 2;(a.at(0)).at(1) = 5; 成员方法： 快速访问：操作符[] 迭代器：除[]外另一种访问元素的方法 只要有迭代器的容器都有（或都应该实现）的方法：返回头迭代器的方法x.begin()，返回尾后迭代器的方法x.end() 为什么叫尾后迭代器：实际上指向的是最后一个元素后面的空位 返回的实际上是std::array&lt;T&gt;::iterator类型，习惯上用auto自动推导类型 迭代器支持的操作： 解引用：*，访问迭代器对应的元素，例如*i 比较：&lt; &lt;= &gt; &gt;= == !=，对迭代器的比较是对位置进行比较 自增自减：++ --，包括前置++i和后置i++ 数字加减：+ x，”前移x位“；- x：”后移x位“ 数字加减复合赋值：+= -= 迭代器作差：iter_1 - iter_2：得到两个迭代器的距离 距离的数据类型：std::array&lt;T&gt;::difference_type 常量（const）的begin和end：cbegin()是常量形式的begin()，cend()是常量形式的end() 可以使用常量迭代器禁止通过迭代器修改元素 常量迭代器的数据类型：std::array&lt;T&gt;::const_iterator 反转（reversed）的begin()和end()：rbegin()指向尾元素，rend()指向头元素的前一个元素 反转常量（const reversed）的begin和end：crbegin()，crend() 注意：只要对元素（包括长度）进行了修改，迭代器即刻失效； 位于：at() 已有元素个数：size() 容量：max_size() 判空：empty() 头尾元素：front()，back() 与另一个同长度同类型的数组交换元素：xxx.swap(yyy) 访问底层的C式数组：data() 运算符：各种比较，== != &lt; &lt;= &gt; &gt;= &lt;=&gt; vector 特点： 存储同一种类型的数据； 可动态扩容； 数据存储在堆上 是C++的“默认容器（Default Container）” 能够最好地展现STL中“容器”的特征（体现STL中“容器”的设计思想）； 许多其他STL模板支持甚至使用vector； 123#include &lt;vector&gt;std::vector&lt;int&gt; test&#123;1, 2, 3&#125;; 两种初始化： 构造函数（Constructor）初始化，std::vector&lt;int&gt; a(2, 5); 初始化列表（Initializer List）初始化，std::vector&lt;int&gt; a&#123;2, 5&#125;; 区别与联系：只会发生在参数个数为2的情况下： 初始化列表：把大括号内的每一个int当作元素，a实际上为(2, 5) 构造函数初始化：由于重载顺序的问题，会匹配到如下的构造函数：2是重复次数，5是要被重复的元素，a实际上是(5, 5) 其他容器也会存在类似的问题，为避免二义性尽量只在元素重复非常多次的情况下使用构造函数初始化 插入和删除：分为两种方式 尾部插入和删除（性能较好）：v.push_back(xxx)和v.pop_back() 任意位置插入和删除（需要移动元素，性能较差）：v.insert(pos, xxx)和v.erase(pos) pos的类型必须是v的迭代器； insert和erase也可以对区间进行操作; insert和erase方法的返回值是新的迭代器； 清空所有元素：v.clear() 注意：删除或清空元素不会回收已分配的空间 123456789101112131415// 假设此时有两个vectorstd::vector&lt;int&gt; a&#123;1,2,3&#125;;std::vector&lt;int&gt; b&#123;4,5,6&#125;;// 在指定位置插入a.insert(a.begin(), 4);// 在指定位置删除a.erase(a.begin());// 提供一个（自己的）迭代器区间，删除这段区间内的元素a.erase(a.begin(), a.end()-1);// 提供一个（其他变量的）迭代器区间，将其他变量的某个区间内的元素插入到当前变量中a.insert(a.begin(), b.begin(), b.end()-1); 安放元素： emplace与insert&#x2F;push的区别：在进行“初始化一个对象，再进行插入”的操作时，insert&#x2F;push需要借助中间变量（临时变量），而emplace不需要 v.emplace_back(args...)：在最后安放 v.emplace(pos, args...)：在指定位置安放 123456789101112131415161718// 假设有一个类struct A&#123; int Id; std::string Name; A() = delete; A(int input_id, std::string input_name): Id(input_id), Name(input_name) &#123;&#125;&#125;;// 以这个类为数据类型定义vectorstd::vector&lt;A&gt; data;// push_back：使用了临时变量data.push_back(A(10, &quot;Test1&quot;));// emplace_back：不使用临时变量data.emplace_back(11, &quot;Test2&quot;); 空间处理：分为查询、扩展和收缩三种操作 v.size()：查询现有元素个数 v.capacity()：查询无需扩容时能容纳的最大元素数（一般是2的倍数） v.resize(x, y)：在原vector的最后用y填充，直至v的元素个数为x v.reserve(x)：将v的内存预分配至x个元素大小 ( TODO )","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://wiki.zhouweitong.site/tags/STL/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"},{"name":"array","slug":"array","permalink":"http://wiki.zhouweitong.site/tags/array/"},{"name":"vector","slug":"vector","permalink":"http://wiki.zhouweitong.site/tags/vector/"},{"name":"tuple","slug":"tuple","permalink":"http://wiki.zhouweitong.site/tags/tuple/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"http://wiki.zhouweitong.site/categories/C/STL/"}]},{"title":"AI绘画模型和插件汇总","date":"2023-03-05T13:00:00.000Z","path":"wiki/AI绘画/AI绘画模型和插件汇总/","text":"绘画模型（*.ckpt&#x2F;*.safetensors）Novel AI 泄露版模型 基于Stable Diffusion网络结构，使用Danbooru数据集进行多次训练后的权重 至少需 5.8GiB 存储空间 磁力链接，使用BitTorrent协议下载 1magnet:?xt=urn:btih:5bde442da86265b670a3e5ea3163afad2c6f8ecc SFW（Suitable For Work）模型：stableckpt/animesfw-final-pruned NSFW模型：stableckpt/animefull-final-pruned Stable Diffusion 官方模型 官方Stable Diffusion，使用多个图片数据集 Stable Diffusion 1.5 runwayml&#x2F;stable-diffusion-v1-5 · Hugging Face 至少需 4.0GB 存储空间 其他Stable Diffusion 1.x版本模型：CompVis (CompVis) 1wget https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.ckpt Stable Diffusion 2.1 stabilityai&#x2F;stable-diffusion-2-1 · Hugging Face 至少需 4.9GB 存储空间 其他Stable Diffusion 2.x版本模型：stabilityai (Stability AI) 1wget https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt Waifu Diffusion 使用Stable Diffusion网络结构，精选了Danbooru数据集 Waifu Diffusion 1.4 hakurei&#x2F;waifu-diffusion-v1-4 · Hugging Face 至少需 4.8GB 存储空间 其他Waifu Diffusion 1.x版本模型：hakurei (Reimu Hakurei) 1wget https://huggingface.co/hakurei/waifu-diffusion-v1-4/resolve/main/wd-1-4-anime_e2.ckpt Kenshi 基于Stable Diffusion网络结构，强调“照片感”。是对多个模型的加权融合，包括BoChen模型、WLOP模型等； Kenshi01 SweetLuna&#x2F;Kenshi · Hugging Face 至少需 4.0GB 存储空间 1wget https://huggingface.co/SweetLuna/Kenshi/resolve/main/KENSHI%2001/KENSHI01_Pruned.ckpt AbyssOrangeMix3 基于Stable Diffusion网络结构，是对多个模型的加权融合，侧重“高质量”和“画面内的纹理效果” 分为A1（平涂）、A2（厚涂；油画风）、A3（融合）三个版本 至少需 2.0GB 存储空间 WarriorMama777&#x2F;OrangeMixs · Hugging Face 1wget https://huggingface.co/WarriorMama777/OrangeMixs/resolve/main/Models/AbyssOrangeMix3/AOM3A3.safetensors NeverEnding Dream 基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“好看的人像”及“有生成cosplay照片的能力” 至少需 4.0GB 存储空间 NeverEnding Dream (NED) | Stable Diffusion Checkpoint | Civitai 1wget https://civitai.com/api/download/models/11925 ChilloutMix 基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“2.5D”、“人像”及“cosplay照片生成” 至少需 2.0GB 存储空间 ChilloutMix | Stable Diffusion Checkpoint | Civitai 1wget https://civitai.com/api/download/models/11732 momoko-e 基于stable-diffusion网络结构，训练了ももこ画师的图片，该模型比较火的原因可能是手和脚的崩坏次数少一些（被一些人称为“有手修复包”，很可能是因为模型过拟合） 至少需 2.0GB 存储空间 链接来自其他人转存，有失效风险 1wget https://huggingface.co/LarryAIDraw/momoko-e/resolve/main/momoko-e.ckpt Anything v4.5 基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“全能（二次元男角色、二次元女角色、二次元风景）”和“更短的tag” 至少需 2.0GB 存储空间 andite&#x2F;anything-v4.0 · Hugging Face 1wget https://huggingface.co/andite/anything-v4.0/resolve/main/anything-v4.5-pruned-fp16.ckpt WebUI 插件a1111-sd-webui-tagcomplete 给WebUI增加Danbooru tag数据库和自动补全支持 DominikDoom&#x2F;a1111-sd-webui-tagcomplete: Booru style tag autocompletion for AUTOMATIC1111’s Stable Diffusion web UI sd-webui-supermerger 直接加权融合多个模型并进行使用，而不需要先合并网络参数制作模型文件 hako-mikan&#x2F;sd-webui-supermerger: model merge extention for stable diffusion web ui sd-webui-controlnet 给WebUI增加ControlNet支持 ControlNet必须搭配这个插件使用 Mikubill&#x2F;sd-webui-controlnet: WebUI extension for ControlNet openpose-editor 直接在WebUI里通过摆放骨骼的方式生成OpenPose图像 Openpose Editor for AUTOMATIC1111’s stable-diffusion-webui Auto-Photoshop-StableDiffusion-Plugin Photoshop插件的后端 AbdullahAlfaraj&#x2F;Auto-Photoshop-StableDiffusion-Plugin: A user-friendly plug-in that makes it easy to generate stable diffusion images inside Photoshop using Automatic1111-sd-webui as a backend. stable-diffusion-webui-localization-zh_CN WebUI的中文语言包 dtlnor&#x2F;stable-diffusion-webui-localization-zh_CN: Simplified Chinese translation extension for AUTOMATIC1111‘s stable diffusion webui sd-webui-additional-networks 用于融合多个LoRA模型 建议LoRA搭配这个插件使用 kohya-ss&#x2F;sd-webui-additional-networks deforum-for-automatic1111-webui 用于使用stable diffusion生成视频 deforum-art&#x2F;deforum-for-automatic1111-webui: Deforum extension script for AUTOMATIC1111’s Stable Diffusion webui sd-webui-depth-lib 预制的手部动作深度图，用于固定和修复手部动作 有ControlNet后才能使用这个插件 jexom&#x2F;sd-webui-depth-lib: Depth map library for use with the Control Net extension for Automatic1111&#x2F;stable-diffusion-webui Textual Inversion模型 引入新的prompt，并将其与已有的prompt关联起来； 放置在WebUI的embeddings文件夹下； EasyNegative 用于快速屏蔽负面tag 配合使用：AbyssOrangeMix3、Counterfeit-V2.5 gsdf&#x2F;EasyNegative · Datasets at Hugging Face Prompt：EASYNEGATIVE 1wget https://huggingface.co/datasets/gsdf/EasyNegative/resolve/main/EasyNegative.pt Ulzzang-6500 用于生成 韩国女明星式的 人像图片 配合使用：ChilloutMix Ulzzang-6500 (Korean doll aesthetic) | Stable Diffusion TextualInversion | Civitai Prompt：ulzzang-6500-v1.1 1wget https://civitai.com/api/download/models/10107 LoRA模型 LoRA用于训练差分模型。用户给出一系列具有相似特征（比如都是某个动漫角色、都是某个绘画风格、都是某个地区的人的脸型，……）的图片，经过训练生成一个几十&#x2F;几百MB的模型 载入绘画模型，再载入LoRA模型，使用LoRA的Prompt（或是插件），便可生成具有训练数据特征的图片 特点：速度快，模型小（类似的Dreambooth技术会生成完整模型），准确度高（对“风格”来说更优秀，但对“脸型”来说不如Dreambooth），可组合 推荐配合sd-webui-additional-networks插件使用 使用插件：LoRA模型放到extensions/sd-webui-additional-networks/models/lora下 不使用插件：LoRA模型放到models/Lora下 *-doll-likeness 配合ChilloutMix绘画模型，生成具有特定地域脸型的人像图片（“伪Cosplay照片”） 原作者已删除模型，链接来自他人转存，有失效风险 Prompt：woman, girl 123456# 日本模特脸型wget https://huggingface.co/AnonPerson/ChilloutMix/resolve/main/Japanese-doll-likeness.safetensors# 韩国模特脸型wget https://huggingface.co/AnonPerson/ChilloutMix/resolve/main/Korean-doll-likeness.safetensors# 中国台湾模特脸型wget https://huggingface.co/AnonPerson/ChilloutMix/resolve/main/Taiwan-doll-likeness.safetensors chinese-doll-likeness 配合ChilloutMix绘画模型，生成具有中国人脸型的人像图片（“伪Cosplay照片”） [LORA] Chinese Doll Likeness | Stable Diffusion LORA | Civitai Prompt：chinese doll 1wget https://civitai.com/api/download/models/11195 Pastel-Mix 使图像变为粉彩风格 Pastel-Mix [Stylized Anime Model] | Stable Diffusion Checkpoint | Civitai 1wget https://civitai.com/api/download/models/7397 Glorious (Azur Lane) Spring 光荣 凉夜春雪 画特定人物（碧蓝航线 光荣 凉夜春雪皮肤），同时少量使用可能可以改善画面细节 Glorious (Azur Lane) Spring 光荣 凉夜春雪 | Stable Diffusion LORA | Civitai Prompt：blonde hair, cleavage, bare shoulders 1wget https://civitai.com/api/download/models/8855 Gacha splash LORA 使输出的图像更像游戏角色立绘 Gacha splash LORA | Stable Diffusion LORA | Civitai Prompt：[(white background:1.5)::5], (bottle bottom:0.9), 1 girl, mid shot, full body 1wget https://civitai.com/api/download/models/15439 Anime Lineart (线稿&#x2F;線画) Style 使Stable Diffusion直接画出图片线稿，而不是填色的图片 Anime Lineart (线稿&#x2F;線画) Style | Stable Diffusion LORA | Civitai Prompt：monochrome, lineart 1wget https://civitai.com/api/download/models/19075 工具模型 与绘画不直接相关，主要用于图片后处理、图片内容识别，以及图片放大 变分自编码器（VAE） 改变生成结果的概率分布，表现为图片的对比度、饱和度等 部分模型内置VAE，看到_bakedVAE字样可忽略 最常用的VAE：NovelAI的VAE，下载： 通过磁力链接，见上述NovelAI模型章节：stableckpt/animevae.pt Huggingface上其他项目的转存 放置在WebUI的models/VAE文件夹下 1wget https://huggingface.co/WarriorMama777/OrangeMixs/resolve/main/VAEs/orangemix.vae.pt Deepbooru 用于识别给出的图片，将图片内容转化为Danbooru的tag AUTOMATIC1111&#x2F;TorchDeepDanbooru: Pure pytorch implementation of DeepDanbooru 放置在WebUI的models/torch_deepdanbooru文件夹下 1wget https://github.com/AUTOMATIC1111/TorchDeepDanbooru/releases/download/v1/model-resnet_custom_v3.pt RealESRGAN（R-ESRGAN4x） 通用图片放大器，4倍时最佳 xinntao&#x2F;Real-ESRGAN: Real-ESRGAN aims at developing Practical Algorithms for General Image&#x2F;Video Restoration. 放置在WebUI的models/RealESRGAN文件夹下 1wget https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.1/RealESRNet_x4plus.pth RealESRGAN+Anime6B（R-ESRGAN4x + Anime6B） 专为二次元图片训练的图片放大器，边缘更锐利、速度更快 xinntao&#x2F;Real-ESRGAN: Real-ESRGAN aims at developing Practical Algorithms for General Image&#x2F;Video Restoration. 放置在WebUI的models/RealESRGAN文件夹下 1wget https://github.com/xinntao/Real-ESRGAN/releases/download/v0.2.2.4/RealESRGAN_x4plus_anime_6B.pth GFPGAN、CodeFormer 用于真实人脸的放大和重建 TencentARC&#x2F;GFPGAN: GFPGAN aims at developing Practical Algorithms for Real-world Face Restoration. xinntao&#x2F;facexlib: FaceXlib aims at providing ready-to-use face-related functions based on current STOA open-source methods. 放置在WebUI的models/GFPGAN文件夹下 123wget https://github.com/TencentARC/GFPGAN/releases/download/v1.3.4/GFPGANv1.4.pthwget https://github.com/xinntao/facexlib/releases/download/v0.1.0/detection_Resnet50_Final.pthwget https://github.com/xinntao/facexlib/releases/download/v0.2.2/parsing_parsenet.pth sczhou&#x2F;CodeFormer: [NeurIPS 2022] Towards Robust Blind Face Restoration with Codebook Lookup Transformer 放置在WebUI的models/CodeFormer文件夹下 1wget https://github.com/sczhou/CodeFormer/releases/download/v0.1.0/codeformer.pth ControlNet 用于部分控制Diffusion网络的参数，例如 固定生成图片的人物动作（OpenPose） 通过精细线稿生成图片（Canny） 通过简笔画生成图片（Scribble） 通过景深生成图片（Depth） … lllyasviel&#x2F;ControlNet: Let us control diffusion models! 需要配合插件sd-webui-controlnet使用 12345678910111213# ControlNet差分模型，放置在WebUI的extensions/sd-webui-controlnet/models文件夹下# Cannywget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_canny-fp16.safetensors# OpenPosewget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_openpose-fp16.safetensors# Scribblewget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_scribble-fp16.safetensors# Depthwget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_depth-fp16.safetensors# OpenPose需要独立的数据模型，放置在WebUI的models/openpose文件夹下wget https://huggingface.co/lllyasviel/ControlNet/resolve/main/annotator/ckpts/body_pose_model.pthwget https://huggingface.co/lllyasviel/ControlNet/resolve/main/annotator/ckpts/hand_pose_model.pth","tags":[{"name":"速查表","slug":"速查表","permalink":"http://wiki.zhouweitong.site/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"name":"Stable Diffusion","slug":"Stable-Diffusion","permalink":"http://wiki.zhouweitong.site/tags/Stable-Diffusion/"},{"name":"Novel AI","slug":"Novel-AI","permalink":"http://wiki.zhouweitong.site/tags/Novel-AI/"},{"name":"模型与插件","slug":"模型与插件","permalink":"http://wiki.zhouweitong.site/tags/%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"categories":[{"name":"AI绘画","slug":"AI绘画","permalink":"http://wiki.zhouweitong.site/categories/AI%E7%BB%98%E7%94%BB/"}]},{"title":"any、variant","date":"2023-03-01T10:00:00.000Z","path":"wiki/CPlusPlus/STL/any、variant/","text":"any any的作用：定义一个“能够保存任何类型数据”的变量 类似Python中的：a = 10, a = &quot;Hello&quot; 类似于弱类型语言中的变量，但不完全一样 1#include &lt;any&gt; 可以直接赋值 123456std::any test;// 存储数据就可以直接赋值test = 1;test = &quot;Hello&quot;;test = 2.3; 但是不能直接取值 std::any：使用std::any_cast&lt;Type&gt;(var)来判断和转换类型 Type不是当前var的实际类型，会抛出std::bad_any_cast异常 也可以使用指针和if，判断返回值是否为nullptr 12345678// 最好使用try-catch，像下面这样try &#123; int tmp = std::any_cast&lt;int&gt;(test);&#125;// 相当于Python的 except XXExpection as ecatch (std::bad_any_cast&amp; e) &#123; std::cout &lt;&lt; &quot;Not integer.&quot; &lt;&lt; &quot; &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125; 12345678910double* tmp2 = nullptr;// 因为是指针，所以也要对变量取地址tmp2 = std::any_cast&lt;double&gt;(&amp;test);if (tmp2 == nullptr) &#123; std::cout &lt;&lt; &quot;Not double.&quot; &lt;&lt; std::endl;&#125;else &#123; std::cout &lt;&lt; *tmp2 &lt;&lt; std::endl;&#125; any也可以用于引用类型和右值引用 any在实际应用中可能遇到可读性问题：因为any在上下文中时编码者不会给出明显的类型提示 参看如下代码：res最后是const char*类型，而不是std::string 12345678910111213141516std::any test = &quot;Hello World!&quot;;try &#123; std::string res = std::any_cast&lt;std::string&gt;(test); std::cout &lt;&lt; res &lt;&lt; std::endl;&#125;catch (std::bad_any_cast&amp; e) &#123; std::cout &lt;&lt; &quot;Not std::string.&quot; &lt;&lt; &quot; &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125;try &#123; const char* res = std::any_cast&lt;const char*&gt;(test); std::cout &lt;&lt; res &lt;&lt; std::endl;&#125;catch (std::bad_any_cast&amp; e) &#123; std::cout &lt;&lt; &quot;Not const char*.&quot; &lt;&lt; &quot; &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125; variant variant，又称“变体”，作用类似any，但需要提前指定可能会更改的类型 其本质是一个联合体，可以手动使用联合体模拟一个简单版本的variant数据结构 123#include &lt;variant&gt;std::variant&lt;int, double, std::string&gt; test; 与std::any类似，定义之后就可以赋值符合指定的variant类型的值 12test = 1;test = 2.2; 与std::any类似，std::variant使用std::get&lt;Type&gt;(var)来判断和转换类型 Type也可以是下标； Type不是当前var的实际类型，会抛出std::bad_variant_cast异常 123456789101112131415161718192021222324252627// 取值，最好使用try-catch判断try &#123; int tmp = std::get&lt;int&gt;(test); std::cout &lt;&lt; tmp &lt;&lt; std::endl;&#125;catch (std::bad_variant_access&amp; e) &#123; std::cout &lt;&lt; &quot;Not int.&quot; &lt;&lt; &quot; &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125;try &#123; double tmp = std::get&lt;double&gt;(test); std::cout &lt;&lt; tmp &lt;&lt; std::endl;&#125;catch (std::bad_variant_access&amp; e) &#123; std::cout &lt;&lt; &quot;Not double.&quot; &lt;&lt; &quot; &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125;// 这样是不可以的，因为没有float存在// std::get&lt;float&gt;(test);// 可以用下标代替尖括号内的内容，0是int，1是double，以此类推try &#123; double tmp = std::get&lt;1&gt;(test);&#125;catch (std::bad_variant_access&amp; e) &#123; std::cout &lt;&lt; &quot;Not 1.&quot; &lt;&lt; &quot; &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125; variant由于编程者手动给出了类型，可以规避上述提到的std::any的问题 123456789101112std::variant&lt;int, double, std::string&gt; test = &quot;Hello World!&quot;;// 检测其类型try &#123; std::string tmp = std::get&lt;std::string&gt;(test); std::cout &lt;&lt; tmp &lt;&lt; std::endl;&#125;catch (std::bad_variant_access&amp; e) &#123; std::cout &lt;&lt; &quot;Not std::string.&quot; &lt;&lt; &quot; &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125;// 发现此处确实是std::string类型，而不是const char*// 因此在字符串等处更推荐使用variant","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://wiki.zhouweitong.site/tags/STL/"},{"name":"any","slug":"any","permalink":"http://wiki.zhouweitong.site/tags/any/"},{"name":"variant","slug":"variant","permalink":"http://wiki.zhouweitong.site/tags/variant/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"http://wiki.zhouweitong.site/categories/C/STL/"}]},{"title":"函数与极限","date":"2023-03-01T07:00:00.000Z","path":"wiki/数学/高等数学/函数与极限/","text":"函数 函数定义 复合函数 注意内层值域&#x3D;外层定义域 不是任意函数都能复合 反函数 注意y到x要一一对应 性质 初等函数 基本初等函数 幂函数 指数函数 对数函数 三角函数 反三角函数 其他初等函数 由常数或基本初等函数构成 由加减乘除或复合运算连接 能由一个解析式表示 函数性质 单调性 单调增 单调不减 可出现水平线 单调减 单调不增 性质 注意是严格大于&#x2F;小于还是大于等于&#x2F;小于等于 应用 根的个数 不等式 判定 定义法 导数法 奇偶性 性质 应用 泰勒展开 奇函数 在 x&#x3D;0 的 泰勒展开式中 没有偶次项 偶函数 在 x&#x3D;0 的 泰勒展开式中 没有奇次项 原函数 连续的奇函数 原函数都是偶函数 连续的偶函数 原函数之一是奇函数 函数的原函数有无限多个 当引入的常数项 C 为 0（最简单的反函数）时，连续偶函数的原函数 f(t) 是奇函数 倒推积分时，注意奇函数的积分下限只能是0 周期性 常见的周期函数 出现三角函数，往往就暗示需要用到周期性 周期性的判定 定义法 周期函数可导，则导函数也是周期函数 周期函数的 原函数 不一定是周期函数 当周期函数在一个周期上的积分为0时，其原函数是周期函数 反向也成立：若周期函数的原函数是周期函数，则当前周期函数在一个周期上的积分必为0 极限 “三基” 基本概念 基本理论 基本方法 常考题型 概念、理论- 极限的概念、性质及存在准则 方法 求极限 确定极限中的参数 无穷小量阶的比较 概念 数列极限 - 几何意义：数列项值的点落在极限的某个邻域区间内- 数列有极限，则数列的部分列也有极限 特殊情况：奇数项极限存在、偶数项极限存在、两个极限相等，则数列极限存在且也相等；反向成立 [[TODO]] 函数极限 - 自变量趋向无穷值 注意趋于无穷的情况：实际上是指绝对值趋于正无穷 - 自变量趋向有限值 注意：趋向的点可以没有定义，但点周边的邻域必须处处有定义 无穷小 性质 有限个无穷小的和是无穷小 有限个无穷小的积是无穷小 无穷小和有界量的乘积是无穷小 无穷大 概念：绝对值要多大有多大 无穷大的比较 不讨论无穷大的高阶、低阶问题 x趋于正无穷时，对数函数$\\ln{x}$ &lt; 幂函数 $x^a$ &lt; 指数函数$a^x$ n趋于正无穷时，对数数列$\\ln{n}$ &lt; 幂数列$n^a$ &lt; 指数数列$a^n$ &lt; 阶乘数列$n!$ &lt; $n^n$ 无穷大和无界变量关系 无穷大：n很大时$x_n$绝对值都很大，强调持续 无界变量：n很大时存在一个$x_n$绝对值很大，强调存在 无穷大一定无界，无界不一定无穷大 两个数列：无穷大x无穷大&#x3D;无穷大；无界x无界≠无界","tags":[{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%B0%E5%AD%A6/"},{"name":"函数","slug":"函数","permalink":"http://wiki.zhouweitong.site/tags/%E5%87%BD%E6%95%B0/"},{"name":"极限","slug":"极限","permalink":"http://wiki.zhouweitong.site/tags/%E6%9E%81%E9%99%90/"},{"name":"高等数学","slug":"高等数学","permalink":"http://wiki.zhouweitong.site/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/"},{"name":"高等数学","slug":"数学/高等数学","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"当今的操作系统","date":"2023-03-01T02:30:00.000Z","path":"wiki/操作系统/当今的操作系统/","text":"程序是什么？ 程序 &#x3D; 状态机 状态：数据（堆和栈） -&gt; 栈帧（含PC寄存器） 初始状态：刚装入内存时的状态 - main()刚进入 状态迁移：指令的执行 函数调用：看作压栈 函数返回：看作出栈 随机数：看作上下限区间内这么多种状态 - 比如0~10之间的整数随机数就有11种状态 状态机的结束：trap，syscall 也可以认为：程序 &#x3D; 计算+syscall 操作系统 &#x3D; 对象（文件，进程etc.） + API &#x3D; C语言程序 编译器 将源代码级别的状态机转化为二进制代码级别的状态机 二者的可观测行为要严格一致 可以这样理解编译器的优化过程：在可观测行为一致时改写代码 compiler barrier：需要对内存进行操作 今天的操作系统 “虚拟化”应用广泛 NUMA 非对称处理器（大小核：性能核与能效核） Intel-VT&#x2F;AMD-V等等 各种设备 互联互通","tags":[{"name":"OS","slug":"OS","permalink":"http://wiki.zhouweitong.site/tags/OS/"},{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"持续更新","slug":"持续更新","permalink":"http://wiki.zhouweitong.site/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"内存","date":"2023-02-28T14:55:00.000Z","path":"wiki/操作系统/内存/","text":"内存四区 一般分为如下四个区间 代码区 有时会将代码区拆成程序代码区和常量存储区 静态&#x2F;全局变量区 有时会拆分为静态变量区和全局变量区 栈区：由上向下延申，自动维护 即低地址向高地址 堆区：由下向上延申，手动维护 即高地址向低地址","tags":[{"name":"OS","slug":"OS","permalink":"http://wiki.zhouweitong.site/tags/OS/"},{"name":"内存","slug":"内存","permalink":"http://wiki.zhouweitong.site/tags/%E5%86%85%E5%AD%98/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统补充知识","date":"2023-02-28T14:50:00.000Z","path":"wiki/操作系统/操作系统补充知识/","text":"数字电路 触发器（Flip-flop） R-S触发器（Reset-Set） 有输出1和输出0两种稳定的状态 可以用于记忆数据 逻辑电路 - 触发器Flip-Flop - kkun - 博客园 ##（待细化） gdb gdb starti gdb layout asm&#x2F;src gdb bt gdb x&#x2F; Python z3 rich sage sympy 汇编：行为是什么？ retq gcc void _start()：是实际上的gcc编译的C语言程序的启动函数 __ASSEMBLER__ 汇编代码预编译？ tmux strace：分析程序使用了哪些syscall time命令：测量程序运行时间 sort -nk：按照第几列进行数值排序 dialog：伪GUI，对话框 busybox，GNU coreutils 形式语义学 bash $status","tags":[{"name":"OS","slug":"OS","permalink":"http://wiki.zhouweitong.site/tags/OS/"},{"name":"持续更新","slug":"持续更新","permalink":"http://wiki.zhouweitong.site/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"进程、线程与锁","date":"2023-02-28T14:30:00.000Z","path":"wiki/操作系统/进程、线程与锁/","text":"多处理器 需要借助进程和线程 进程：资源分配的最小单位 线程：任务调度的最小单位 多处理器：实际上是并行，同一时间点上同时，因为现在已经是多核CPU的时代 简单认为：一个程序n个线程，每个线程在不同的CPU核心上 线程也有单独的状态机模型，“子状态机” non-deterministic finite automaton（NFA），非确定性有限自动机，多线程的程序具有不确定性 直观认识：thread.h 基本步骤：create，生成并启动线程；join，等待所有线程返回； gcc编译时：-l pthread，文档：man 7 pthreads thread.h是可以修改的，实现各种不同的功能：超大线程栈、detach运行等 实际上是POSIX API 线程的特点：共享内存，独立堆栈 当然也可以定义线程本地变量：__thread __attribute__((noinline)) 多线程带来的三个问题 原子性：使某一条指令独占处理器执行 那多线程呢？线程可能会被打断 多处理器呢？其他处理器也要等 现代处理器指令集呢？add都不是原子的（可能涉及隐含的mov操作） c - Is the following Assembly Atomic, If not, Why? - Stack Overflow 使用常见算法进行互斥？许多算法只适用于两个线程的原子性保持 实现原子性： 临界区，上锁，解锁； 使用队列解决，参照Windows API； 要进行任务拆分，形成worker线程； 线程池； 执行顺序的丧失： 一部分是由编译器优化造成的：内存读写次数的优化 保护执行顺序： 编译器屏障——内存屏障（memory barrier） asm volatile (&quot;&quot; ::: &quot;memory&quot;); 保持编译后的代码（汇编的语义）与C语言代码的语义一致； 为什么带有缓冲区的printf可以在多线程情况下正常调用？已经考虑到了线程安全； 即不会出现 一个长字符串 插入到 另一个长字符串中 的情况 stdatomic.h 可以手动进行内存同步： 设置一个全局变量FLAG，取FLAG中的后两位bit （主线程，或者main函数里）FLAG初始化为0 _sync_synchronize()进行全内存同步（确保线程看到的FLAG都是0） 子线程通过异或修改FLAG的位 [[TODO]] 多处理器情况下可见性的丧失 [[TODO]] Peterson算法 使用共享内存实现互斥 [[TODO]] 互斥 原子指令 什么叫原子化？：执行过程中不能被打断； x86 lock指令前缀。为啥是前缀？因为要先去上锁； xchg，实际上是exchange 其实原子化和自旋锁问题早就有了 双路CPU，谁可以访问内存？ 当时可以实现总线锁：CPU和缓存、内存间沟通都需要经过总线，总线加锁就安全了 当代CPU 缓存一致性 会给处理器增加很大性能负担 其实都是load（读取或载入数据） -&gt; exec（执行一些步骤） -&gt; store（把执行结果写回） RISC-V：LR&#x2F;SC，检测锁的拥堵 自旋锁（spin lock）- 软件无法完美实现，就靠硬件来做 一个线程加锁，其他线程重复询问锁，若仍获取不到锁则等待 特点：循环等待，也叫忙等 缺点：原子指令本身就有开销；忙等导致性能损失严重，处理器利用率低下；正在运行的线程可能会被调度，导致锁无法及时释放； 适用场景 争抢锁的概率很小，或者几乎没有； 在抢占锁的时候禁止调度； 几乎只在操作系统内核代码里应用； 互斥锁（mutex lock） - 用户态无法完美实现，就靠内核态来做 性能评价维度：伸缩性（Scalability） 互斥锁的锁一般由操作系统控制 一个线程加锁，其他线程询问锁，若获取不到则被调度； 特点：循环等待，但不忙等； 与自旋锁之间的区别 自旋锁：下限很快（直接进临界区），上限很慢（忙等） 互斥锁：下限没那么快（进出内核），上限没那么慢（不会忙等） Futex：快速的互斥锁 futex &#x3D; fast user mutex 实际上是改良了的自旋锁和互斥锁 原子指令上锁 上锁成功即直接进入互斥区 上锁失败自动调用内核API被调度 二八定律 pthread_mutex man futex model checker? “找到你依赖的假设，并大胆地打破它” PV问题（大题考点） 解题的一般流程 检查有几类进程？一般每一类进程都对应着自己的函数 先在函数内部用中文描述进程动作；注意执行次数 只做一次 不断重复：while(1) 理清在执行进程前，要P什么 注意：P和V是配对的，有P必有V；当发现需要P时，写完这个P必须先找它对应的V的位置，而不是去分析下一个P 注意隐含的互斥问题，例如缓冲区访问 PV写完之后去定义信号量（和信号量本身的PV） 如果存在很多个P，需要检查会不会发生死锁，会发生的话则想办法解决 只有多个P存在时才可能发生死锁，因为需要请求和保持条件 CPU指令流水线[[TODO]]","tags":[{"name":"OS","slug":"OS","permalink":"http://wiki.zhouweitong.site/tags/OS/"},{"name":"进程","slug":"进程","permalink":"http://wiki.zhouweitong.site/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://wiki.zhouweitong.site/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"锁","slug":"锁","permalink":"http://wiki.zhouweitong.site/tags/%E9%94%81/"},{"name":"互斥","slug":"互斥","permalink":"http://wiki.zhouweitong.site/tags/%E4%BA%92%E6%96%A5/"},{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Lua版本、特性、数据结构和变量","date":"2023-02-28T06:00:00.000Z","path":"wiki/Lua/Lua版本、特性、数据结构和变量/","text":"Lua分支和版本 Lua有诸多版本和分支，其中最著名的当属以下三个： Lua官方版本：Lua: download，由Lua社区维护； Windows版：Lua Binaries Download (sourceforge.net) Linux版：apt-get install lua5.4就可以安装Lua 5.4（最新的大版本） LuaJIT：侧重于Lua的解释执行（即时编译）。Download (luajit.org)； Linux版：同样apt-get install luajit xLua：由腾讯公司开发，用于Unity程序内嵌Lua。Tencent&#x2F;xLua (github.com) Lua不存在官方创建的、给第三方库提供托管服务的网站（类比npm）。常用的第三方库的获取和安装主要有以下两种办法： 从源码安装。这包括： 纯Lua库，下载、解压到require加载路径下，导入即可； C库，下载、配合Lua源码（lua.h等）进行编译（Linux下会生成.so文件），设置package.cpath，然后导入； C库需要的Lua源码，Linux下可以通过apt-get install liblua5.4-dev来安装； LuaRocks平台，可以当作第三方包管理器（Package Manager）使用 建议Linux平台下载源码并编译安装： 1234sudo apt-get install liblua5.4-dev./configuremakesudo make install IDE：一般很少使用IDE来编写Lua代码，但可以参考： 文本编辑器+LSP Server，如NeoVim； 调试器，如slembcke&#x2F;debugger.lua (github.com) 一些成型的IDE，但往往不能支持最新版本Lua，如ZeroBrane Studio 语言特性 Lua是解释型语言； 因此，Lua也是有opcode和bytecode的，运行在VM之上； lua&#x2F;lopcodes.h at master · lua&#x2F;lua luac和luajit也可以编译.lua，但执行仍需解释器（可以理解为类似.py到.pyc的过程）； Lua解释器本体极小，且完全由C语言写成，因此可以很方便的： 嵌入到其他大型程序中，如文本编辑器、游戏、开发工具等等； 与高性能的C语言程序结合，拓展其功能，如nginx-lua-module； 使用其编写功能完善的程序，并应用于嵌入式系统中，如openwrt的luci便是cgi+lua； Lua语言是弱类型语言 Lua语言是面向过程的语言，但可以模拟面向对象 Lua的版本与版本之间差异较大 运行于官版Lua上的库，可能无法兼容luajit或xLua； 运行于Lua 5.1上的库，可能无法兼容Lua 5.2（不向后兼容）； 同样地，运行于Lua 5.2上的库，可能无法兼容Lua 5.1（不向前兼容）； 基本结构 由于不同的Lua分支可能在语法上有差异（甚至可能有不同的opcode），所以此处以官方版本语法为准 注释 单行注释：-- 1-- Test 多行注释：--[[ --]] 12345--[[ThisisComment--]] 数据类型 Lua共有8个基本类型 nil：表示无效值&#x2F;值不存在，可转换为布尔型的false 未初始化的变量，访问即可得到其值nil 将nil赋值给变量等同于将该变量删除，此后内存空间会被GC（垃圾回收器）自动回收 boolean：布尔型，值为true或者false number：数字类型，保存一切数字数据，为双精度浮点型（即C中的double） string：字符串。双引号或单引号包裹字符串字面量。 function：函数，类似于C中的函数指针（只不过不需要各种间接访问符）。既可以是Lua中定义的函数，也可以是C插件中定义的函数。 thread：非抢占式协程（用户态线程），变量本身可看作是协程的handler。 Lua实现抢占式多线程（甚至是多进程）需要使用第三方库 协程只能支持并发（时间段内同时）而不支持并行（时间点上同时） Lua Lanes - multithreading in Lua table：表，Lua中最重要的数据类型之一，兼具数组和Map的特征，同时可以用于模拟面向对象编程 userdata：纯内存空间。主要用于Lua环境与C插件间的变量交互，例如在Lua中给C插件生成的C语言结构体开辟空间 判断变量的类型：type(xxx) 变量及其赋值 Lua变量赋值时均不用指定数据类型。以下是最简单的、合法的变量定义语句： 1a = 10 变量只有两种作用域类型：局部变量、全局变量。没有被local关键字修饰的变量均是全局变量 12345678a = 10 --全局变量local b = 20 --局部变量function add() c = 30 --全局变量，add函数以外仍可以访问 local d = 40 --局部变量，add函数结束就销毁 b = 50 --作用域外的全局变量或局部变量均可被重新赋值end 赋值语句：分为单值赋值语句和多值赋值语句 单值赋值语句：与C语言几乎相同：task.m_1 = task.m_1 + 2 多值赋值语句：可同时定义并初始化多个变量： a, b, c = 10, 2 + 2, 3.14 多值赋值语句的特例： 可以用于快速交换两个变量的值：x, y = y, x 变量个数少于值的个数，多余的值会被忽略：a, b = 10, 11, 12，12会被忽略 变量个数多于值的个数，多余的变量不会被定义 [[TODO]]","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"Lua","permalink":"http://wiki.zhouweitong.site/tags/Lua/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"Lua","slug":"Lua","permalink":"http://wiki.zhouweitong.site/categories/Lua/"}]},{"title":"认识CUDA","date":"2023-02-28T03:00:00.000Z","path":"wiki/CUDA/认识CUDA/","text":"CUDA是？ 是适用于NVIDIA GPU的通用目的GPU（GPGPU）并行编程平台 安装？：CUDA Toolkit 12.0 Update 1 Downloads | NVIDIA Developer 用什么编译器？：实际上是NVIDIA自己的nvcc CUDA语言是C++的超集，因此可以和C++混编 nvcc会将非CUDA部分的代码送给其他编译器（如MSVC或clang）编译，自己编译CUDA部分代码 CMake、Visual Studio均支持CUDA项目 开发环境：Visual Studio + CUDA Toolkit最常见 基本结构 一般含有CUDA代码的源码文件，扩展名改为.cu 头文件：#include &lt;cuda_runtime.h&gt; 入口点 程序入口点依然是C++中的int main()函数 程序不会在入口点就在GPU上执行，而是依然在CPU上执行 关键字 CUDA通过特殊定义的关键字标识代码在CPU上执行，还是在GPU上执行 修饰函数的关键字，用法：__global__ void func() &#123;&#125; __device__：由GPU调用，在GPU上执行 __global__：由CPU调用，在GPU上执行 __host__：由CPU调用，在CPU上执行","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"CUDA","slug":"CUDA","permalink":"http://wiki.zhouweitong.site/tags/CUDA/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://wiki.zhouweitong.site/tags/NVIDIA/"},{"name":"GPU","slug":"GPU","permalink":"http://wiki.zhouweitong.site/tags/GPU/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"CUDA","slug":"CUDA","permalink":"http://wiki.zhouweitong.site/categories/CUDA/"}]},{"title":"准备工作与K8s部署","date":"2023-02-27T11:00:00.000Z","path":"wiki/K8s/准备工作与K8s部署/","text":"准备工作 Linux操作系统 Ubuntu、Debian、CentOS、Fedora、RHEL、openSUSE&#x2F;SLES 等主流Linux发行版 Fedora CoreOS、VMware Photon OS等“容器专用”OS 足够的RAM和存储：物理机部署时推荐只运行K8s相关程序 Internet连接，或能够访问特定registry（需要提前搭好registry并在registry中添加K8s组件镜像） 物理机之间的网络联通（Worker访问Control的API、Worker与Worker之间的网络甚至存储共享） 安装好部署工具 见下文 安装好CRI-O标准兼容的容器工具，docker、podman、containerd等均可 podman：绝对开源，无服务（无daemon），很适用于Rootless Container模式（低权限），仅支持Linux容器 docker：最主流，有商业版，传统daemon模式（需要root&#x2F;管理员权限），支持Linux容器和Windows容器 containerd：最基础，绝对开源，最标准，是K8s、K3s等默认的CRI-O容器工具，支持Linux容器和Windows容器 可以使用带GUI的容器工具 Podman Desktop Docker Desktop Rancher Desktop 该选哪种部署方式？ 大型生产环境：完整的K8s集群 使用 kubeadm 工具进行部署 有两种节点类型：Control Plane（控制平面，也叫Master）和Worker 适合物理机部署 需要高配置（稳定运行最好2thread+8GB） 最好多个物理机（Control Plane和Worker隔离，应用容器只部署在Worker上），最好3台以上（1 Control + 2 Worker） 小型生产环境：K3s 由rancher公司开发维护 直接使用k3s工具进行部署 有两种节点类型Server和Agent，默认单节点Server 裸机部署和虚拟机部署均可 配置需求低（1thread+512MB足够） 本地测试环境：minikube 由K8s官方维护 不建议暴露在公网 很多默认配置都是以localhost或内网为基础的 默认是单节点 可以扩展为多节点 其他：Microk8s，Canonical公司开发与维护，使用snap部署 部署K3s 如果需要关闭已有的K3s集群：k3s-killall.sh 安装 主节点（Server） curl -sfL https://get.k3s.io | sh - 默认安装的selinux规则太旧 手动安装新的。以CoreOS为例：sudo rpm-ostree install https://github.com/k3s-io/k3s-selinux/releases/download/v1.2.stable.2/k3s-selinux-1.2-2.el8.noarch.rpm 子节点（Agent） 要先找主节点的token，再记录主节点的ip地址 sudo cat /var/lib/rancher/k3s/server/node-token ip addr 然后使用安装命令，加入特殊变量 curl -sfL https://get.k3s.io | K3S_TOKEN=&quot;&lt;主节点token值&gt;&quot; K3S_URL=&quot;https://&lt;主节点ip地址&gt;:6443&quot; sh - systemd service文件位置 主节点：/etc/systemd/system/k3s.service 子节点：/etc/systemd/system/k3s-agent.service 升级 依然使用curl在线获取升级脚本，版本号可去 Releases · k3s-io&#x2F;k3s 查看，使用环境变量 INSTALL_K3S_VERSION 指定新版本 主节点 curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=&lt;版本号&gt; sh - 子节点 curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=&lt;版本号&gt; K3S_TOKEN=&quot;&lt;主节点token值&gt;&quot; K3S_URL=&quot;https://&lt;主节点ip地址&gt;:6443&quot; sh - 部署Minikube 如果要删掉已有的Minikube集群 停止：minikube stop 删除：minikube delete --all 借助containerd和podman，启动新集群 minikube start --driver=podman --container-runtime=containerd --listen-address=0.0.0.0","tags":[{"name":"K8s","slug":"K8s","permalink":"http://wiki.zhouweitong.site/tags/K8s/"},{"name":"K3s","slug":"K3s","permalink":"http://wiki.zhouweitong.site/tags/K3s/"},{"name":"Minikube","slug":"Minikube","permalink":"http://wiki.zhouweitong.site/tags/Minikube/"}],"categories":[{"name":"K8s","slug":"K8s","permalink":"http://wiki.zhouweitong.site/categories/K8s/"}]},{"title":"mangle与demangle","date":"2023-02-25T13:20:00.000Z","path":"wiki/CPlusPlus/编码规范/mangle与demangle/","text":"Example.cc：测试程序 Example.s：使用g++ -S编译后的汇编文件 观察函数名，发现似乎函数名经过了某种编码 void Test::func_1()：_ZN4Test6func_1Ev static std::string func_2(int in_a)：消失 原因：inline Test* Test::func_3(double in_b)：_ZN4Test6func_3Ed int test_2(std::string in_c, uint16_t in_d)：_Z6test_2NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEt 原因：mangle 因为C++可以函数重载和重写引入的功能 本质就是对函数的命名空间（比如哪个类或者哪个namespace）、函数名、函数参数进行编码 注意：不编码函数返回值 可以被解码 不同编译器编码规则不同，一般以g++为例 解码：demangle 使用工具 c++filt 包含在binutils软件包中","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"编码规范","slug":"编码规范","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"编码规范","slug":"C/编码规范","permalink":"http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"单元测试与模糊测试","date":"2023-02-25T13:00:00.000Z","path":"wiki/CPlusPlus/编码规范/单元测试与模糊测试/","text":"单元测试：Unit Test，特点是作者需要指定正确的输入数据和输出结果 单元测试的目的在于验证逻辑正确性 模糊测试：Fuzz Test&#x2F;Monkey Test，特点是由程序库&#x2F;其他工具随机生成输入数据，通过规则校验输出结果 模糊测试的目的在于验证代码鲁棒性 单元测试库：Gtest&#x2F;Gmock vcpkg install gtest:x64-windows 需要新建项目，或者新建文件 [[TODO]] 模糊测试库-LibFuzzer[[TODO]]","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"编码规范","slug":"编码规范","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"编码规范","slug":"C/编码规范","permalink":"http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"其他规则","date":"2023-02-25T12:50:00.000Z","path":"wiki/CPlusPlus/编码规范/其他规则/","text":"不能在类的析构函数中抛出异常； 建议父类的析构函数均声明为虚函数；建议有其他虚函数的类其析构函数也要声明为虚函数； 定义函数时，要做到想清楚以下几点： 先验条件（Preconditions）：函数需要什么样的输入？ 例如：sqrt(x)，x&gt;&#x3D;0 后验条件（Postconditions）：函数保证提供什么样的输出？ 例如：sin(x)一定返回(-1, 1) 不变量（Invariant）：函数不能改变哪些东西？ 例如：sin(x)中不会改变x的值 副作用（Side effect）：函数改变了哪些它作用域以外的东西？ 例如：file.write()改变了写入的文件内容 目的（Propose）：你写的函数是否有清晰的目的？函数是否达到了它的目的？ 例如：ChangeStudentName()：写它是为了修改学生姓名，它也确实修改了学生姓名 函数名（Name）：函数名是否清晰地传达了函数的目的？ 例如：Name()一般来说就不是一个好名字——对“Name”做了什么？ 函数参数名（Parameter）：函数参数名是否清晰易懂不会混淆？ 例如：ChangeStudentName(a, b, c)：a、b、c具体是什么东西？ 不要在仿函数的operator()调用中修改数据成员，即保持其无状态（Stateless）； 单行定义单个变量时，&amp;或*应紧贴类型名：int* a; 单行定义多个变量时，&amp;或*应紧贴变量名：int *a, &amp;b; 为避免出现冲突，头文件不应该包含using语句； [[TODO]]","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"编码规范","slug":"编码规范","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"编码规范","slug":"C/编码规范","permalink":"http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"函数参数规则","date":"2023-02-25T11:50:00.000Z","path":"wiki/CPlusPlus/编码规范/函数参数规则/","text":"大体上可以分为三种传递类型：传值、传指针和传引用 传值：新建临时变量（形参名即是变量名），使用赋值将外部的参数值传递给临时变量 传指针：指针本身是基本类型（int或int64）进行传值，而不涉及到指针指向的内存区域的复制 传引用：相当于给外部的参数值设置单独的别名和访问权限，本质也是传指针，可看作是传指针的语法糖 三种传递类型的优缺点 传值：最直接，而且临时变量与外部变量完全无关；复制开销很大，尤其是对于对象等较大的变量时； 传指针：能节省很大开销，C语言也可以使用；还是发生了传值过程，使用不方便； 传引用：几乎节省全部开销，能很好与C++的左右值和重载功能相结合；不是所有场合都适合传引用； 综合各优缺点，得出的使用规则： 基本类型传值、传引用和传指针均可，但必须是单个变量等级的传递 对象的传递，包括标准模板库生成的对象，必须传递引用，除非是下面的情况： 在需要兼容性的情况下（如Windows API编程）可能不允许传递引用，此时对非基本类型的数据应首先考虑传递指针 概括：传引用（常用）-&gt; 传指针（兼容性）-&gt; 传值（基本类型）","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"编码规范","slug":"编码规范","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"编码规范","slug":"C/编码规范","permalink":"http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"Google编码规范","date":"2023-02-25T11:00:00.000Z","path":"wiki/CPlusPlus/编码规范/Google编码规范/","text":"好的标准？ 标准容易记住，也容易实践； 积极维护和更新，确保标准符合业务发展和技术发展； 多消耗写代码者的精力，确保读代码者的体验； 标准要整体一致，方便写自动化的格式检查工具； 参照国际标准，但不需要全盘接纳，可以禁用某些标准库并使用更好用、更统一的第三方库； 不要使用风险较大的语言功能； 在优化性能时，允许降低代码可读性、允许使用危险功能； 避免复杂的类结构和其他数据结构； 代码规模越大，注意的事情越多，标准也会越多； C++版本 使用主流C++版本（C++17）开发 C++20、C++23还在被编译器实现中，部分已经稳定的功能可以使用 不要使用特定编译器的独有功能，除非特殊说明并附带详细注释 头文件和文件头 源码文件建议统一以.cc结尾 每一个源码文件都应该对应一个与其同名的.h文件 单元测试文件除外 小程序（行数很少，且包含main()函数）除外 头文件应彼此独立 需要带有#define类似的 包含保护，避免循环包含 问题 头文件内应include所有 被该头文件本身 和 被该头文件对应的.cc依赖的 所有其他头文件 例外：如果是将include用作文本插入，则待插入的文本应单独存为.inc文件，然后在适当位置#include “xxx.inc” 包含保护：#define 项目路径（每一个子路径用下划线分割）_文件名_H_ 例如：#define SRC_WEB_HTTP_H_，即src/web/http.h 不要使用前置声明 函数小于10行，或必须使用内联函数时，才应该在头文件内定义内联函数 #include的顺序 第一位：优先头文件，例如a.cc对应a.h，则这个位置应该放a.h 第二位：C系统头，包括C自带的头文件和操作系统等使用C语言格式的头文件（系统路径），可加extern关键字 第三位：C++系统头，包括C++自带头文件、STL、其他C++库的头文件（系统路径）等 第四位：其他库的.h文件（不在系统路径） 第五位：同项目的.h文件（不在系统路径，且除去优先头文件） [[TODO]]","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"编码规范","slug":"编码规范","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"编码规范","slug":"C/编码规范","permalink":"http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"CMake基础","date":"2023-02-25T08:00:00.000Z","path":"wiki/CPlusPlus/CMake/CMake基础/","text":"跨平台的“编译器所需文件的生成器” Make是什么 相当于自动执行多个文件的编译与链接 只需一个配置文件，就可根据配置文件自动生成命令然后执行 同时应用了增量编译的思想：文件没有做出修改就不会重新编译 只显示自动生成的编译命令而不运行：make --dry-run Make有什么缺点？ 语法不够复杂，许多高级功能实现不了 GNU系软件，没有官方的对Windows的支持 与GCC结合紧密，但与其他编译器结合可能会出现问题 需要明确指明项目与项目间（或项目与子模块）的依赖关系 CMake解决了这些问题 高级和复杂的语法，适应多种情况 自动检测源文件和头文件的关联 针对不同平台的不同编译器生成不同的项目文件&#x2F;编译命令 相关概念 需要将配置写在CMakeLists.txt里 编译模式 源码混杂编译：In-Source，部分编译文件（如Makefile等）会生成在根目录下 cmake . 源码分离编译（最常用）：Out-of-Source 常常是在源码目录里建build文件夹，做shell的工作目录（Working Directory） 所有编译相关的文件均会放置在build子目录下 删除build文件夹即可完全重新编译 cd build/ &amp;&amp; cmake .. 头文件 对于C++来说： C++是强声明的语言，在没有声明时 是不知道一个名字是变量、函数还是类的 #include是预处理命令，本质上就是文件的插入，相当于把被include的文件的内容复制粘贴过来 因此会遇到 重复定义问题、循环包含问题 和 include顺序不同导致编译结果不一样 等问题 解决办法： include顺序固定 使用宏#pragma once 使用宏#ifdef、#ifndef 使用模块（C++20） 两种include的语法 双引号 #include &quot;&quot;：先找工作目录，再找系统目录 尖括号 #include &lt;&gt;：直接找系统目录 为什么有双引号include方式还要保留尖括号方式？：可以避免工作目录内同名的其他文件 &lt;cxxx&gt;和&lt;xxx.h&gt;没有必然联系，有些头文件中会检测当前语言是否为C++，是的话自动添加extern &quot;C&quot;&#123;&#125; 库 分为静态库和动态库 静态库链接时会直接插入到程序中，动态库则只会向程序中插入“插桩”代码（PLT表） 动态链接库的查找位置 Windows：程序同文件夹 -&gt; PATH内目录（用户PATH -&gt; 系统PATH） *nix：ELF程序的RPATH -&gt; /usr/lib -&gt; /lib 命令 cmake --version：当前CMake版本号 cmake -H&lt;path1&gt; -B&lt;path2&gt;：使用CMake生成文件。在path1中查找CMakeLists.txt，在path2子目录中存放所有编译文件 cmake -D&lt;flag&gt;：设置CMake编译选项 cmake -G&lt;generator&gt;：切换CMake生成针对哪个编译器的项目文件 [[TODO]] 函数 函数名是不区分大小写的，但变量名&#x2F;关键字是区分大小写的。关键字一般都是大写，变量名（除系统定义的之外）建议小写 project(xxx)：指定项目名 设置项目语言：project(xxx LANGUAGES CXX)；CXX：即C++ 1project(hello_world LANGUAGES CXX) cmake_minimum_required(VERSION xxx)：指定最低CMake版本号 1cmake_minimum_required(VERSON 3.22) add_executable(AAA, BBB)：把BBB文件编译成AAA，AAA是目标文件名 1add_executable(hello.elf hello.cc) set(AAA, BBB)：把AAA变量（定义并）内容设置为BBB file()：查找文件，并将结果写入变量 target_include_directories()：相当于cmake -I，设置头文件查找文件夹 12345# 下面的语句相当于 -I ./includetarget_include_directories(target PRIVATE $&#123;PROJECT_SOURCE_DIR&#125;/include) 如何给项目添加多个文件？将多个文件编译为一个目标时，可使用如下方法 直接在add_executable里指定文件，add_executable(xxx a.cc b.cc c.h) 12345# 源码文件顺序固定add_executable($&#123;PROJECT_NAME&#125; main.cc hello.cc) 使用变量，不推荐。set(YYY a.cc b.cc c.h) add_executable(XXX $&#123;YYY&#125;) 1234567891011# 可以定义单行的变量set(SOURCES main.cc)# 也可以定义多行的变量set(SOURCES main.cc hello.cc)# 定义好的变量可以在接下来的语句中使用# 比如添加编译目标add_executable($&#123;PROJECT_NAME&#125; $&#123;SOURCES&#125;)# 注意，现代CMake中已不推荐使用这种变量的方式 使用file()函数动态检测，即使用通配符的自动添加，不推荐：顺序不固定，且易丢失文件。 1234# GLOB：globbing表达式的结果形成列表# SOURCES：结果写入SOURCES变量file(GLOB SOURCES &quot;*.cc&quot;)add_executable($&#123;PROJECT_NAME&#125; $&#123;SOURCES&#125;) 变量 使用$&#123;xxx&#125;来使用变量 1$&#123;PROJECT_NAME&#125; PROJECT_NAME：由project()产生 CMAKE_SOURCE_DIR：源码目录 CMAKE_BINARY_DIR：编译目录 子文件夹相关变量 CMAKE_CURRENT_SOURCE_DIR：当前源码目录 CMAKE_CURRENT_BINARY_DIR：当前编译目录 子模块相关变量 PROJECT_SOURCE_DIR：当前项目源码目录 PROJECT_BINARY_DIR：当前项目编译目录 子模块 可以将不同模块的源码放置在不同的子目录下 头文件除外。头文件应当放置在同一个目录下，如include/ 头文件的目录也可以拥有子目录，如include/hello/ 主项目CMakeLists.txt add_library()：添加子模块，为库 STATIC：指定库的类型是静态链接库 target_include_directories()：设置包含子模块的头文件文件夹 target_link_libraries()：将库链接到 目标ELF文件 中 12345678910111213141516171819add_library(hello_library STATIC hello/hello.cc)# PUBLIC：library自己和引用该library的程序同时能够访问这些头文件target_include_directories(hello_library PUBLIC $&#123;PROJECT_SOURCE_DIR&#125;/include)# 此处的源码文件名不需要包括子模块中的文件名add_executable(hello.elf main.cc)target_link_libraries(hello.elf PRIVATE hello_library) 头文件在子文件夹内怎么办？ 有如下的子模块和文件 1234main.ccCMakeLists.txtmylib/hello.ccmylib/hello.h A. 可以不在CMakeLists.txt文件中写target_include_directories() main.cc中可以按如下方式引入mylib/hello.h：#include &quot;mylib/hello.h&quot; B. 也可以将target_include_directories()写成 1234target_include_directories(hello_library PUBLIC $&#123;PROJECT_SOURCE_DIR&#125;/mylib) main.cc中可以按如下方式引入mylib/hello.h：#include &quot;hello.h&quot;或是#include &lt;hello.h&gt; 有如下的子模块和文件 1234main.ccCMakeLists.txtmylib/hello.ccinclude/mylib/hello.h 如下编写target_include_directories() 1234target_include_directories(hello_library PUBLIC $&#123;PROJECT_SOURCE_DIR&#125;/include) main.cc中按如下方式引入mylib/hello.h：#include &quot;mylib/hello.h&quot;","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"CMake","slug":"CMake","permalink":"http://wiki.zhouweitong.site/tags/CMake/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"CMake","slug":"C/CMake","permalink":"http://wiki.zhouweitong.site/categories/C/CMake/"}]},{"title":"P1-随机事件与概率","date":"2023-02-24T15:00:00.000Z","path":"wiki/数学/概率论与数理统计/P1_随机事件与概率/","text":"随机试验[[TODO]] 样本空间[[TODO]] 事件 基本事件 必然事件 不可能事件 事件关系 包含 相等 互斥 对立 事件运算 积事件：集合取交 取公共部分 互斥的积为空集 和事件：集合取并 取所有覆盖部分 对立的和为全集 差事件 取”一个抠掉另一个后的剩余部分“ 运算规律 不存在“消去率” AB&#x3D;AC并不是B&#x3D;C 交换率 分配率 对偶率 not(A and B) &#x3D; not(A) or not(B) not(A or B) &#x3D; not(A) and not(B) not(A - B) &#x3D; not(A) or B 概率 性质 条件概率 计算公式： P(B|A) &#x3D; P(AB)&#x2F;P(A) 用于缩减样本空间 独立性 与互斥区分 互斥：P(AB)&#x3D;0 独立：P(AB)&#x3D;P(A)P(B) 非互斥非独立：P(A or B)&#x3D;P(A)+P(B)-P(AB) 不可能事件与任意其他事件既独立又互斥 A包含B时，A、B独立 P(A)&#x3D;0时，P(AB)&#x3D;0 P(A)&#x3D;1时，P(AB)&#x3D;P(B) 三个事件相互独立：P(ABC)&#x3D;P(A)P(B)P(C) 五大公式 加法公式 减法公式 乘法公式 全概率公式 贝叶斯公式 概率型 古典型概率 有限 等可能 几何型概率 n重泊努利试验 从中得到二项分布公式 注意事项 不可能事件（空集）的对立事件（取反）是整个事件集合（全集） 概率不能得出事件的结论，事件可以得出概率的结论 概率为0的事件不一定是不可能事件，不可能事件的概率一定是0","tags":[{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%B0%E5%AD%A6/"},{"name":"概率论","slug":"概率论","permalink":"http://wiki.zhouweitong.site/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"数理统计","slug":"数理统计","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"随机事件","slug":"随机事件","permalink":"http://wiki.zhouweitong.site/tags/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}]},{"title":"UML图","date":"2023-02-24T13:00:00.000Z","path":"wiki/CPlusPlus/UML图/","text":"UML包括许多种类的图，其中使用最广泛的就是类图（Class Diagram）和时序图（Sequence Diagram）。 类图 表达类（Class）的结构、类与类之间关系和包（Package）的结构的图； 类的结构 属性（Attribute）：同一个类中的成员变量；&lt;保护符&gt; &lt;属性名&gt;: &lt;属性类型&gt;； 例如：- name: std::string 操作（Operation）：同一个类中的成员方法；&lt;保护符&gt; &lt;方法名&gt;(): &lt;返回值类型&gt;； 例如：+ getName() : std::string 三种详细等级 概念型：只写类名 标准型（说明型）：类名、属性名、重要的方法名以及成员可见性。此时可以省略属性和方法的类型。 实现型，怎么详细怎么写，包括类名，属性名、属性类型，所有方法的方法名、方法形参、方法形参的出入类型、方法的返回值类型，成员可见性等。 四种成员可见性（Visibility）：同 面向对象编程语言中类的成员保护符； public：公开，+ private：私有，- protected：受保护的，# package：在同一个包内，~ 抽象方法：同面向对象编程语言中类的抽象方法，使用斜体表示 成员方法的形参：&lt;参数方向&gt; &lt;参数名&gt;: &lt;参数类型&gt; 三种参数方向类型 in：仅供输入，类似于函数的普通形参，例如：int test(int a) 此处的 a。 out：仅供输出，类似于函数将指针&#x2F;引用作为形参，且函数内只修改、不读取该指针&#x2F;引用的值。 inout： 既是输入又是输出，类似于函数将指针&#x2F;引用作为形参，读取了该指针&#x2F;引用的值，修改后再写回。 参数或属性拥有默认值：在参数后加上=&lt;默认值&gt;即可； 抽象类&#x2F;接口：类名上方标&lt;&lt;abstract&gt;&gt;&#x2F;&lt;&lt;interface&gt;&gt;； 对象图 用于表示已实例化的类，即对象 标题带下划线，且会用冒号指明实例化自哪个类（对象名: 类名） 等号右侧的值是实际值&#x2F;期待返回的实际值，而不是默认值 对象间关系只有关联、依赖、共享聚集和组合聚集 对象图常常以独立的图的形式出现（即一张图都是对象） 类间关系 关联（Association） 单纯的一个类和另一个类有数量上的松散关系，两个类彼此是独立的 这种联系是松散的而不是逻辑的（即不是一个包含另一个或一个继承另一个之类的强联系） 举例：飞机关联航线，航线关联飞机 线型：实线，无箭头 线上写联系的简要描述（文字描述&#x2F;函数名），下同 数量关系，下同 1：一对一 n：一对n 0…1：可选，即没有或有1个 0…n：至少0个（没有），至多n个 0…*：任意多个 1…*：至少有1个 m…n：至少有m个，至多有n个 单项关联（Unidirectional Association） 只有一个类与另一个类有数量上的逻辑关系 举例：提现请求与支付宝账号 类型：实线，普通箭头，箭头从一个类出发指向与其关联的另一个类 继承（Inheritance） 同C++中类的继承，子类获得父类的部分属性和方法并可以重载 举例：老师继承自人 类型：实现，空心三角箭头，由子类指向父类 很少见到继承的数量关系 实现（Implement） 同C++&#x2F;Golang中的抽象类&#x2F;接口的实现，且一般只在有抽象类&#x2F;接口时才会使用 举例：正方形类实现了形状抽象类 类型：虚线，空心三角箭头，指向被实现的抽象类&#x2F;接口 很少见到实现的数量关系 依赖（Dependency） 表示一个类与另一个类有简单的依赖关系，一般是方法上的依赖 举例：学生类的阅读方法依赖书类 类型：虚线，普通箭头，指向被依赖的类 共享聚集（Aggregation） 类互相独立但可以聚集为一个新的类。当这个类消失时，聚集成它的类不会消失 举例：课桌类可由椅子类和桌子类聚集。课桌拆散时桌子、椅子还在 类型：实线，普通箭头，空心菱形线头。线头在聚集成的类处，箭头指向各个子类 组合聚集（Combination） 子类互相独立但必须依存于组合成的类存在。当组合成的类消失时，这些子类也会一并消失 举例：公司可由公司的各个部门组合。公司解散后各部门也不复存在 类型：实线，普通箭头，实心菱形线头。线头在组合成的类处，箭头指向各个子类 杂项 注释 一般放置在图旁边（或包范围内），起解释说明作用； 包","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"UML","slug":"UML","permalink":"http://wiki.zhouweitong.site/tags/UML/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"}]},{"title":"SVN、Git区别","date":"2023-02-24T07:00:00.000Z","path":"wiki/版本控制/SVN、Git区别/","text":"Git：分布式的（Decentralized）版本控制软件 SVN：中心化的（Centralized）版本控制软件 Git 优点： 去中心化 避免单点故障（服务器下线）导致Repo无法访问； 不需要服务器也可完成大多数功能； 可以用本地Git Repo初始化服务器上的Git Repo； Merge&#x2F;Rebase流程完善 适合大量成员共同在单个Repo内开发； 缺点： 学习曲线陡峭，非计算机专业人士入门困难； 即使有Git LFS，Git对大文件的支持仍然一般； 权限控制粒度不细 一个用户能访问Repo，就能访问Repo中的所有文件和历史； 一个用户Clone了完整的Repo，就能将它放到某个Git服务器上开始分析和分发； SVN 优点 原生支持大文件版本管理，性能高； 功能简单直接，入门难度低； 各SVN GUI软件更加完善、人性化 与Git的正向Delta不同，SVN采用反向Delta，降低存储占用、提升拉取性能； SVN本体十分稳定，更新及出现安全问题概率低，有利于进行二次开发； 权限控制完善 支持用户名+密码、用户名+令牌（Token）、LDAP等多种不同认证方式的同时，还可结合Web服务器的功能提供更多验证方式； 可设置用户和用户组，读写权限可精确到Repo下的单个文件 缺点 中心化 服务器出现问题（单点故障）会导致开发无法继续，或数据（提交历史等）永久丢失； 可以改造为“多中心”模式：增加类似“服务器间同步”的功能，或使用特殊的分布式文件系统储存服务端文件； 例如：WANdisco 与 VisualSVN 必须有服务器的存在 即使是本地Repo进行开发，也要启动SVN Server； 失去服务器的情况下操作受限； 大量成员共同在单个Repo内开发时，服务器有持续较高负载；","tags":[{"name":"SVN","slug":"SVN","permalink":"http://wiki.zhouweitong.site/tags/SVN/"},{"name":"Git","slug":"Git","permalink":"http://wiki.zhouweitong.site/tags/Git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://wiki.zhouweitong.site/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Version Control","slug":"Version-Control","permalink":"http://wiki.zhouweitong.site/tags/Version-Control/"},{"name":"优缺点","slug":"优缺点","permalink":"http://wiki.zhouweitong.site/tags/%E4%BC%98%E7%BC%BA%E7%82%B9/"}],"categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://wiki.zhouweitong.site/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}]},{"title":"计组笔记_指令、存储","date":"2023-02-23T13:00:00.000Z","path":"wiki/计算机组成/计组笔记_指令、存储/","text":"指令系统指令格式 CPU控制器的主要功能之一：解析指令，协调各部件工作 一台计算机所有指令的集合称为该计算机的指令系统，也称指令集 例如：x86、arm、mips 一条指令通常包括两个部分 操作码：要做什么 地址码：要对谁操作 依照地址码数目分类 零地址指令 不需要操作数的情况：如nop（空指令）、hlt（停机）等 $ OP $ 与栈配合使用，数据已预先压在栈顶：如syscall（系统调用） 单地址指令 只需要一个操作数：加1、减1、取反等 $ OP(x) \\rightarrow x $ x：数据的地址，(x)：地址中的内容（间接访问） 三次访存：读OP、读x、写x 需要两个操作数，另一个操作数在栈上&#x2F;寄存器中 假设隐含在ACC中 $ (ACC)OP(x) \\rightarrow ACC $ 数据压回栈&#x2F;写回寄存器 两次访存：读OP、读x，ACC是寄存器不算访存 二地址指令 需要两个操作数，常用于逻辑运算、算术运算等 $ (A1)OP(A2) \\rightarrow A1 $ 数据写回A1地址指向的区域 四次访存：读OP、读A1、读A2、写A1 三地址指令 需要三个操作数，常用于逻辑运算、算术运算 $ (A1)OP(A2) \\rightarrow A3 $ 数据写回新地址A3 四次访存：读OP、读A1、读A2、写A3 四地址指令 与三地址指令不同点在于，新增加了一个“下一条指令的地址“操作数 $ (A1)OP(A2) \\rightarrow A3, A4 $ …… 以此类推 按长度分类 指令字长 整个指令的长度可以发生变化 定长指令字结构 变长指令字结构 和操作码长度、操作数长度、操作数个数都有关 操作码长 操作码本身的长度可以发生变化 定长操作码 操作码n位，最多$ 2^n $种 译码器设计简单，灵活性低 可变长操作码 译码器设计复杂，灵活性高 机器字长 进行一次整数运算时所能处理的二进制位数 即ALU位数 存储字长 主存一个存储单元的二进制位数 即MDR位数 按操作类型分类 数据传送类 内存到寄存器 寄存器到内存 运算类 算术逻辑操作 移位操作 程序控制类：转移&#x2F;跳转操作 实现程序执行流程的变化 使PC寄存器值发生改变 输入输出类 扩展操作码 是一种固定指令字长、可变操作码长的指令结构 以指令固定长为16位，零、一、二、三地址指令均15个为例 给指令位分段 $ 15&#x3D;2^4-1 $，零地址指令至少需要4个二进制位 $ 16-15&#x3D;1 $，这一个4位编码可用于表示“扩展”——指令码长于4位 构造指令编码 前缀0000～1110为三地址操作码 前缀1111留作扩展位，表示此时操作码大于4位 前缀1111 0000～1111 1110为二地址操作码 前缀1111 1111留作扩展位，表示此时操作码大于8位 前缀1111 1111 0000～1111 1111 1110为一地址操作码 前缀1111 1111 1111保留 1111 1111 1111 0000～1111 1111 1111 1110为零地址操作码 1111 1111 1111 1111未用 习题例子 设计时的要求（类比计算机网络 哈夫曼编码） 不允许短码是长码的前缀 不允许操作码重复 通常情况下：指令使用频率越高，码长越短 指令寻址 目的：确定下一条待执行指令的指令地址 PC寄存器（程序计数寄存器）始终保存下一条指令的地址 顺序寻址：取指令操作完成后，PC寄存器值自动 + 当前指令字长 如果是变长指令字结构：操作码一定会在第一个存储单元（或者第一个字节&#x2F;第一个能载入寄存器长度的二进制位）中 CPU判断操作码需要几个操作数（即计算指令字长），以确定如何修改PC 跳跃寻址：由转移指令给出 数据寻址 目的：确定本条指令的地址码（操作数）指明的真实地址 怎么确定指令的地址码采用什么方式寻址 统一约定 CPU预设 在地址码前加入描述寻址方式的位，例如地址0010，地址吗0001 0010（立即寻址0010） 形式地址（Address） 有效地址（Effective Address） 隐含寻址 立即寻址 直接寻址 间接寻址 寄存器寻址 寄存器间接寻址 相对寻址 基址寻址 变址寻址 堆栈寻址 存储系统DRAM DRAM的刷新 多久刷新 2ms为一个周期 刷新多少 如何刷新 分散刷新 集中刷新 异步刷新：最常用 刷新特点 内存芯片自动操作 对CPU透明 类似读RAM 但不需选片 主存与CPU的连接 主存容量扩充 位扩展 增加同时存储的数据量 字扩展 增加能够存储的数据量 线选法 译码器片选法：内存地址连续 译码器的输出默认高电平有效，若配合低电平有效的片选信号需要使用两端带圈的线段连接（表示取非） 字位扩展 磁盘存储器 磁盘性能指标 磁盘容量 未格式化容量：物理上的 用于存储用途的 磁化单元总数 格式化容量：实际存储信息的总量，会去除掉坏块、备用块等等 格式化容量 &lt; 未格式化容量 记录密度 道密度：半径 位密度：单位圆弧 面密度：道密度x位密度 越内侧的磁道位密度越大 平均存取时间：加和 寻道时间：机械臂移动 旋转延迟时间：盘片旋转 没有明确给出则按半圈计算 传输时间：磁头在盘片上，盘片继续旋转 数据传输率 磁道容量*转速 磁盘地址 驱动器号 柱面&#x2F;磁道号 盘面号 扇区号 工作过程 寻址 读盘 写盘 是独立的操作 有控制字 取控制字 执行控制字 读写串行 不同时进行 与主机连接需要串行-并行开关 磁盘阵列 RAID 廉价冗余磁盘阵列 RAID 0~6 RAID 0：无冗余无校验磁盘阵列 相邻扇区依次存放至不同磁盘，提高速度（条带化） RAID 1：镜像磁盘阵列 同一个数据拷贝并放两个磁盘，浪费100%空间 RAID 2：海明码磁盘阵列 数据和数据的海明码放两个磁盘，浪费75%空间 只能纠一位错 RAID 5：无独立校验的奇偶校验磁盘阵列 空间浪费：1&#x2F;N，N是磁盘数 用到了异或特性 不是奇偶校验码 最多一次只能坏一块盘 固态硬盘 基于闪存技术Flash Memory，也即E2PROM 主控：闪存翻译层 主机提供逻辑块号 闪存翻译层转换为物理块号 一个SSD硬盘包含多个闪存芯片 一个闪存芯片包含多个数据块 一般512K一块 因此属于“块设备” 一个块内包含多个数据页 一般0.5K~4K一页 读写特性 一次读一个块 无用数据会被丢弃 一次写一个页 一次擦除（删除）一个块 如果只需擦除块中的几页，需要先将其他页复制到其它块 直观现象：读快写慢 通过电路选页选块，速度极快 相比机械硬盘来说 电路代替盘片旋转和磁头移动，速度大幅提升 体积小，安静无噪音，抗震 价格高 擦除次数过多会磨损 导致损坏 引入磨损均衡技术 将擦除尽量平均分布在各个块上 动态磨损均衡：写入时找擦除次数更少的块 静态磨损均衡：由主控自动监测处理，让老块多读、新块多写 正常使用情境下，寿命很长，可以接受 Cache 内存速度无法匹配CPU速度，导致性能问题，如何解决？ [[TODO]] 局部性原理 空间局部性：数据 数组 时间局部性：指令 循环 如何让Cache代替部分RAM？或者说如何将RAM拷贝入Cache？：Cache-主存映射方式 全相联映射 自由存储 存储时保存完整的标记位，读取时依次检查各Cache块的标记位 Cache利用率最高 读取时时间消耗最大 直接映射：完全不相联 存放位置与RAM中地址紧密相关 也记录标记，但标记位数最短 读取时间最短 Cache利用率最低 虚拟存储器 由主存和辅存共同组成，统一编址 应用局部性原理，只有当辅存中的数据需要用到时才会调入内存 辅存和主存对编程人员来说边界更加模糊了 例如：打开文件时无需了解文件的哪些数据在主存哪些数据在辅存、地址各是多少 同样存在数据的替换问题和数据的一致性问题 处理一致性问题是只使用回写法：辅存速度太慢，全写法不现实 页式虚拟存储器 扩展的页表：逻辑页号，物理页号，辅存页号，有效位（是否已经调入主存），脏位（数据是否被修改且没回写），访问位（配合LRU算法等） 页 也可以称作 块 段式虚拟存储器 段 按照功能划分，不同段的大小可能不同 段表：需要段号、段的起始地址、段的长度、有效位、脏位等 段页式虚拟存储器 既有段表也有页表，先分段再在段内分页 一个程序一个段表，一个段一个页表 调入和替换等仍以页为单位 CPU访问内存的大体流程 程序提供数据的逻辑地址 逻辑页号 页内偏移（页内地址） CPU依据逻辑页号查找页表 先查找TLB，TLB命中则直接获得物理页号 TLB未命中则访问DRAM中的页表查找，找到后将页表项（键值对）复制到TLB 拼接物理页号和页内偏移得到物理地址 访问物理地址指向的DRAM块 假设1：先找Cache再找DRAM方式 假设2：拥有L1和L2两级缓存 从Cache中找寻DRAM数据 在L1缓存中查找，若找到则继续 L1缓存未命中，则在L2缓存中查找，若找到则继续 从DRAM中读取数据 L1、L2 Cache均未命中，则读取DRAM中的数据，并将数据替换至L1缓存中 假设3：使用LRU算法作为Cache替换算法 [[TODO]]","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://wiki.zhouweitong.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"Computer Architecture","slug":"Computer-Architecture","permalink":"http://wiki.zhouweitong.site/tags/Computer-Architecture/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://wiki.zhouweitong.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}]},{"title":"Wayland下开启Chromium或Edge浏览器的显卡加速","date":"2023-02-22T12:00:00.000Z","path":"wiki/Linux浏览器/Wayland下开启Chromium或Edge浏览器的显卡加速/","text":"Firefox在X11和Wayland情况下均默认启用显卡加速。在大多数发行版环境下、在显卡支持时，可硬件解码开放标准的编码（如VP9、AV1等），或 标准版权已过期的商用标准的编码（如H.264等）。如果发行版自带或手动安装了支持有授权限制的编码（如H.265）的VA-API，Firefox也会尝试硬件解码这些编码。 Microsoft Edge与Chromium在X11下均默认启用显卡加速。而在Wayland下，显卡加速仍处于实验状态，需要手动启用。 下面以Fedora 37 + GNOME（Wayland + XWayland）+ Firefox + Microsoft Edge + Chromium为例，给出查看和启用显卡加速的办法。 检查是否已启用显卡加速 Firefox： 访问about:support “图像” -&gt; “窗口协议” -&gt; 确认对应的表格内容是为“wayland” “图像” -&gt; “HARDWARE_VIDEO_DECODING” -&gt; 确认对应的表格中没有“unavailable”字样； Chromium&#x2F;Edge： 访问chrome://gpu或edge://gpu “Driver Information” -&gt; “XDG_SESSION_TYPE” -&gt; 确认对应表格内容是“wayland” “Graphics Feature Status” -&gt; 确认“Video Decode”为“Hardware accelerated” “GpuMemoryBuffers Status” -&gt; 确认所有表格内容不全是“Software only” 系统环境配置Firefox及Chromium&#x2F;Edge的显卡加速均依靠VA-API和VDPAU支持。 安装显卡驱动，闭源的官方驱动或是开源的社区驱动均可。 安装VA-API和VDPAU工具 1sudo dnf install -y libva libva-utils libvdpau vdpauinfo 因为法律问题，Fedora等发行版中只提供编码受限的FFmpeg、Mesa VA-API、VDPAU支持包等，因此需要开启RPMFusion 操作流程见 Configuration - RPM Fusion 1sudo dnf install -y https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm 安装FFmpeg 123sudo dnf install -y ffmpeg# 如果已经安装了ffpmeg-freesudo dnf swap -y ffmpeg-free ffmpeg 开源的驱动大概率是基于Mesa图形库开发的。如果你使用的是开源驱动，则需要安装Mesa的VA-API、VDPAU支持包 1234sudo dnf install -y mesa-va-drivers-freeworld mesa-vdpau-drivers-freeworld# 如果已经安装了mesa-va-drivers和mesa-vdpau-driverssudo dnf swap -y mesa-va-drivers mesa-va-drivers-freeworldsudo dnf swap -y mesa-vdpau-drivers mesa-vdpau-drivers-freeworld 闭源的驱动大概率内置对VA-API、VDPAU的支持，因此无需执行上述命令；有些闭源驱动需要单独安装自己的VA-API和VDPAU支持包，可参考闭源驱动的官方文档； 例如： 1sudo dnf install -y libva-intel-driver 使用工具检查支持情况 1234# 检查VA-API支持情况vainfo# 检查VDPAU支持情况vdpauinfo 强行开启Firefox硬件加速 访问about:config 搜索ffmpeg，将结果中的media.ffmpeg.vaapi.enabled改成true 重启Firefox 开启Chromium&#x2F;Edge硬件加速方法注意：此方法不适用于无GTK4环境安装的Chromium&#x2F;Edge浏览器，例如Flatpak。 到/usr/share/applications下找到chromium-browser.desktop或microsoft-edge-&#123;beta,dev&#125;.desktop 直接修改或复制一个副本进行修改 修改Name=方便标识 修改Exec=，在原命令的最后面加入如下参数 123456789101112131415# 为方便解释，此处每行一个参数# 使用系统GL渲染器--use-gl=egl# 启用VA-API支持，启用Ozone平台--enable-features=VaapiVideoDecoder,VaapiIgnoreDriverChecks,UseOzonePlatform# 设置Ozone平台使用Wayland作为显示服务--ozone-platform=wayland# 强制使用GPU光栅化--force-gpu-rasterization# 允许进行光栅化的线程直接读写GPU内存--enable-zerocopy# Wayland输入法支持--enable-wayland-ime# 使用GTK4库--gtk-version=4 若在副本中修改，则将副本替换/usr/share/applications下的文件，或保存到~/.local/share/applications 注销当前用户，重新登录（使GNOME重新读取所有Desktop entry） 使用修改后的Desktop entry启动Chromium&#x2F;Edge 输入法不能用，如何解决？ 方法一：安装GNOME扩展Input Method Panel，即可正常使用输入法 方法二：可以使用Chrome扩展Google 输入工具，代替系统输入法","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"浏览器","slug":"浏览器","permalink":"http://wiki.zhouweitong.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"显卡加速","slug":"显卡加速","permalink":"http://wiki.zhouweitong.site/tags/%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/"},{"name":"Chromium","slug":"Chromium","permalink":"http://wiki.zhouweitong.site/tags/Chromium/"},{"name":"Microsoft Edge","slug":"Microsoft-Edge","permalink":"http://wiki.zhouweitong.site/tags/Microsoft-Edge/"}],"categories":[{"name":"Linux浏览器","slug":"Linux浏览器","permalink":"http://wiki.zhouweitong.site/categories/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"计算机网络笔记-物理层、数据链路层、网络层","date":"2023-02-22T10:00:00.000Z","path":"wiki/计算机网络/计算机网络笔记-物理层、数据链路层、网络层/","text":"物理层理论概念 数据 信号 码元 通过码元数量计算码元信息量：k进制码元 $ \\log_2k $ 信源：发送信号 信宿：接受信号 信道 信道≠电路 从信道数量上来看 串行传输 并行传输：多信道 从信号方向上来看 单向通信：比如现实中光模块接的单模光纤 半双工通信：比如对讲机 全双工通信：比如打电话 波特（Baud）：单位时间内脉冲的个数 即码元 比特（Bit）：信息量的单位 即二进制位 速率：也叫数据率，一般指信息传输速率 码元传输速率：单位时间（1s内）传输的码元个数，单位为波特 信息传输速率：单位时间（1s内）传输的比特数，单位为比特每秒（b&#x2F;s或bps） 波特率转比特率：比特率&#x3D;波特率x码元信息量 带宽：单位是赫兹（Hz），一般是直接给出的物理参数 失真：也叫噪声 较小的失真：信号经过处理后依然可以识别 较大的失真：信号通过处理也无法再被识别 奈奎斯特定理：注意是定理不是频率，单位bps 奈奎斯特率 避免码间串扰 理想情况下：无噪声，带宽有限 极限速率：$ MAX&#x3D;2W \\log_2 V $ 香农定理：单位bps 避免噪声干扰 非理想情况下：有噪声（一般是白噪声），带宽有限 极限速率：$ MAX &#x3D; W \\log_2 (1 + \\frac{S}{N})) $ [[TODO]] 数据链路层功能 差错控制 使用编码计算进行差错控制 FEC：前向纠错，发现错误直接纠正 ARQ：自动重传，发现错误请求重传 是主要应用的差错控制技术 网络层 目的：向传输层提供最大可能交付的、无连接的、简单的数据报服务。 异构网络互联 寻址方法、路由算法、差错处理算法均可能不同 [[TODO]] IP协议 IP数据报格式 首部：最先发送 固定部分：大小相同，20字节，160bit 版本 4bit：IPv4？IPv6？ 首部长度 4bit：单位是半字节（4bit），最低为5；长度一定是4bit的整数倍，不足在末尾用填充位填充； 区分服务 8bit 总长度 16bit：首部长度+数据部分长度 标识 16bit 标志 4bit 片偏移 12bit 生存时间 8bit：即TTL值，为防止 协议 8bit：数据部分的协议类型。TCP：6，UDP：17。 首部校验和 16bit：只检验首部完整性；每经过一次路由器都要重新计算一次（首部会发生变化） 源地址 32bit 目的地址 32bit 可选字段 0～40bit 填充位 可变部分：可有可无，大多数时间没有 数据部分：传输层的报文段 IP数据报分片 MTU：最大传输单元，数据部分长度大于这个值必须分片 标识：同一个数据部分的不同分片使用同一个标识值 标志：共4bit，只有后两个bit有意义 中间位DF：为1禁止分片，为0允许分片 最低位MF：为1表示还有分片，为0表示最后一片&#x2F;没有分片 片偏移：分片在组中的相对位置（第几个片），单位为字节（8bit）；也即偏移的字节数 字节数从0开始 注意单位问题：总长度单位为1bit，片偏移单位为8bit，首部单位为4bit，“总1片8首4” IPv4地址 使用点分十进制表示 IP地址分类 IP地址是区域唯一的 IP地址只可以区分路由器或主机的接口：一个主机可能有多个接口 IP地址由网络号和主机号构成：各占多少位不固定 特殊的双主机逻辑网络：IP无编号网络IP Unnumbered Explained “类别位”：通过IP地址的前几位划分类型 A类：0，0～8为网络号 B类：10，0～16位为网络号 C类：110，0～24位为网络号 D类：1110，多播地址 E类：1111，保留地址 特殊IP地址： 0.0.0.0：可表示任意地址（listen 0.0.0.0）或默认路由（0.0.0.0 route via X.X.X.X），也叫未指明地址 0.0.0.0&#x2F;8：网络号全0,主机号不为0，表示同一网络下的某个主机 255.255.255.255：本网广播地址，向它发送相当于向本网所有主机发送 X.X.X.0：网络号不为0、主机号为0，只用于表示一个网络，不能使用 X.X.X.255：网络号不为0、主机号位全为1，特定网络的广播地址 127.0.0.0&#x2F;8：环回地址，用于本地调试 169.254.0.0&#x2F;16：链路本地地址&#x2F;缺省IP地址，常见于DHCP分配失败时，相当于“目前还没有IP” 始终注意X.X.X.0&#x2F;24和X.X.X.255&#x2F;24这两种IP地址，算可用地址数时要减去 私有IP地址： 10.0.0.0&#x2F;8 172.16.X.X～172.31.X.X 192.168.0.0&#x2F;16 记住特殊数字的二进制 0：00000000 255：11111111 192：11000000 128：10000000 10：00001010 168：10101000 172：10101100 127：11111100 子网划分 目的：便于扩展网络、管理网络、减少子网IP地址浪费；更灵活的控制一个子网中能容纳多少台设备 将两层IP地址转化为三层IP地址：网络号、子网号和主机号 子网号对外是透明的，看作是主机号的一部分 三层IP地址中，主机位最少是2位（去掉全0和全1，可提供给两台设备） 子网掩码：网络号部分的位为1，主机号部分的位为0 已知主机地址和子网掩码，求子网地址：二者按位相与（and），结果的四段式10进制就是子网地址 路由器路由表基本结构 目的网络地址：发给谁？ 目的网络地址的子网掩码：他在哪个子网？ 下一跳的地址：通过什么发给他？ 路由器路由转发的基本流程 找到分组IP地址：发给谁？ 尝试直接交付：子网是不是直接和我连接？ 不能直接交付，查路由表配置，进行IP完全匹配：是不是手动配置了发给他的路线？ 没有配置，查路由表，进行IP前缀匹配（网络号匹配）：是不是手动配置了发给他所在的子网的路线？ 以上均失败，发给默认路由：子网不在我这，是不是分组分配错了？ 默认路由发给该路由器，路由器再发给默认路由，重复直到TTL&#x3D;0，直接丢弃并报错：分组出错，谁也联系不到他 CIDR组成超网 网络地址转换：NAT 有流量时会通过路由器的NAT转换表转换为正确的IP地址，再发送信息 NAT转换表包含端口号 IPv6 解决IPv4地址不够用的办法 NAT CIDR 治标不治本 IPv6的主要目标 从根本上解决IP地址不够用的问题 改进和精简首部格式，使路由器处理速度更快（快速处理&#x2F;转发数据报） 支持QoS服务模型 IPv6封包格式 基本首部，40字节，320bit 版本 4bit 值为“6” 优先级 8bit 标识数据报是否优先处理 流标签 20bit 类似IPv4中的标识，但是是“流”，与QoS有关 有效载荷长度 16bit 扩展首部+数据部分 大小 下一个首部 8bit 基本首部和每个扩展首部各有一个“下一个首部”字段 如果当前首部不是最后一个首部，该字段指向下一个首部的偏移 如果当前首部是最后一个首部，该字段指向数据部分的起始偏移 把所有部分“串在一起” 跳数限制 8bit 相当于IPv4中的TTL 源地址 128bit 目标地址 128bit 有效载荷，最高65535字节，64KB 扩展首部：代替IPv4首部中的可变部分 数据部分 与IPv4的区别 IPv6地址 使用冒号16进制表示 连续的0可以用一个0代替 0000:0000:0000变成0:0:0 0AAA:B000:000C变成 AAA:B000:C 缩头不缩尾 双冒号零压缩，多组0用双冒号代替 AAAA:0000:0000:0000:BBBB变为AAAA:0:0:0:BBBB再变为AAAA::BBBB AAAA:0000:0000:0000:BBBB:0000:0000只能变为AAAA::BBBB:0:0 双冒号只能使用一次，压缩最前面的多组零 网络号和主机号 未指明情况下，网络号为64位（最后16位为子网号），主机号为64位 可以使用类似CIDR的表示法表示网络号的位数，如：&#x2F;24 代表网络号有24位，其他位是主机号 IPv6地址类型 单播：一对一，可做源地址和目标地址 多播：一对多，只能作为目标地址 不存在广播：广播用多播实现 任播：本质一对多，实际一对一（一般是发给离本机最近的目标主机） 例子：多台主机提供相同服务时使用任播负载均衡 IPv6地址划分 全球单播：以001位开头，2000::&#x2F;3 链路本地：FE80::&#x2F;10 本地环回：::1&#x2F;128 未指明：::0&#x2F;0，也可写成::&#x2F;0 唯一本地地址&#x2F;私有地址：FC00::&#x2F;7 内嵌IPv4的IPv6地址 IPv4向IPv6过渡 双栈协议：主机同时使用IPv4和IPv6地址（不同接口） 隧道技术：IPv6-IPv4-发送，IPv4-IPv6-接收 ARP协议 数据链路层需要本机MAC地址和目标主机MAC地址 每个主机维护一个ARP高速缓存：ARP表 维护ARP表 已知IP，不知道MAC，发广播ARP请求分组（请求帧） 广播ARP请求中，目标主机MAC地址为全1（FF-FF-FF-FF-FF-FF） 目标主机识别到广播ARP请求中的IP地址是自己，发单播（点对点）ARP响应请求（响应帧） 本机得到响应帧，更新ARP表 后续的数据分组依照ARP表内的项，填充MAC地址并发送 以上ARP表的维护适用于目标主机和本机在同一个局域网内的情况：较大的网络不适合进行广播寻找主机 [[TODO]] DHCP协议 应用层协议，基于UDP RIP协议 应用层协议，基于UDP 一种分布式的、基于距离向量的路由选择协议 特点：简单，只能用于小范围互联网 主机维护路由表，存放当前路由器到其他每一个目的网络唯一的最佳距离记录 距离一般指 跳数 距离值小于15为合法，距离值为16表示网络不可达 路由表重要的表项 目的网络地址 距离值 下一跳的路由器地址 对路由表进行定时更新 只和相邻路由器交换信息，相互交换自己的路由表 每30s交换一次，相邻路由器180s内无响应则判定失联 初始情况下，路由器的路由表只包含相邻路由器的、距离为1的路由 若干次更新后，每个路由器均会获得当前路由器到所有可能的网络的最短距离（小于等于15），也称“收敛”。 若相邻的路由器之一失联，则从路由表中删除下一跳是该路由器的路由表项 路由表更新算法 子主题 4","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wiki.zhouweitong.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Network","slug":"Network","permalink":"http://wiki.zhouweitong.site/tags/Network/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wiki.zhouweitong.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"P1-行列式","date":"2023-02-22T09:00:00.000Z","path":"wiki/数学/线性代数/P1_行列式/","text":"线性代数是数学的其中一个分支。主要研究向量、向量空间（线性空间）、线性变换及有限维度的线性方程组。[1] 线性指的是线性关系，即两个或多个变量（数学元素）间的关系程一次形式。例如：n元一次方程组、形如 $f(x+y) &#x3D; f(x) + f(y)$ 的函数关系等。代数 指的是用符号代替具体数值进行计算，化具体为抽象。 本提纲基于教材《工程数学线性代数（第六版）》（同济大学数学系），采用其表述及顺序。 行列式 行列式是一个数 区别于矩阵，矩阵是一个数表 二阶行列式 计算式共4项 明确每项的特点 不同行不同列元素乘积 明确项与项之间的组合 加法或减法 三阶行列式 速算法 各主对角线方向的三个项 减去 各副对角线方向的三个项 逆序数：判断项的正负 n阶排列 n个数 逆序 大数在前小数在后 逆序数 逆序的总数 奇&#x2F;偶排列 逆序数奇&#x2F;偶 逆序数为0时是偶排列 怎么算 选定当前的数 找当前数后面比他小的数的个数 依次向后进行这个操作，直到最后一个数 作和 t(31542)&#x3D;2+0+2+1&#x3D;5 n阶行列式 利用逆序数写出项 注意判断正负的方法：尽量将行标写成递增的，这样就只用算列标的逆序数 共有 n! 项 性质 矩阵的行列式 与其转置矩阵的行列式 值相等 某行有公因数k，可将k提出行列式外 两行互换，行列式值变号 两行相同，行列式值为0 两行成比例，行列式值为0 一行是两数之和，可拆成两个行列式相加 某行k倍加到另一行，行列式值不变 重要公式 主对角线&#x2F;上三角&#x2F;下三角行列式 结果是主对角线上元素的乘积 副对角线&#x2F;副对角线上三角&#x2F;副对角线下三角行列式 副对角线上元素的乘积，并计算符号正负 拉普拉斯公式 副对角线拉普拉斯公式，m、n为A、B的行数 范德蒙行列式 爪形行列式 一般变成上三角&#x2F;下三角行列式 计算规律 数字型：行列式中的每个元素都是确定的数字 ！考虑展开公式 常用的恒等变形 某行k倍加到另一行，行列式值不变 将每一行（的倍数）都加到第一行 逐行相加：L2+L3-&gt;L2，L1+L2-&gt;L1 抽象型：行列式中有未知数，需要求未知数的值&#x2F;范围 ！除了考虑行列式性质外还要考虑矩阵的性质 各种行列式的恒等变形 矩阵性质 1 2 3 4 注意|A|&#x3D;0的特殊情况，此时等式也成立，但是恒等，无法用于计算或证明 5 6 7 单位矩阵的恒等变形 特征值性质 相似矩阵性质 应用 特征多项式 克拉默法则 矩阵的秩1.线性代数（数学分支学科）_百度百科 ↩","tags":[{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"http://wiki.zhouweitong.site/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"行列式","slug":"行列式","permalink":"http://wiki.zhouweitong.site/tags/%E8%A1%8C%E5%88%97%E5%BC%8F/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/"},{"name":"线性代数","slug":"数学/线性代数","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"C#基础","date":"2023-02-21T10:00:00.000Z","path":"wiki/CSharp/CSharp基础/","text":"版本问题 目前最新的版本是C# 11（.Net 7），在研的版本是C# 12（.Net 8） .Net版本和C#版本有对应关系：.Net相当于JDK（运行时），C#相当于Java（语言标准） .Net经过多次分割和合并 开始时.Net仅在Windows平台上开放（.Net Framework 3.x，4.x，目前仍在维护，即.Net Framework 4.8），截止到C# 7 因此开源的.Net运行时开始发展（Mono，等同于.Net Framework 4.x），截止到C# 7 .Net Framework 3.x在Windows 7上预装，.Net Framework 4.x 在Windows 8以上系统内预装 随后Microsoft推出了.Net Core计划，相当于把.Net部分开源，截止到.Net Core 3.1（C# 8） 之后，Microsoft宣布将.Net完全开源，推出了.Net 5.x（C# 9）、.Net 6.x（C# 10）、.Net 7.x（C# 11） .Net，.Net Framework和.Net Core的关系：.Net Framework是最“完整”的.Net，包含Windows窗口API、Windows服务API、Web支持等等；.Net Core是最初开源的.Net，.Net是完全开源的.Net，但仍然只有部分功能（可以类比Oracle Glassfish Server，OpenJDK和JDK） Unity和C#之间的关系： Unity使用Roslyn编译器，也即.Net官方给出的编译器（dotnet&#x2F;roslyn: The Roslyn .NET compiler provides C# and Visual Basic languages with rich code analysis APIs. (github.com)），将C#代码转换为中间码IL 随后依据平台的不同，使用Mono继续处理IL（IL到机器码）或者使用IL2CPP（IL到C++到机器码）或者使用.Net本身（IL到机器码） 目前的Unity版本与C#版本的对应关系 Unity 2018.4 .Net Framework 3.5（C# 4） .Net Framework 4.6（C# 7.3） Unity 2019.4 .Net Framework 4.6（C# 7.3） Unity 2020.3 .Net Framework 4.6（C# 8.0） Unity 2021.3 C# 9.0 Unity 2022.2，Unity 2023.1 C# 9.0 环境搭建和使用 Windows下推荐使用Visual Studio,开启.Net&#x2F;ASP .Net开发功能 Visual Studio: 面向软件开发人员和 Teams 的 IDE 和代码编辑器 如果有在Windows上以Mono做开发的需求，可以安装Mono和MonoDevelop： Download - Stable | Mono Download | MonoDevelop Linux下可选择.Net或Mono： Mono需要添加官方源：Download - Stable | Mono apt-get install mono-devel monodevelop .Net同样需要添加官方源：在 Linux 发行版上安装 .NET - .NET | Microsoft Docs apt-get install dotnet-sdk-6.0 基本结构 C#程序的基本结构：使用命名空间、定义命名空间、命名空间内定义类、类内定义方法、Main函数入口点 语句的结尾用分号（;），class、function、namespace算语句块，不需要分号 Main函数入口点的形式：static void Main(string[] args) &#123;&#125; 必须是静态函数：static 一定是无返回值的：void 参数是可选的，若有参数，则是字符串数组：string[] 因为是静态函数，所以Main函数中只能直接调用其他静态函数 即：函数能静态最好设置为静态 示例程序 1234567891011using System;namespace TestNamespace&#123; class ExampleClass &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Hello World!&quot;); &#125; &#125;&#125; 基本类型 也分常量&#x2F;变量类型和字面量（literal）类型 不符合“一切皆对象”的哲学：字面量不是对象 所有基本类型在定义时会被自动初始化为默认值。（一些编译器认为）如果需要变量在定义时保持其默认值，不应该将其初始化。（另一些编译器认为）变量使用前均应该被初始化。 即：bool m_a = false; 应该写为 bool m_a; 值类型：数据存放在栈中，使用时也是直接从栈取数据、向栈写回数据； 内置的基本类型：均是值类型 bool：布尔类型，默认值为false int：32位整型，2^-31到2^31-1，默认值为0 uint：32位无符号整型，0到2^32-1,默认值为0 short：16位整型，-2^15到2^15-1，默认值为0 ushort：16位无符号整型，0到2^16-1，默认值为0 long：64位整型，-2^63到2^63-1,默认值为0L ulong：64位无符号整型，0到2^64-1，默认值为0UL sbyte：8位整型，-2^7到2^7-1，默认值为0 byte：8位无符号整型，0到2^8-1，默认值为0 float：32位单精度浮点型，默认值为0.0f double：64位双精度浮点型，默认值为0.0d char：16位UNICODE字符，默认值为’\\u0000’，即’\\0’ decimal:128位整型（有效位数28～29位），默认值0.0M 注意基本类型的变量和常量也是对象，提供了一些成员方法 引用类型：数据存放在堆中，但会在栈中保存数据的地址。使用时从栈中找地址，再从堆中读数据； 字符串string是引用类型； 动态类型dynamic是引用类型； 对象类型（及其各种子类）object是引用类型：string和dynamic可看作是object的两个常用子类 字符串类型：string string 本质上是一个对象 可以定义字符串数组：string[]，然后用下标去访问需要的字符串 字符串中部分字符需要反斜线转译，比如 \\n 可以使用“逐字字符串”，例如 @&quot;A&quot;，用法类似于Python中的raw string（r&quot;A&quot;），换行符、缩进、空格等都会被原样保留 指针类型：与C++一样，使用 * 必须在指定不安全的上下文中使用，即unsafe的函数、变量或命名空间，且需在IDE的项目设置中开启“允许不安全的代码”选项（&#x2F;unsafe） 定义：int *b = &amp;a; 使用：*b; 动态类型：dynamic 与C++中的std::any有些类似 变量的类型可在执行中改变，编译器不会对该变量进行类型检查 多用于函数的返回值 对象类型：object object是所有基本类型变量的基类。更确切地说，它是所有类（类型）的终极父类； 所以理论上object类型可以“装入”并且“被读出”任意类型的数据 两种操作： 将值类型转换为object类型的引用：装箱 1object obj = 9; 将object类型的引用转化为原来的值类型：拆箱，要注意必须使用强制类型转换，且只能转换为object对象中值的真实类型（否则会抛出InvalidCastExpection异常） 1int y = (int)obj;","tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"C#","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"}]},{"title":"自定义Toolbox镜像","date":"2023-02-18T05:38:00.000Z","path":"wiki/Fedora Silverblue/Toolbox/自定义Toolbox镜像/","text":"Toolbox 可看做是Podman的Wrapper，力求将容器与主机的操作系统（Host OS）无缝集成。与Toolbox类似的工具还有Distrobox。它们在牺牲一些容器安全性（端口控制、资源控制、文件的独立性等）的情况下可以做到： 用户穿透：在容器中使用与当前Host user一样的user与home目录； 设备穿透：直接使用Host的/dev、/media等； 网络穿透：直接使用Host网络，获得与主机一致的网络体验； 服务穿透：通过直接使用Host的/run/user/&lt;uid&gt;和/tmp以及关键服务的Socket，实现在容器中访问主机的显示服务（X11&#x2F;Wayland）、网络服务（Avahi）、D-Bus、systemd journal等； 因此，Toolbox可以用来： 作为不可变系统的软件安装方式之一。如Fedora Silverblue、Fedora CoreOS等不可变系统中均预装Toolbox，另一些不可变系统中可能预装Distrobox； 使用其他发行版的镜像，在当前发行版中无缝运行针对其他发行版制作的程序。如在Fedora下运行只提供Ubuntu deb包的GUI程序； 在没有Host的root权限时创造一个假root环境。如非privileged的Toolbox容器同样可以使用sudo dnf install安装软件； 需要镜像中预装sudo，并支持sudo、wheel组获取root权限，且支持NOPASSWD选项； 使用不同版本的镜像实现“旧程序运行在新系统上”或“新程序运行在旧系统上”，或对程序进行兼容性测试； 可以通过对镜像进行自定义，实现快速且一致的开发环境搭建； 创建自己的Toolbox镜像符合OCI标准的容器镜像均可被Toolbox使用。换言之，依照通常的Docker镜像构建方法就可以构建自己的Toolbox镜像。 Fedora社区持续维护着Fedora的Toolbox镜像构建文件 container&#x2F;fedora-toolbox，GitHub上也有社区维护的各主流发行版的Toolbox镜像 toolbx-images&#x2F;images。 以Fedora的Toolbox镜像为例，以下是官方给出的Dockerfile示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 使用fedora:37，而不是fedora-toolbox:37FROM registry.fedoraproject.org/fedora:37# 镜像标签ENV NAME=fedora-toolbox VERSION=37LABEL com.github.containers.toolbox=&quot;true&quot; \\ com.redhat.component=&quot;$NAME&quot; \\ name=&quot;$NAME&quot; \\ version=&quot;$VERSION&quot; \\ usage=&quot;This image is meant to be used with the toolbox command&quot; \\ summary=&quot;Base image for creating Fedora toolbox containers&quot; \\ maintainer=&quot;Debarshi Ray &lt;rishi@fedoraproject.org&gt;&quot; COPY README.md /# 使dnf安装软件包时 同步安装所有语言的语言文件 及文档文件RUN rm /etc/rpm/macros.image-language-confRUN sed -i &#x27;/tsflags=nodocs/d&#x27; /etc/dnf/dnf.conf# [A] 安装完整的 核心工具（GNU Coreutils）及其语言文件RUN dnf -y upgradeRUN dnf -y swap coreutils-single coreutils-fullRUN dnf -y swap glibc-minimal-langpack glibc-all-langpacks# [B] 通过重装的方式补齐语言和文档COPY missing-docs /RUN dnf -y reinstall $(&lt;missing-docs)RUN rm /missing-docs# [C] 安装额外的软件包COPY extra-packages /RUN dnf -y install $(&lt;extra-packages)RUN rm /extra-packages# [D] 保证关键文档文件存在COPY ensure-files /RUN ret_val=0; \\ while read file; do \\ if ! compgen -G &quot;$file&quot; &gt;/dev/null; then \\ echo &quot;$file: No such file or directory&quot; &gt;&amp;2; \\ ret_val=1; \\ break; \\ fi; \\ done &lt;ensure-files; \\ if [ &quot;$ret_val&quot; -ne 0 ]; then \\ false; \\ fiRUN rm /ensure-filesRUN dnf clean all 同时还需要三个额外的文件 ensure-files、extra-packages和missing-docs。 想增加或删减Toolbox中的镜像，可直接修改extra-packages文件，修改时尽量保证每行只有一个软件包的包名。也可以仿照上述Dockerfile的[C]节，在不修改extra-packages文件时使用自定义文件； 仿写： 123COPY added-packages /RUN dnf -y install $(&lt;added-packages)RUN rm /added-packages added-packages例子： 12345nodejsnpmpython3-pipgccg++ 给Toolbox镜像增加中文支持可以通过修改LANG变量、重新生成语言文件、安装中文字体等方法使Toolbox内的命令行&#x2F;GUI程序支持并默认显示中文。 添加语言文件：在上述Dockerfile示例的[B]节前添加如下内容 123# 中文语言RUN dnf install -y glibc-locale-source glibc-langpack-zh langpacks-zh_CNRUN localedef -c -i zh_CN -f UTF-8 zh_CN.UTF-8 安装字体和输入法：在上述Dockerfile示例的[C]节或[D]节前添加如下内容 12# 安装字体和输入法RUN dnf install -y wqy-microhei-fonts wqy-zenhei-fonts fcitx5 设置LANG环境变量：在上述Dockerfile示例的最后添加如下内容 12# 设置环境变量ENV LANG zh_CN.UTF-8 使用Toolbox镜像以自定义镜像的tag为a.com/fedora-toolbox-customized:37为例： 通过podman拉取自定义镜像 1podman pull a.com/fedora-toolbox-customized:37 使用toolbox创建容器 123# 容器名可以随意指定# 当主机为Fedora系统，且容器名为 fedora-toolbox-&lt;主机Fedora版本号&gt; 时，该容器为Toolbox默认容器toolbox create --image a.com/fedora-toolbox-customized:37 fedora-toolbox-37 进入容器环境或执行容器内特定程序 12345678# 当主机只有一个Toolbox容器时，会直接进入该容器# 当Fedora系统的主机有默认容器时，会直接进入默认容器toolbox enter# 可以直接指定需要运行的命令toolbox run &lt;命令&gt;# 在存在多个Toolbox容器时，可通过命令参数指定运行哪个容器toolbox enter &lt;容器名&gt;toolbox run --container &lt;容器名&gt; &lt;命令&gt; 删除Toolbox容器和镜像1234567# 需要退出所有正在使用Toolbox Shell/命令行程序/GUI程序的窗口# 停止容器podman stop &lt;容器名&gt;# 删除容器toolbox rm &lt;容器名&gt;# 删除镜像podman rmi a.com/fedora-toolbox-customized:37","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://wiki.zhouweitong.site/tags/Docker/"},{"name":"Fedora","slug":"Fedora","permalink":"http://wiki.zhouweitong.site/tags/Fedora/"},{"name":"Toolbox","slug":"Toolbox","permalink":"http://wiki.zhouweitong.site/tags/Toolbox/"},{"name":"Podman","slug":"Podman","permalink":"http://wiki.zhouweitong.site/tags/Podman/"}],"categories":[{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/"},{"name":"Toolbox","slug":"Fedora-Silverblue/Toolbox","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Toolbox/"}]},{"title":"科目一 口诀","date":"2023-02-14T12:30:00.000Z","path":"wiki/驾照/科目一/科目一 口诀/","text":"申请驾驶证年龄要求 最小18，最大不限 70以上，每年体检 驾驶证有效期 6 10 长 刚拿时6年过期，然后换证10年过期，再换证长期有效 遇周期，找12 驾驶证周期是12个月 驾驶证实习期是12个月 遇时间，找9、3 选项有90日就选90日 没有90日就选30日 遇有效期，找3年 准考证有效期3年 实习期上高速找3年经验者陪同 因事不能审验延期3年 大客中客牵引车，普通驾照也没辙","tags":[{"name":"驾照","slug":"驾照","permalink":"http://wiki.zhouweitong.site/tags/%E9%A9%BE%E7%85%A7/"},{"name":"科目一","slug":"科目一","permalink":"http://wiki.zhouweitong.site/tags/%E7%A7%91%E7%9B%AE%E4%B8%80/"},{"name":"口诀","slug":"口诀","permalink":"http://wiki.zhouweitong.site/tags/%E5%8F%A3%E8%AF%80/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"驾照","slug":"驾照","permalink":"http://wiki.zhouweitong.site/categories/%E9%A9%BE%E7%85%A7/"},{"name":"科目一","slug":"驾照/科目一","permalink":"http://wiki.zhouweitong.site/categories/%E9%A9%BE%E7%85%A7/%E7%A7%91%E7%9B%AE%E4%B8%80/"}]},{"title":"Arch安装速查表","date":"2023-02-14T10:00:00.000Z","path":"wiki/Arch Linux/Arch安装速查表/","text":"LiveCD下载后操作无需求时可跳过本节； 校验ISO镜像 sha256校验：https://archlinux.org/download/#checksums，或者 pgp校验（必须从 archlinux.org 域名下载pgp签名文件 烧录ISO镜像刻录ISO为光盘 或者 使用软件从ISO镜像制作USB启动盘； Rufus； balenaEtcher； 从LiveCD启动机器 若是UEFI BIOS模式启动，须在BIOS设置中关闭“安全启动”（Secure Boot）； LiveCD启动后操作修改键盘键位标准qwerty键盘时可跳过本节； 1234# 获得键位布局IDls /usr/share/kbd/keymaps/**/*.map.gz# 加载键位布局loadkeys &lt;keymap_id&gt; 检测启动模式熟悉BIOS设置和BIOS启动选项时可跳过本节； 123# 文件夹存在：是UEFI BIOS模式# 文件夹不存在：是Legacy BIOS模式ls /sys/firmware/efi/efivars 检查网络设置Arch要求必须连接网络才能进行安装; 检查网络硬件 以太网：确定网线已经插入 内置Wi-fi网卡：确保网卡没有物理按钮（可以硬件层面打开或禁用Wi-fi网卡）；或者有物理按钮并切换到启用； 外置Wi-fi网卡：确保网卡已插入； 内置SIM卡卡槽：确保已插卡； 外置SIM卡上网卡：确保已插卡并已插入； 连接网络首先ip link检查接口是否打开，没有的话ip link set dev &lt;device&gt; up； 以太网：无特殊操作 Wi-fi：使用 iwctl 1234567iwctl device listiwctl station listiwctl station &lt;device&gt; scaniwctl station &lt;device&gt; get-networksiwctl --passphrase &quot;&lt;password&gt;&quot; station &lt;device&gt; connect &lt;SSID&gt;iwctl station &lt;device&gt; show# iwctl station &lt;device&gt; disconnect SIM卡移动网络：使用mmcli 123mmcli -Lmmcli -m &lt;index&gt; --simple-connect=&quot;apn=&lt;apn&gt;,user=&lt;username&gt;,password=&lt;password&gt;&quot;mmcli -m &lt;index&gt; --simple-disconnect 检查IP地址ip addr检查IP地址； DHCP自动分配IP的链路：无需特殊操作，IP地址会自动获取 静态IP的链路：使用ip手动添加地址和路由 1234567ip [-6] addr add &lt;ip&gt;/&lt;prefix&gt; broadcast + dev &lt;device&gt;# ip [-6] address del &lt;ip&gt;/&lt;prefix&gt; dev &lt;device&gt;ip [-6] routeip [-6] route add &lt;route_ip&gt;/&lt;prefix&gt; via &lt;ip&gt; dev &lt;device&gt;ip [-6] route add default via &lt;ip&gt; dev &lt;device&gt;# ip [-6] route del &lt;route_ip&gt;/&lt;prefix&gt; via &lt;ip&gt; dev &lt;device&gt; 检查互联网连通性12ping 8.8.8.8ping www.baidu.com 检查时钟自动在联网后触发同步，检查： 1timedatectl status 同步失败等情况需手动设置： 1timedatectl set-time &quot;&lt;YYYY-MM-dd HH:mm:ss&gt;&quot; 硬盘和分区设置使用fdisk交互式设置分区表； 12fdisk -lfdisk &lt;device&gt; 1234567891011g：建立GPT分区表o：建立DOS分区表n：新建分区d：删除分区p：查询分区表t：修改分区类型l：列出支持的分区类型w：将分区表更改写入硬盘q：不保存分区表修改 设置分区大小时可以直接使用容量值，如+100M 硬盘规划EFI分区1个，仅UEFI模式时需要 格式：EFI System 文件系统：FAT32 容量：数百MB（300MB） 挂载点：/boot/efi Flag: boot 用途：存储UEFI需要的启动文件 boot分区根分区不是ext4时，推荐单独建立1个ext4格式的boot分区； 格式：Linux filesystem 文件系统：ext4 容量：数百MB（500MB）或数GB（1GB） 挂载点：/boot 用途：存储所有启动相关的文件，如：GRUB配置、Linux内核（vmlinuz、initrd）等 swap交换空间除非存储空间非常紧缺，否则应该使用swap，推荐直接创建swap分区； 除了使用swap分区以外，也可以不创建分区而使用swap文件； 格式：Linux swap 文件系统：swap 容量：根据是否需要使用休眠功能（Hibernation）和RAM大小确定： 使用休眠功能：休眠时Linux会将整个物理内存保存在硬盘（也即swap）中； RAM &lt;&#x3D; 2GB，swap &gt;&#x3D; 3*RAM RAM &gt; 2GB &amp;&amp; RAM &lt;&#x3D; 8GB，swap &gt;&#x3D; 2*RAM RAM &gt; 8GB &amp;&amp; RAM &lt;&#x3D; 64GB，swap &gt;&#x3D; 1.5*RAM RAM &gt;&#x3D; 64GB，此时使用休眠功能耗时较长，且若是固态硬盘则会快速消耗硬盘寿命，因此不推荐使用休眠功能 不使用休眠功能 RAM &lt;&#x3D; 2GB，swap &gt;&#x3D; 2*RAM RAM &gt; 2GB &amp;&amp; RAM &lt;&#x3D; 8GB，swap &gt;&#x3D; RAM RAM &gt; 8GB，swap &gt;&#x3D; max(8GB, 0.5*RAM) TODO：整个安装流程","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"http://wiki.zhouweitong.site/tags/Arch-Linux/"},{"name":"发行版安装","slug":"发行版安装","permalink":"http://wiki.zhouweitong.site/tags/%E5%8F%91%E8%A1%8C%E7%89%88%E5%AE%89%E8%A3%85/"},{"name":"速查表","slug":"速查表","permalink":"http://wiki.zhouweitong.site/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"http://wiki.zhouweitong.site/categories/Arch-Linux/"}]},{"title":"Flatpak概念","date":"2023-02-13T08:00:00.000Z","path":"wiki/Fedora Silverblue/Flatpak/Flatpak概念/","text":"为什么使用Flatpak？ 问题：已经有了apt、dnf等这种系统级的包管理器，为什么还要使用Flatpak？ Flatpak给软件提供相对独立的运行环境（沙箱），并提供权限控制功能，避免软件破坏或任意修改系统； Flatpak很大程度上解决了软件的兼容性问题，让“新系统跑旧软件”或“旧系统跑新软件”成为可能；因此Flatpak可以在非滚动更新的发行版上安装 比系统源内版本更高的软件； Flatpak支持诸多发行版，在不同的发行版上能够获得几乎相同的软件使用体验； Flatpak允许同一个软件的不同版本在系统内共存； Flatpak允许非root用户在单用户作用域内安装软件； …… 问题：我在用Snap或者AppImage，它们和Flatpak有什么区别嘛？ Flatpak性能中等，略优于Snap，略差于AppImage； Flatpak、AppImage不需要服务（Service），而Snap需要Snapd； Flatpak、Snap提供权限控制功能，而AppImage不提供； Flatpak、Snap统一提供所有软件包的更新，而AppImage需要打包者自行适配应用内更新或利用第三方工具更新； Flatpak、Snap在发行版的预装情况方面有区别： Flatpak预装在这些发行版中： Fedora (Workstation&#x2F;Silverblue&#x2F;Kinoite) Manjaro Endless OS Linux Mint Rocky Linux (GNOME) AlmaLinux (GNOME) CentOS (GNOME) EuroLinux (GNOME) Pop!_OS elementary OS Clear Linux (Desktop) PureOS Zorin OS MX Linux KDE neon …… 而Snap预装在这些发行版中： Ubuntu系列 (Ubuntu Desktop, Ubuntu Server, KUbuntu, XUbuntu……) KDE neon Manjaro Solus Zorin OS …… Flatpak和Snap均得到了两个软件中心（GNOME Software Center、KDE Plasma Discover）的支持，而Appimage需要使用第三方软件中心（如prateekmedia&#x2F;appimagepool、app-outlet&#x2F;app-outlet（同样支持Flatpak）） …… 什么时候不用Flatpak？ 软件与系统结合非常紧密、不适合在沙箱中运行时不应该使用Flatpak 或者说，这种情况下软件很难打包成Flatpak 例如：GParted、Wireshark、Virt-Manager 应当考虑系统软件包管理器（apt、dnf等） 需要软件的便携性时不应该使用Flatpak 应当考虑将程序打包成单个文件的AppImage 命令行软件不应该使用Flatpak Flatpak有计划支持命令行程序，但目前体验不佳 Flatpak不会自动创建软件包内程序文件的链接和别名，例如不能直接执行go只能执行flatpak run --command=/usr/lib/sdk/golang/bin/go org.freedesktop.Sdk//21.08 例如：Golang，Gcc，Docker，Minikube 应当考虑Snap或系统软件包管理器 运行内存（RAM）或存储空间（Storage）极为有限的时候不应该使用Flatpak 应当考虑系统软件包管理器； App和RuntimeFlatpak 分为两种软件包： Application（App）：应用本体； Runtime：应用所需的运行时； “运行时”均是支持GUI显示的基本运行时（“没它打不开”），与桌面环境相关，一个“应用本体”只依赖一个“运行时”。 “运行时”目前主要有以下四种： FreeDesktop：最基础的运行时，提供D-Bus、GTK3、X11、Wayland等 org.freedesktop.Platform org.freedesktop.Sdk GNOME：GNOME&#x3D;FreeDesktop+GNOME_Specific；提供Gjs、GStreamer、GVFS等； org.gnome.Platform org.gnome.Sdk KDE：KDE&#x3D;FreeDesktop+KDE_Specific；提供Qt等； org.kde.Platform org.kde.Sdk elementary：elementary&#x3D;GNOME+elementary_Specific；提供elementaryOS专属的图标、Granite等； io.elementary.Platform io.elementary.Sdk ID每个App或Runtime都有一个ID，类似Andorid下App的包名，例如： （App） Blender： org.blender.Blender （Runtime） Gnome Platform：org.gnome.Platform 加入架构和版本号，就构成了 ID三元组： org.blender.Blender/x86_64/stable org.gnome.Platform/x86_64/43 加入软件包类型，就构成了 该App对应的Flatpak ostree分支名： app/org.blender.Blender/x86_64/stable runtime/org.gnome.Platform/x86_64/43 App和Extension另一种对软件包的分类是： Application（App）：（主要）应用，即可直接打开或运行的应用，例如：VLC、Blender； Extension：应用的扩展，有多种情况： 支持特定应用正常运行的其他软件或库（“没它用不了”），如：Wine、FFMpeg、Mesa； 特定应用所需的程序包（“没它用不好”），如：TeX环境、Rust语言（编译器）、Go语言（编译器）； 软件自身的一部分，如：Blender的语言文件； 对应第一种分类时，App和Runtime都可以有Extension。Extension有自己的ID，命名规则是在App或Runtime的包名后加上Extension名： App的Extension，例如：&#96; 应用安装时，应用依赖的运行时和扩展也会被安装； 安装范围Flatpak 有两种安装范围： System：系统级安装，需要root权限，安装的应用 系统上所有的用户均可见； User：用户级安装，安装的应用 仅当前用户（触发安装的用户）可见； 软件包的源与其他的包管理器（系统级或Snap）一样，flatpak也有“软件源”的概念（即“软件包源”）。 .flatpakref.flatpakref文件描述了单个软件包的信息和获取方式，文件结构大致如下： 12345678[Faltpak Ref]Name=&lt;软件包的ID&gt;Branch=&lt;软件包的版本&gt;Title=&lt;描述该软件包的标题（软件包名字）&gt;Url=&lt;软件包所在的源的地址&gt;RuntimeRepo=&lt;软件包依赖的运行时所在的源的地址&gt;IsRuntime=&lt;本软件包是不是运行时&gt;GPGKey=&lt;Base64编码的GPG密钥&gt; 示例： 12345678[Flatpak Ref]Name=fr.free.HomebankBranch=stableTitle=fr.free.Homebank from flathubUrl=https://dl.flathub.org/repo/RuntimeRepo=https://dl.flathub.org/repo/flathub.flatpakrepoIsRuntime=falseGPGKey=mQINBFlD2sABEADsiUZUO... .flatpackref文件可直接用于安装软件包的命令中，也可直接使用软件中心打开； .flatpakrepo TODO：ostree相关","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"Fedora","slug":"Fedora","permalink":"http://wiki.zhouweitong.site/tags/Fedora/"},{"name":"Flatpak","slug":"Flatpak","permalink":"http://wiki.zhouweitong.site/tags/Flatpak/"},{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/tags/Fedora-Silverblue/"},{"name":"概念","slug":"概念","permalink":"http://wiki.zhouweitong.site/tags/%E6%A6%82%E5%BF%B5/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/"},{"name":"Flatpak","slug":"Fedora-Silverblue/Flatpak","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Flatpak/"}]},{"title":"Flatpak基础使用","date":"2023-02-13T01:40:00.000Z","path":"wiki/Fedora Silverblue/Flatpak/Flatpak基本使用/","text":"列出已安装的软件包只列出App： 1flatpak list 也可以： 1flatpak list --app 只列出Runtime： 1flatpak list --runtime 列出System App： 1flatpak list --system 列出User Runtime： 1flatpak list --user --runtime 卸载软件包卸载特定软件包： 1flatpak uninstall &lt;ID&gt; 卸载所有无用（useless）的运行时和扩展（相当于 apt-get autoremove）: 1flatpak uninstall --unused 升级软件包升级所有已安装软件包： 1flatpak update 升级所有User范围内的软件包： 1flatpak update --user 升级某个特定的软件包： 1flatpak update &lt;ID&gt; 搜索软件包类似apt search： 1flatpak search &lt;keyword&gt; 关键字可以是ID内出现的字符串（与ID相关），也可能是软件包描述内出现的字符串（与描述有关）； 在某一个源内搜索软件包： 1234# 找带关键字的所有软件包 -&gt; grep过滤出特定的源flatpak search &lt;keyword&gt; | grep &lt;repo_name&gt;# 列出特定源里的所有软件包 -&gt; grep过滤出特定的软件包（需要keyword与ID相关）flathub remote-ls &lt;repo_name&gt; | grep &lt;keyword&gt; 安装软件包在不知道软件包的ID时，可以直接使用关键字，flatpak会查找所有匹配的项并询问要安装哪个： 1flatpak install &lt;keyword&gt; 知道软件包的ID时，可根据ID直接安装： 1flatpak install &lt;ID&gt; 知道软件包源和软件包ID时，可安装指定源内的某软件包： 1flatpak install &lt;repo_name&gt; &lt;ID&gt; 控制安装软件的范围：加--system或--user 控制安装软件的版本（即安装某个旧版本而不是最新版）：使用ID三元组 flatpak可自动检测当前系统的架构，三元组可简写为二元组，例如：org.blender.Blender/x86_64/stable -&gt; org.blender.Blender//stable 有些情况下，软件包所在的软件包源（Repo）系统中并没有添加（比如第三方源，或者本地源），此时若软件包提供者提供了flatpakref文件，软件包可以在不添加源的情况下安装； 1flatpak install &lt;flatpakref_url&gt; 修复软件包软件包的文件丢失或出错，可以联网快速修复： 1flatpak repair 修复操作包括校验安装的所有软件包、重新下载安装文件缺失或出错的软件包、删除没被任何ostree commit引用的文件，等。 可以使用--system和--user指定修复的范围。 查询flatpak操作历史会列出flatpak的拉取（pull）、部署（depoly）、卸载（uninstall）等动作的历史记录； 1flatpak history 查询软件包的详细信息需要是已安装的软件包的ID； 1flatpak info &lt;ID&gt; 会给出类似下面的输出（LANG=en-US.UTF-8）： 12345678910111213141516171819Blender - Free and open source 3D creation suite ID: org.blender.Blender Ref: app/org.blender.Blender/x86_64/stable Arch: x86_64 Branch: stable Version: 3.4.1 License: GPL-3.0 Origin: flathub Collection: org.flathub.StableInstallation: system Installed: 879.3?MB Runtime: org.freedesktop.Platform/x86_64/22.08 Sdk: org.freedesktop.Sdk/x86_64/22.08 Commit: 477316037ec442424b97d3d5fddc898d5908f47af6b3976ded5d070f8ed72d38 Parent: 9bcff42b740d86faf8e64484ed5bcab9b0598c47ee0eebb604c7c52f1a9c2233 Subject: [fix #18] enable spnav socket (e10330e0) Date: 2022-12-28 14:15:54 +0000 查询哪些软件包正在运行需要以和运行软件时相同的用户身份进行查询（查询userA正在运行的软件包就su userA）； 类似 docker ps 1flatpak ps 有时只需要软件包ID或者是只需要实例ID，可以使用参数--columns=&lt;column_name&gt;进行输出限定；column_name是输出列的英文名称； 1234# 只看实例ID列flatpak ps --columns=instance# 只看ID和PID两个列flatpak ps --columns=application,pid 强制退出正在运行的软件包与kill不同，不能用于发送信号，只能用于强制停止软件包运行； 类似 docker stop 1flatpak kill &lt;ID&gt; 使用命令行运行软件包有时需要对软件包进行这些操作： 查看软件包对stdout的输出（log等）； 给软件包增加启动参数（例如给Discord软件包增加--proxy-server=&lt;url&gt;使Discord通过代理连接服务器）； 修改、增加或删除软件包中的环境变量； 强制使软件包使用某个运行时； 修改软件包的入口点（使用自定义的软件包启动命令）； 临时赋予软件包某些权限，如允许访问某些文件系统（路径等）、允许访问特定设备（共享内存等）…… 类似docker run 直接运行： 1flatpak run &lt;ID&gt; 增加启动参数： 123flatpak run &lt;ID&gt; &lt;params&gt;# 例如：flatpak run com.discordapp.Discord --proxy-server=http://127.0.0.1:7890 其他常用的命令参数，参数需要放到软件包ID的前面： 环境变量 修改或增加：--env=&lt;var_name&gt;=&lt;var_value&gt; 删除：--unset-env=&lt;var_name&gt; 入口点 修改运行软件包时执行什么命令：--command=&lt;command&gt; 强制指定运行时（需要ID或ID三元组） --runtime=&lt;ID&gt; 临时修改权限相关设置 文件系统：--filesystem，--nofilesystem 规则：--add-policy，--remove-policy 设备：--device，--nodevice Socket：--socket，--nosocket …… 其他选项可参照官方文档了解 进入正在运行的软件包的环境flatpak的软件包运行在相对独立的环境中（类似于容器），因此只能通过命令进入正在运行中的软件包的环境；需要正在运行中的软件包的实例ID； 类似docker exec 1flatpak enter &lt;instance_id&gt; &lt;command&gt; 软件包的权限要查看某个软件包获取了哪些权限： 1flatpak permission-show &lt;ID&gt; 修改软件包的权限：不推荐直接使用命令行修改，可以使用软件包 Flatseal 若软件包出现权限问题，可尝试重置软件包权限解决： 1flatpak permission-reset &lt;ID&gt; 软件包源与直接编辑配置文件增加&#x2F;删除软件源不同，软件包源是通过flatpak命令行增删和管理的； 查看当前已有的源： 1234# 会显示源的名称（Repo name）和源的选项（Options）flatpak remotes# 如果要显示源的链接、优先级等详细信息：flatpak remotes --show-details 删除某个源： 1flatpak remote-delete &lt;repo_name&gt; 添加某个源：软件包源的维护者会提供源的描述文件（.flatpakrepo），而添加源时需要这个描述文件的位置； 1flatpak remote-add &lt;repo_name&gt; &lt;flatpakrepo_url&gt; 其他常用的命令参数 指定作用域：--user，--system 关闭GPG签名校验，测试时非常好用：--no-gpg-verify 本地导入源的GPG密钥：--gpg-import=&lt;gpg_file_url&gt; …… 其他选项可参照官方文档了解 添加源时没有使用命令行参数设置选项，可在以后使用命令行修改； 1flatpak remote-modify &lt;repo_name&gt; 软件包源内的软件包查看某个软件包源内包含的所有软件包： 1flatpak remote-ls &lt;repo_name&gt; 查看某软件包源内某个软件包的具体信息： 1flatpak remote-info &lt;repo_name&gt; &lt;ID&gt;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"Fedora","slug":"Fedora","permalink":"http://wiki.zhouweitong.site/tags/Fedora/"},{"name":"Flatpak","slug":"Flatpak","permalink":"http://wiki.zhouweitong.site/tags/Flatpak/"},{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/tags/Fedora-Silverblue/"}],"categories":[{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/"},{"name":"Flatpak","slug":"Fedora-Silverblue/Flatpak","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Flatpak/"}]},{"title":"清空iptables规则","date":"2023-02-10T07:00:00.000Z","path":"wiki/Linux防火墙/iptables/清空iptables规则/","text":"常见的两种清空iptables规则的方法是： 手动给每一条规则都执行iptables -D： 针对默认表，iptables -D &lt;chain_name&gt; ... 针对其他表，iptables -t &lt;table_name&gt; -D &lt;table_name&gt; ... 查找规则在表的链中是第几条（Line Number），用条目序号进行删除 找条目序号：iptables [-t &lt;table_name&gt;] -L --line-number 使用条目序号进行删除：iptables [-t &lt;table_name&gt;] -D &lt;chain_name&gt; &lt;line_nuber&gt; 但也可以使用下面的方法批量删除： 1234567891011# 如果iptables的默认规则不是ACCEPT，为了防止清除后主机拒绝一切数据包，将所有内置链的默认规则设置为ACCEPTiptables -P INPUT ACCEPTiptables -P FORWARD ACCEPTiptables -P OUTPUT ACCEPT# 删除所有默认表中的rulesiptables -F# 删除指定的其他表中的rulesiptables -t &lt;table_name&gt; -F# 删除默认表中所有user-defined chain（因为此时所有chain均为空）iptables -X 使用场景：在需要完全重建iptables规则，或是使用其他软件代替&#x2F;包装iptables（如firewalld）时；","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"iptables","slug":"iptables","permalink":"http://wiki.zhouweitong.site/tags/iptables/"},{"name":"防火墙","slug":"防火墙","permalink":"http://wiki.zhouweitong.site/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"}],"categories":[{"name":"Linux防火墙","slug":"Linux防火墙","permalink":"http://wiki.zhouweitong.site/categories/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"iptables","slug":"Linux防火墙/iptables","permalink":"http://wiki.zhouweitong.site/categories/Linux%E9%98%B2%E7%81%AB%E5%A2%99/iptables/"}]},{"title":"快速删除无用的Docker Image","date":"2023-02-03T02:07:00.000Z","path":"wiki/Docker/快速删除无用的Image/","text":"docker image pruneDocker提供了可以快速删除无用镜像的命令： 1docker image prune 可直接运行，效果：删除所有悬空的（Dangling）镜像 Dangling Image 指无镜像名或无镜像版本的镜像，比如：xxx:&lt;none&gt;、&lt;none&gt;:xxx、&lt;none&gt;:&lt;none&gt; 均是Dangling Image 注意：是 image，不是 images docker images 只用于查看已拉取的镜像详情 docker image 用于对镜像进行操作 docker image prune 有三个重要参数： -f：直接执行不确认 -a：除了删除Dangling Image外，还删除未被任何容器使用的镜像 --filter：过滤器，用于选择性删除 --filter until=时间戳：在该时间戳之前的镜像会被处理 --filter until=48h：近48小时内的镜像不处理 --filter until=2023-01-01T04:00:00：在2023&#x2F;01&#x2F;01 04:00:00之后的镜像不处理 --filter label=标签名：有这个标签的镜像才处理 --filter label!=标签名：没有这个标签的镜像才处理 --filter label=标签名=标签值，--filter label!=标签名=标签值：指定标签的值 docker container prune与docker image prune类似，但是对容器进行操作：删除所有停止（Stopped）的容器。 1docker container prune 有两个参数： -f：直接执行不确认 --filter：过滤器，用法同docker image prune --filter","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://wiki.zhouweitong.site/tags/Docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://wiki.zhouweitong.site/tags/CI-CD/"},{"name":"Docker Image","slug":"Docker-Image","permalink":"http://wiki.zhouweitong.site/tags/Docker-Image/"}],"categories":[{"name":"Docker","slug":"Docker","permalink":"http://wiki.zhouweitong.site/categories/Docker/"}]},{"title":"Flathub & 如何制作Flathub镜像","date":"2023-02-02T12:38:00.000Z","path":"wiki/Fedora Silverblue/Flatpak/Flathub & 如何制作Flathub镜像/","text":"TODO：flathub设置，flatpack repo建立，如何mirror，如何公网访问","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"Fedora","slug":"Fedora","permalink":"http://wiki.zhouweitong.site/tags/Fedora/"},{"name":"OSTree","slug":"OSTree","permalink":"http://wiki.zhouweitong.site/tags/OSTree/"},{"name":"Flatpak","slug":"Flatpak","permalink":"http://wiki.zhouweitong.site/tags/Flatpak/"},{"name":"Flathub","slug":"Flathub","permalink":"http://wiki.zhouweitong.site/tags/Flathub/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/"},{"name":"Flatpak","slug":"Fedora-Silverblue/Flatpak","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Flatpak/"}]},{"title":"欢迎访问 ObjectNotFound 个人知识库","date":"2023-01-18T09:00:00.000Z","path":"wiki/index/","text":"本知识库以类 Wiki 形式进行组织，内容可能包括： 独立的笔记，例如编程语言的语法笔记； 对一些概念的主观理解，例如如何理解商品的价值与价格； 零散的技巧，例如如何通过一条命令删除机器Docker上未使用的所有镜像； 读后感、观后感、游戏剧情分析等，例如原神&#x2F;明日方舟世界观分析、死亡搁浅剧情概要等； 不同类别的知识放入不同的二级分类中，可通过“分类”页面检索。 由于本知识库的个人性质，因此： 不接受直接的内容编辑和贡献，非常欢迎有此想法的读者在评论区写出详细内容； 不接受“向 Wiki 增加 xxx 条目”类似的请求； 内容可能存在错漏，非常欢迎读者在评论区指出； 内容带有主观色彩和个人立场，部分情况下无法无视； 特别注意：知识库内的条目有可能在改写、完善后作为博客（主站）文章发布，因此如果曾经访问过或收藏过的页面不存在了，可以去主站找找有没有相关的博客文章。 以下是部分一级分类的详细介绍： 多国语：指日常生活中沟通交流所使用的自然语言。 网络安全：指网络安全竞赛（夺旗赛CTF等）、网络安全技术、网络安全行业等。 编程语言：指程序开发时所用到的各类程序语言。此模块会记录一些语言的语法、例程、技巧及开发注意事项等。 数学：指算法、额外的数学知识、额外的信息理论知识等。 游戏开发：指游戏程序开发、游戏引擎、游戏玩法分类与设计、游戏剧情策划、游戏数值策划等。 设计：指平面设计、UI设计、UX设计、字体设计、网页设计、人物设计、服装设计等。 绘画：指绘画理论、线稿修饰、透视上色、数字绘景、3D辅助作画、厚涂半厚涂及赛璐璐风格剖析等。 舞台技术：指现场拾音调音、打光（调光）、导播、直播、舞台弹幕互动等。 音乐与音频：指乐理、声音理论、效果器、合成器、修音、后期处理、母带、电音分类与制作等。 传媒：指影视剪辑、影视特效、人像处理、广告包装、营销、色彩修正、视频压制、视频字幕等。 技术美术：指DCC（与的上述分类重复的除外）、三维技术、渲染技术、特效（与上述分类重复的除外）、计算机图形学（上述分类重复的除外）等。 流媒体技术：指音视频直播技术、流媒体编解码技术等。 人工智能与机器学习：指人工智能理论、机器学习理论、神经网络分类、人工智能框架、人工智能开发、人工智能法律等。 区块链：指区块链理论、加密货币、智能合约、区块链存储、区块链开发等。 文学与考证：指书摘、书评、世界观描述、科幻体系架构、神秘学、宗教文化等。 名词注解：指零散的、不成体系的“百科全书”式的词条，对一个或多个名词的个人理解进行记录。","tags":[],"categories":[]},{"title":"X to Y","date":"2023-01-18T09:00:00.000Z","path":"wiki/名词注解/X to Y/","text":"常见的缩写： 2：“to”，谐音 G：“Government”，政府 E：“Employee”，职工&#x2F;雇员 C：“Costumer”，消费者 B：“Business”，商业&#x2F;公司 举例说明： B2C：Business to Costumer，即公司给消费者提供服务。公司生产产品供消费者购买使用属于此类。 B2B：Business to Business，即公司给公司提供服务。原材料公司将产品进行粗加工后提供给其他公司做精细加工属于此类。 B2G：Business to Government，即公司给政府提供服务。云计算公司给政府提供云计算基础设施属于此类。","tags":[{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"name":"B2B","slug":"B2B","permalink":"http://wiki.zhouweitong.site/tags/B2B/"},{"name":"B2C","slug":"B2C","permalink":"http://wiki.zhouweitong.site/tags/B2C/"},{"name":"B2G","slug":"B2G","permalink":"http://wiki.zhouweitong.site/tags/B2G/"}],"categories":[{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/categories/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"}]},{"title":"第X国际","date":"2023-01-18T09:00:00.000Z","path":"wiki/名词注解/第X国际/","text":"主观理解 历史上存在第一国际、第二国际、第三国际、第二半国际、第四国际、第五国际这六种提法。 第一国际：又称“国际工人联合会”，由马克思领导，于1864年成立，于1876年解散。历史意义集中在思想的宣传和发展方面。巴黎公社运动由第一国际的法国支部参加和领导。[1] 第二国际：又称“社会主义国际”，由恩格斯领导，于1889年成立，于1914年解散，活跃于第一次世界大战前夕。其中1895年恩格斯逝世后，机会主义开始泛滥，因此1896年第二国际修正主义开始形成。[2] [3] 第三国际：又称“共产国际”，由布尔什维克领导，于1919年成立，于1943年解散。中国于1922年加入第三国际，于1940年中断联系。[4] 第二半国际：又称“维也纳国际”，于1921年成立，于1923年与伯尔尼国际合并为社会主义工人国际。[5] 第四国际：又称“世界社会主义革命党”，由托洛茨基领导，于1938年成立，活跃至今。活跃期间组织发生多次分裂。[6] 第五国际：并不是单一的组织，而是泛指第四国际后部分社会主义和无产阶级尝试创建新的国际联盟的努力。“争取第五国际联盟”于1990年改为现用名称，现已解散并合并入英国工党。[7] [8] 1.第一国际 - 百度百科 ↩2.第二国际 - 百度百科 ↩3.第二国际修正主义 - 百度百科 ↩4.第三国际 - 百度百科 ↩5.第二半国际 - 百度百科 ↩6.第四国际 - 百度百科 ↩7.第五国际 - 百度百科 ↩8.争取第五国际联盟 - 维基百科，自由的百科全书 ↩","tags":[{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"name":"第一国际","slug":"第一国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%B8%80%E5%9B%BD%E9%99%85/"},{"name":"第二国际","slug":"第二国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%BA%8C%E5%9B%BD%E9%99%85/"},{"name":"第三国际","slug":"第三国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%B8%89%E5%9B%BD%E9%99%85/"},{"name":"第四国际","slug":"第四国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E5%9B%9B%E5%9B%BD%E9%99%85/"},{"name":"第五国际","slug":"第五国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%BA%94%E5%9B%BD%E9%99%85/"}],"categories":[{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/categories/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"}]},{"title":"费控","date":"2023-01-18T09:00:00.000Z","path":"wiki/名词注解/费控/","text":"“成本费用控制”的简称，是指企业在生产经营过程中，按照既定的成本费用目标，对构成成本费用的诸要素进行的规划、限制和调节，及时纠正偏差，控制成本费用超支，把实际耗费控制在成本费用计划范围内[1]。 1.成本费用控制_百度百科 ↩","tags":[{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"name":"费控","slug":"费控","permalink":"http://wiki.zhouweitong.site/tags/%E8%B4%B9%E6%8E%A7/"}],"categories":[{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/categories/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"}]},{"title":"概念","date":"2023-01-18T09:00:00.000Z","path":"wiki/多国语/中文/概念/","text":"语流音变在语流中，由于受到相邻音节的相邻音素的影响，一些音节中的声母、韵母或声调会发生语音的变化，我们称之为语流音变。[1] “音变”，指的是声音发生了变化。“语流”，人在说话的时候并非发出一个个单独的字音，而是由字成词、连词成句。 1.https://baike.baidu.com/item/%E8%AF%AD%E6%B5%81%E9%9F%B3%E5%8F%98/5667409 ↩","tags":[{"name":"概念","slug":"概念","permalink":"http://wiki.zhouweitong.site/tags/%E6%A6%82%E5%BF%B5/"},{"name":"中文","slug":"中文","permalink":"http://wiki.zhouweitong.site/tags/%E4%B8%AD%E6%96%87/"},{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/tags/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"语言","slug":"语言","permalink":"http://wiki.zhouweitong.site/tags/%E8%AF%AD%E8%A8%80/"},{"name":"持续更新","slug":"持续更新","permalink":"http://wiki.zhouweitong.site/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"中文","slug":"多国语/中文","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E4%B8%AD%E6%96%87/"}]},{"title":"方言及区别","date":"2023-01-18T09:00:00.000Z","path":"wiki/多国语/日语/方言及区别/","text":"日语分支与方言众多[1] 。比较有名的如 大阪话（关西方言）、北海道方言、博多方言 等。 1.http://m.fx361.com/news/2017/0906/2229969.html ↩","tags":[{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/tags/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"语言","slug":"语言","permalink":"http://wiki.zhouweitong.site/tags/%E8%AF%AD%E8%A8%80/"},{"name":"日语","slug":"日语","permalink":"http://wiki.zhouweitong.site/tags/%E6%97%A5%E8%AF%AD/"},{"name":"方言","slug":"方言","permalink":"http://wiki.zhouweitong.site/tags/%E6%96%B9%E8%A8%80/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"日语","slug":"多国语/日语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E6%97%A5%E8%AF%AD/"}]},{"title":"法语字母","date":"2023-01-18T09:00:00.000Z","path":"wiki/多国语/法语/法语字母/","text":"","tags":[{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/tags/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"语言","slug":"语言","permalink":"http://wiki.zhouweitong.site/tags/%E8%AF%AD%E8%A8%80/"},{"name":"法语","slug":"法语","permalink":"http://wiki.zhouweitong.site/tags/%E6%B3%95%E8%AF%AD/"},{"name":"字母","slug":"字母","permalink":"http://wiki.zhouweitong.site/tags/%E5%AD%97%E6%AF%8D/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"}],"categories":[{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"法语","slug":"多国语/法语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E6%B3%95%E8%AF%AD/"}]},{"title":"常见缩略语","date":"2023-01-18T09:00:00.000Z","path":"wiki/多国语/英语/常见缩略语/","text":"w.r.t：也写作WRT或w&#x2F;r&#x2F;t或r&#x2F;t，表示“至于说…”、“关于…”、“对…来说”。 例一：WRT the docs, there&#39;s an issue. 至于那些文档，其中有个问题。 例二：Code is where the &quot;rubber meets the road&quot; w/r/t performance. 代码是关系到性能“有所偏差”的地方。","tags":[{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/tags/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"语言","slug":"语言","permalink":"http://wiki.zhouweitong.site/tags/%E8%AF%AD%E8%A8%80/"},{"name":"英语","slug":"英语","permalink":"http://wiki.zhouweitong.site/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"缩略语","slug":"缩略语","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%A9%E7%95%A5%E8%AF%AD/"},{"name":"持续更新","slug":"持续更新","permalink":"http://wiki.zhouweitong.site/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"英语","slug":"多国语/英语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E8%8B%B1%E8%AF%AD/"}]},{"title":"EQ调节误区","date":"2023-01-18T09:00:00.000Z","path":"wiki/音乐与音频/效果器/EQ调节误区/","text":"来源：BV1yA411H7id “EQ调节范围应小于3db或者6db”：不正确。应该依照素材的特性，确定EQ的调节范围。 “EQ应该多做减法（降低声音响度）少做加法（提升声音响度）”：不正确。加法和减法没有必然的使用要求，多数情况下加法合成器更加符合工作流程。 过度扫频：错误。任何过度使用EQ的操作都是错误的，淹没声音特点，而且会习惯性的使用不必要的EQ。-&gt; 只在需要进行EQ处理的时候使用EQ 做EQ时尽量不要Solo，注意“上下文”。","tags":[{"name":"音乐与音频","slug":"音乐与音频","permalink":"http://wiki.zhouweitong.site/tags/%E9%9F%B3%E4%B9%90%E4%B8%8E%E9%9F%B3%E9%A2%91/"},{"name":"效果器","slug":"效果器","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%88%E6%9E%9C%E5%99%A8/"},{"name":"EQ","slug":"EQ","permalink":"http://wiki.zhouweitong.site/tags/EQ/"},{"name":"制作技巧","slug":"制作技巧","permalink":"http://wiki.zhouweitong.site/tags/%E5%88%B6%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"categories":[{"name":"音乐与音频","slug":"音乐与音频","permalink":"http://wiki.zhouweitong.site/categories/%E9%9F%B3%E4%B9%90%E4%B8%8E%E9%9F%B3%E9%A2%91/"},{"name":"效果器","slug":"音乐与音频/效果器","permalink":"http://wiki.zhouweitong.site/categories/%E9%9F%B3%E4%B9%90%E4%B8%8E%E9%9F%B3%E9%A2%91/%E6%95%88%E6%9E%9C%E5%99%A8/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"Windows","slug":"C/Windows","permalink":"http://wiki.zhouweitong.site/categories/C/Windows/"},{"name":"基础语法","slug":"C/基础语法","permalink":"http://wiki.zhouweitong.site/categories/C/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"C/STL","permalink":"http://wiki.zhouweitong.site/categories/C/STL/"},{"name":"AI绘画","slug":"AI绘画","permalink":"http://wiki.zhouweitong.site/categories/AI%E7%BB%98%E7%94%BB/"},{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/"},{"name":"高等数学","slug":"数学/高等数学","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Lua","slug":"Lua","permalink":"http://wiki.zhouweitong.site/categories/Lua/"},{"name":"CUDA","slug":"CUDA","permalink":"http://wiki.zhouweitong.site/categories/CUDA/"},{"name":"K8s","slug":"K8s","permalink":"http://wiki.zhouweitong.site/categories/K8s/"},{"name":"编码规范","slug":"C/编码规范","permalink":"http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"CMake","slug":"C/CMake","permalink":"http://wiki.zhouweitong.site/categories/C/CMake/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"版本控制","slug":"版本控制","permalink":"http://wiki.zhouweitong.site/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"计算机组成","slug":"计算机组成","permalink":"http://wiki.zhouweitong.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"},{"name":"Linux浏览器","slug":"Linux浏览器","permalink":"http://wiki.zhouweitong.site/categories/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://wiki.zhouweitong.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"线性代数","slug":"数学/线性代数","permalink":"http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"C#","slug":"C","permalink":"http://wiki.zhouweitong.site/categories/C/"},{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/"},{"name":"Toolbox","slug":"Fedora-Silverblue/Toolbox","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Toolbox/"},{"name":"驾照","slug":"驾照","permalink":"http://wiki.zhouweitong.site/categories/%E9%A9%BE%E7%85%A7/"},{"name":"科目一","slug":"驾照/科目一","permalink":"http://wiki.zhouweitong.site/categories/%E9%A9%BE%E7%85%A7/%E7%A7%91%E7%9B%AE%E4%B8%80/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"http://wiki.zhouweitong.site/categories/Arch-Linux/"},{"name":"Flatpak","slug":"Fedora-Silverblue/Flatpak","permalink":"http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Flatpak/"},{"name":"Linux防火墙","slug":"Linux防火墙","permalink":"http://wiki.zhouweitong.site/categories/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"iptables","slug":"Linux防火墙/iptables","permalink":"http://wiki.zhouweitong.site/categories/Linux%E9%98%B2%E7%81%AB%E5%A2%99/iptables/"},{"name":"Docker","slug":"Docker","permalink":"http://wiki.zhouweitong.site/categories/Docker/"},{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/categories/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"中文","slug":"多国语/中文","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E4%B8%AD%E6%96%87/"},{"name":"日语","slug":"多国语/日语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E6%97%A5%E8%AF%AD/"},{"name":"法语","slug":"多国语/法语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E6%B3%95%E8%AF%AD/"},{"name":"英语","slug":"多国语/英语","permalink":"http://wiki.zhouweitong.site/categories/%E5%A4%9A%E5%9B%BD%E8%AF%AD/%E8%8B%B1%E8%AF%AD/"},{"name":"音乐与音频","slug":"音乐与音频","permalink":"http://wiki.zhouweitong.site/categories/%E9%9F%B3%E4%B9%90%E4%B8%8E%E9%9F%B3%E9%A2%91/"},{"name":"效果器","slug":"音乐与音频/效果器","permalink":"http://wiki.zhouweitong.site/categories/%E9%9F%B3%E4%B9%90%E4%B8%8E%E9%9F%B3%E9%A2%91/%E6%95%88%E6%9E%9C%E5%99%A8/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"未写完","slug":"未写完","permalink":"http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"},{"name":"Windows","slug":"Windows","permalink":"http://wiki.zhouweitong.site/tags/Windows/"},{"name":"动态链接库","slug":"动态链接库","permalink":"http://wiki.zhouweitong.site/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"静态库","slug":"静态库","permalink":"http://wiki.zhouweitong.site/tags/%E9%9D%99%E6%80%81%E5%BA%93/"},{"name":"GCC","slug":"GCC","permalink":"http://wiki.zhouweitong.site/tags/GCC/"},{"name":"G++","slug":"G","permalink":"http://wiki.zhouweitong.site/tags/G/"},{"name":"匈牙利命名法","slug":"匈牙利命名法","permalink":"http://wiki.zhouweitong.site/tags/%E5%8C%88%E7%89%99%E5%88%A9%E5%91%BD%E5%90%8D%E6%B3%95/"},{"name":"宏","slug":"宏","permalink":"http://wiki.zhouweitong.site/tags/%E5%AE%8F/"},{"name":"宏函数","slug":"宏函数","permalink":"http://wiki.zhouweitong.site/tags/%E5%AE%8F%E5%87%BD%E6%95%B0/"},{"name":"Macro","slug":"Macro","permalink":"http://wiki.zhouweitong.site/tags/Macro/"},{"name":"STL","slug":"STL","permalink":"http://wiki.zhouweitong.site/tags/STL/"},{"name":"array","slug":"array","permalink":"http://wiki.zhouweitong.site/tags/array/"},{"name":"vector","slug":"vector","permalink":"http://wiki.zhouweitong.site/tags/vector/"},{"name":"tuple","slug":"tuple","permalink":"http://wiki.zhouweitong.site/tags/tuple/"},{"name":"速查表","slug":"速查表","permalink":"http://wiki.zhouweitong.site/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"name":"Stable Diffusion","slug":"Stable-Diffusion","permalink":"http://wiki.zhouweitong.site/tags/Stable-Diffusion/"},{"name":"Novel AI","slug":"Novel-AI","permalink":"http://wiki.zhouweitong.site/tags/Novel-AI/"},{"name":"模型与插件","slug":"模型与插件","permalink":"http://wiki.zhouweitong.site/tags/%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%8F%92%E4%BB%B6/"},{"name":"any","slug":"any","permalink":"http://wiki.zhouweitong.site/tags/any/"},{"name":"variant","slug":"variant","permalink":"http://wiki.zhouweitong.site/tags/variant/"},{"name":"数学","slug":"数学","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%B0%E5%AD%A6/"},{"name":"函数","slug":"函数","permalink":"http://wiki.zhouweitong.site/tags/%E5%87%BD%E6%95%B0/"},{"name":"极限","slug":"极限","permalink":"http://wiki.zhouweitong.site/tags/%E6%9E%81%E9%99%90/"},{"name":"高等数学","slug":"高等数学","permalink":"http://wiki.zhouweitong.site/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"OS","slug":"OS","permalink":"http://wiki.zhouweitong.site/tags/OS/"},{"name":"操作系统","slug":"操作系统","permalink":"http://wiki.zhouweitong.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"持续更新","slug":"持续更新","permalink":"http://wiki.zhouweitong.site/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"name":"内存","slug":"内存","permalink":"http://wiki.zhouweitong.site/tags/%E5%86%85%E5%AD%98/"},{"name":"进程","slug":"进程","permalink":"http://wiki.zhouweitong.site/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://wiki.zhouweitong.site/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"锁","slug":"锁","permalink":"http://wiki.zhouweitong.site/tags/%E9%94%81/"},{"name":"互斥","slug":"互斥","permalink":"http://wiki.zhouweitong.site/tags/%E4%BA%92%E6%96%A5/"},{"name":"Lua","slug":"Lua","permalink":"http://wiki.zhouweitong.site/tags/Lua/"},{"name":"CUDA","slug":"CUDA","permalink":"http://wiki.zhouweitong.site/tags/CUDA/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://wiki.zhouweitong.site/tags/NVIDIA/"},{"name":"GPU","slug":"GPU","permalink":"http://wiki.zhouweitong.site/tags/GPU/"},{"name":"K8s","slug":"K8s","permalink":"http://wiki.zhouweitong.site/tags/K8s/"},{"name":"K3s","slug":"K3s","permalink":"http://wiki.zhouweitong.site/tags/K3s/"},{"name":"Minikube","slug":"Minikube","permalink":"http://wiki.zhouweitong.site/tags/Minikube/"},{"name":"编码规范","slug":"编码规范","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"CMake","slug":"CMake","permalink":"http://wiki.zhouweitong.site/tags/CMake/"},{"name":"概率论","slug":"概率论","permalink":"http://wiki.zhouweitong.site/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"数理统计","slug":"数理统计","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"随机事件","slug":"随机事件","permalink":"http://wiki.zhouweitong.site/tags/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/"},{"name":"UML","slug":"UML","permalink":"http://wiki.zhouweitong.site/tags/UML/"},{"name":"SVN","slug":"SVN","permalink":"http://wiki.zhouweitong.site/tags/SVN/"},{"name":"Git","slug":"Git","permalink":"http://wiki.zhouweitong.site/tags/Git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://wiki.zhouweitong.site/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Version Control","slug":"Version-Control","permalink":"http://wiki.zhouweitong.site/tags/Version-Control/"},{"name":"优缺点","slug":"优缺点","permalink":"http://wiki.zhouweitong.site/tags/%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://wiki.zhouweitong.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"Computer Architecture","slug":"Computer-Architecture","permalink":"http://wiki.zhouweitong.site/tags/Computer-Architecture/"},{"name":"Linux","slug":"Linux","permalink":"http://wiki.zhouweitong.site/tags/Linux/"},{"name":"浏览器","slug":"浏览器","permalink":"http://wiki.zhouweitong.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"显卡加速","slug":"显卡加速","permalink":"http://wiki.zhouweitong.site/tags/%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/"},{"name":"Chromium","slug":"Chromium","permalink":"http://wiki.zhouweitong.site/tags/Chromium/"},{"name":"Microsoft Edge","slug":"Microsoft-Edge","permalink":"http://wiki.zhouweitong.site/tags/Microsoft-Edge/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://wiki.zhouweitong.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Network","slug":"Network","permalink":"http://wiki.zhouweitong.site/tags/Network/"},{"name":"线性代数","slug":"线性代数","permalink":"http://wiki.zhouweitong.site/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"行列式","slug":"行列式","permalink":"http://wiki.zhouweitong.site/tags/%E8%A1%8C%E5%88%97%E5%BC%8F/"},{"name":"C#","slug":"C","permalink":"http://wiki.zhouweitong.site/tags/C/"},{"name":"Docker","slug":"Docker","permalink":"http://wiki.zhouweitong.site/tags/Docker/"},{"name":"Fedora","slug":"Fedora","permalink":"http://wiki.zhouweitong.site/tags/Fedora/"},{"name":"Toolbox","slug":"Toolbox","permalink":"http://wiki.zhouweitong.site/tags/Toolbox/"},{"name":"Podman","slug":"Podman","permalink":"http://wiki.zhouweitong.site/tags/Podman/"},{"name":"驾照","slug":"驾照","permalink":"http://wiki.zhouweitong.site/tags/%E9%A9%BE%E7%85%A7/"},{"name":"科目一","slug":"科目一","permalink":"http://wiki.zhouweitong.site/tags/%E7%A7%91%E7%9B%AE%E4%B8%80/"},{"name":"口诀","slug":"口诀","permalink":"http://wiki.zhouweitong.site/tags/%E5%8F%A3%E8%AF%80/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"http://wiki.zhouweitong.site/tags/Arch-Linux/"},{"name":"发行版安装","slug":"发行版安装","permalink":"http://wiki.zhouweitong.site/tags/%E5%8F%91%E8%A1%8C%E7%89%88%E5%AE%89%E8%A3%85/"},{"name":"Flatpak","slug":"Flatpak","permalink":"http://wiki.zhouweitong.site/tags/Flatpak/"},{"name":"Fedora Silverblue","slug":"Fedora-Silverblue","permalink":"http://wiki.zhouweitong.site/tags/Fedora-Silverblue/"},{"name":"概念","slug":"概念","permalink":"http://wiki.zhouweitong.site/tags/%E6%A6%82%E5%BF%B5/"},{"name":"iptables","slug":"iptables","permalink":"http://wiki.zhouweitong.site/tags/iptables/"},{"name":"防火墙","slug":"防火墙","permalink":"http://wiki.zhouweitong.site/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://wiki.zhouweitong.site/tags/CI-CD/"},{"name":"Docker Image","slug":"Docker-Image","permalink":"http://wiki.zhouweitong.site/tags/Docker-Image/"},{"name":"OSTree","slug":"OSTree","permalink":"http://wiki.zhouweitong.site/tags/OSTree/"},{"name":"Flathub","slug":"Flathub","permalink":"http://wiki.zhouweitong.site/tags/Flathub/"},{"name":"名词解释","slug":"名词解释","permalink":"http://wiki.zhouweitong.site/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"name":"B2B","slug":"B2B","permalink":"http://wiki.zhouweitong.site/tags/B2B/"},{"name":"B2C","slug":"B2C","permalink":"http://wiki.zhouweitong.site/tags/B2C/"},{"name":"B2G","slug":"B2G","permalink":"http://wiki.zhouweitong.site/tags/B2G/"},{"name":"第一国际","slug":"第一国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%B8%80%E5%9B%BD%E9%99%85/"},{"name":"第二国际","slug":"第二国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%BA%8C%E5%9B%BD%E9%99%85/"},{"name":"第三国际","slug":"第三国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%B8%89%E5%9B%BD%E9%99%85/"},{"name":"第四国际","slug":"第四国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E5%9B%9B%E5%9B%BD%E9%99%85/"},{"name":"第五国际","slug":"第五国际","permalink":"http://wiki.zhouweitong.site/tags/%E7%AC%AC%E4%BA%94%E5%9B%BD%E9%99%85/"},{"name":"费控","slug":"费控","permalink":"http://wiki.zhouweitong.site/tags/%E8%B4%B9%E6%8E%A7/"},{"name":"中文","slug":"中文","permalink":"http://wiki.zhouweitong.site/tags/%E4%B8%AD%E6%96%87/"},{"name":"多国语","slug":"多国语","permalink":"http://wiki.zhouweitong.site/tags/%E5%A4%9A%E5%9B%BD%E8%AF%AD/"},{"name":"语言","slug":"语言","permalink":"http://wiki.zhouweitong.site/tags/%E8%AF%AD%E8%A8%80/"},{"name":"日语","slug":"日语","permalink":"http://wiki.zhouweitong.site/tags/%E6%97%A5%E8%AF%AD/"},{"name":"方言","slug":"方言","permalink":"http://wiki.zhouweitong.site/tags/%E6%96%B9%E8%A8%80/"},{"name":"法语","slug":"法语","permalink":"http://wiki.zhouweitong.site/tags/%E6%B3%95%E8%AF%AD/"},{"name":"字母","slug":"字母","permalink":"http://wiki.zhouweitong.site/tags/%E5%AD%97%E6%AF%8D/"},{"name":"英语","slug":"英语","permalink":"http://wiki.zhouweitong.site/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"缩略语","slug":"缩略语","permalink":"http://wiki.zhouweitong.site/tags/%E7%BC%A9%E7%95%A5%E8%AF%AD/"},{"name":"音乐与音频","slug":"音乐与音频","permalink":"http://wiki.zhouweitong.site/tags/%E9%9F%B3%E4%B9%90%E4%B8%8E%E9%9F%B3%E9%A2%91/"},{"name":"效果器","slug":"效果器","permalink":"http://wiki.zhouweitong.site/tags/%E6%95%88%E6%9E%9C%E5%99%A8/"},{"name":"EQ","slug":"EQ","permalink":"http://wiki.zhouweitong.site/tags/EQ/"},{"name":"制作技巧","slug":"制作技巧","permalink":"http://wiki.zhouweitong.site/tags/%E5%88%B6%E4%BD%9C%E6%8A%80%E5%B7%A7/"}]}