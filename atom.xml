<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ObjectNotFound Wiki</title>
  
  
  <link href="http://wiki.zhouweitong.site/atom.xml" rel="self"/>
  
  <link href="http://wiki.zhouweitong.site/"/>
  <updated>2023-03-10T15:32:54.882Z</updated>
  <id>http://wiki.zhouweitong.site/</id>
  
  <author>
    <name>ObjectNotFound</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flathub &amp; 如何制作Flathub镜像</title>
    <link href="http://wiki.zhouweitong.site/wiki/Fedora%20Silverblue/Flatpak/Flathub%20&amp;%20%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CFlathub%E9%95%9C%E5%83%8F/"/>
    <id>http://wiki.zhouweitong.site/wiki/Fedora%20Silverblue/Flatpak/Flathub%20&amp;%20%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CFlathub%E9%95%9C%E5%83%8F/</id>
    <published>2023-03-10T13:30:00.000Z</published>
    <updated>2023-03-10T15:32:54.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>TODO：flatpack repo建立，如何mirror，如何公网访问</p></blockquote><h2 id="什么是Flathub？"><a href="#什么是Flathub？" class="headerlink" title="什么是Flathub？"></a>什么是Flathub？</h2><ul><li>Flathub之于Flatpak，正如Snapcraft之于Snap<ul><li>类似于“官方Repo”，但是由社区维护</li><li>与AUR不同，Flathub存储了软件的二进制文件，而不只是构建文件</li><li>Flathub有着自己的大型CI集群<a href="https://buildbot.flathub.org/#/">Flathub Buildbot</a></li></ul></li><li>安装发行版上的Flatpak时，不一定默认启用Flathub，需要手动查看和添加</li></ul><h2 id="启用Flathub"><a href="#启用Flathub" class="headerlink" title="启用Flathub"></a>启用Flathub</h2><ul><li>查看已经启用的源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak remotes</span><br></pre></td></tr></table></figure><ul><li>如果没有<code>flathub</code>源，就需要手动添加</li><li>添加Flathub源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo</span><br></pre></td></tr></table></figure><ul><li>随后就可以安装Flathub中的软件包了</li></ul><h2 id="搭建Flathub镜像"><a href="#搭建Flathub镜像" class="headerlink" title="搭建Flathub镜像"></a>搭建Flathub镜像</h2><ul><li>Flatpak Repo的本质就是一个OSTree Repo，Flathub也不例外</li><li>Flathub的OSTree Repo地址可从flatpakrepo文件中找到：<code>https://dl.flathub.org/repo/</code></li><li>使用该地址可以进行 全量镜像 及 部分镜像</li></ul><h3 id="全量镜像"><a href="#全量镜像" class="headerlink" title="全量镜像"></a>全量镜像</h3><ul><li>数TB大小，包含所有软件包的所有历史版本</li><li>需要的同步时间较长</li><li>使用<code>rsync</code>，以及第三方脚本<code>rsync-repos</code>，脚本的代码见<a href="https://github.com/ostreedev/ostree-releng-scripts/blob/master/rsync-repos">ostree-releng-scripts&#x2F;rsync-repos at master · ostreedev&#x2F;ostree-releng-scripts</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装rsync</span></span><br><span class="line">sudo dnf install rsync</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="Fedora Silverblue" scheme="http://wiki.zhouweitong.site/categories/Fedora-Silverblue/"/>
    
    <category term="Flatpak" scheme="http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Flatpak/"/>
    
    
    <category term="Linux" scheme="http://wiki.zhouweitong.site/tags/Linux/"/>
    
    <category term="Fedora" scheme="http://wiki.zhouweitong.site/tags/Fedora/"/>
    
    <category term="OSTree" scheme="http://wiki.zhouweitong.site/tags/OSTree/"/>
    
    <category term="Flatpak" scheme="http://wiki.zhouweitong.site/tags/Flatpak/"/>
    
    <category term="Flathub" scheme="http://wiki.zhouweitong.site/tags/Flathub/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>AI绘画模型和插件汇总</title>
    <link href="http://wiki.zhouweitong.site/wiki/AI%E7%BB%98%E7%94%BB/AI%E7%BB%98%E7%94%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
    <id>http://wiki.zhouweitong.site/wiki/AI%E7%BB%98%E7%94%BB/AI%E7%BB%98%E7%94%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</id>
    <published>2023-03-09T08:00:00.000Z</published>
    <updated>2023-03-09T08:20:01.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="绘画模型（-ckpt-x2F-safetensors）"><a href="#绘画模型（-ckpt-x2F-safetensors）" class="headerlink" title="绘画模型（*.ckpt&#x2F;*.safetensors）"></a>绘画模型（*.ckpt&#x2F;*.safetensors）</h2><h3 id="Novel-AI-泄露版模型"><a href="#Novel-AI-泄露版模型" class="headerlink" title="Novel AI 泄露版模型"></a>Novel AI 泄露版模型</h3><ul><li>基于Stable Diffusion网络结构，使用Danbooru数据集进行多次训练后的权重</li><li>至少需 5.8GiB 存储空间</li><li>磁力链接，使用BitTorrent协议下载</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnet:?xt=urn:btih:5bde442da86265b670a3e5ea3163afad2c6f8ecc</span><br></pre></td></tr></table></figure><ul><li>SFW（Suitable For Work）模型：<code>stableckpt/animesfw-final-pruned</code></li><li>NSFW模型：<code>stableckpt/animefull-final-pruned</code></li></ul><h3 id="Stable-Diffusion-官方模型"><a href="#Stable-Diffusion-官方模型" class="headerlink" title="Stable Diffusion 官方模型"></a>Stable Diffusion 官方模型</h3><ul><li>官方Stable Diffusion，使用多个图片数据集</li><li>Stable Diffusion 1.5<ul><li><a href="https://huggingface.co/runwayml/stable-diffusion-v1-5">runwayml&#x2F;stable-diffusion-v1-5 · Hugging Face</a></li><li>至少需 4.0GB 存储空间</li></ul></li><li>其他Stable Diffusion 1.x版本模型：<a href="https://huggingface.co/CompVis">CompVis (CompVis)</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.ckpt</span><br></pre></td></tr></table></figure><ul><li>Stable Diffusion 2.1<ul><li><a href="https://huggingface.co/stabilityai/stable-diffusion-2-1">stabilityai&#x2F;stable-diffusion-2-1 · Hugging Face</a></li><li>至少需 4.9GB 存储空间</li></ul></li><li>其他Stable Diffusion 2.x版本模型：<a href="https://huggingface.co/stabilityai">stabilityai (Stability AI)</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt</span><br></pre></td></tr></table></figure><h3 id="Waifu-Diffusion"><a href="#Waifu-Diffusion" class="headerlink" title="Waifu Diffusion"></a>Waifu Diffusion</h3><ul><li>使用Stable Diffusion网络结构，精选了Danbooru数据集</li><li>Waifu Diffusion 1.4<ul><li><a href="https://huggingface.co/hakurei/waifu-diffusion-v1-4">hakurei&#x2F;waifu-diffusion-v1-4 · Hugging Face</a></li><li>至少需 4.8GB 存储空间</li></ul></li><li>其他Waifu Diffusion 1.x版本模型：<a href="https://huggingface.co/hakurei">hakurei (Reimu Hakurei)</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/hakurei/waifu-diffusion-v1-4/resolve/main/wd-1-4-anime_e2.ckpt</span><br></pre></td></tr></table></figure><h3 id="Kenshi"><a href="#Kenshi" class="headerlink" title="Kenshi"></a>Kenshi</h3><ul><li>基于Stable Diffusion网络结构，强调“照片感”。是对多个模型的加权融合，包括BoChen模型、WLOP模型等；</li><li>Kenshi01<ul><li><a href="https://huggingface.co/SweetLuna/Kenshi">SweetLuna&#x2F;Kenshi · Hugging Face</a></li><li>至少需 4.0GB 存储空间</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/SweetLuna/Kenshi/resolve/main/KENSHI%2001/KENSHI01_Pruned.ckpt</span><br></pre></td></tr></table></figure><h3 id="AbyssOrangeMix3"><a href="#AbyssOrangeMix3" class="headerlink" title="AbyssOrangeMix3"></a>AbyssOrangeMix3</h3><ul><li>基于Stable Diffusion网络结构，是对多个模型的加权融合，侧重“高质量”和“画面内的纹理效果”</li><li>分为A1（平涂）、A2（厚涂；油画风）、A3（融合）三个版本</li><li>至少需 2.0GB 存储空间</li><li><a href="https://huggingface.co/WarriorMama777/OrangeMixs">WarriorMama777&#x2F;OrangeMixs · Hugging Face</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/WarriorMama777/OrangeMixs/resolve/main/Models/AbyssOrangeMix3/AOM3A3.safetensors</span><br></pre></td></tr></table></figure><h3 id="NeverEnding-Dream"><a href="#NeverEnding-Dream" class="headerlink" title="NeverEnding Dream"></a>NeverEnding Dream</h3><ul><li>基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“好看的人像”及“有生成cosplay照片的能力”</li><li>至少需 4.0GB 存储空间</li><li><a href="https://civitai.com/models/10028/neverending-dream">NeverEnding Dream (NED) | Stable Diffusion Checkpoint | Civitai</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/11925</span><br></pre></td></tr></table></figure><h3 id="ChilloutMix"><a href="#ChilloutMix" class="headerlink" title="ChilloutMix"></a>ChilloutMix</h3><ul><li>基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“2.5D”、“人像”及“cosplay照片生成”</li><li>至少需 2.0GB 存储空间</li><li><a href="https://civitai.com/models/6424/chilloutmix">ChilloutMix | Stable Diffusion Checkpoint | Civitai</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/11732</span><br></pre></td></tr></table></figure><h3 id="momoko-e"><a href="#momoko-e" class="headerlink" title="momoko-e"></a>momoko-e</h3><ul><li>基于stable-diffusion网络结构，训练了<a href="https://www.pixiv.net/users/1113943">ももこ</a>画师的图片，该模型比较火的原因可能是手和脚的崩坏次数少一些（被一些人称为“有手修复包”，很可能是因为模型过拟合）</li><li>至少需 2.0GB 存储空间</li><li>链接来自其他人转存，有失效风险</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/LarryAIDraw/momoko-e/resolve/main/momoko-e.ckpt</span><br></pre></td></tr></table></figure><h3 id="Anything-v4-5"><a href="#Anything-v4-5" class="headerlink" title="Anything v4.5"></a>Anything v4.5</h3><ul><li>基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“全能（二次元男角色、二次元女角色、二次元风景）”和“更短的tag”</li><li>至少需 2.0GB 存储空间</li><li><a href="https://huggingface.co/andite/anything-v4.0">andite&#x2F;anything-v4.0 · Hugging Face</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/andite/anything-v4.0/resolve/main/anything-v4.5-pruned-fp16.ckpt</span><br></pre></td></tr></table></figure><h2 id="WebUI-插件"><a href="#WebUI-插件" class="headerlink" title="WebUI 插件"></a>WebUI 插件</h2><h3 id="a1111-sd-webui-tagcomplete"><a href="#a1111-sd-webui-tagcomplete" class="headerlink" title="a1111-sd-webui-tagcomplete"></a>a1111-sd-webui-tagcomplete</h3><ul><li>给WebUI增加Danbooru tag数据库和自动补全支持</li><li><a href="https://github.com/DominikDoom/a1111-sd-webui-tagcomplete">DominikDoom&#x2F;a1111-sd-webui-tagcomplete: Booru style tag autocompletion for AUTOMATIC1111’s Stable Diffusion web UI</a></li></ul><h3 id="sd-webui-supermerger"><a href="#sd-webui-supermerger" class="headerlink" title="sd-webui-supermerger"></a>sd-webui-supermerger</h3><ul><li>直接加权融合多个模型并进行使用，而不需要先合并网络参数制作模型文件</li><li><a href="https://github.com/hako-mikan/sd-webui-supermerger/">hako-mikan&#x2F;sd-webui-supermerger: model merge extention for stable diffusion web ui</a></li></ul><h3 id="sd-webui-controlnet"><a href="#sd-webui-controlnet" class="headerlink" title="sd-webui-controlnet"></a>sd-webui-controlnet</h3><ul><li>给WebUI增加ControlNet支持</li><li><strong>ControlNet必须搭配这个插件使用</strong></li><li><a href="https://github.com/Mikubill/sd-webui-controlnet">Mikubill&#x2F;sd-webui-controlnet: WebUI extension for ControlNet</a></li></ul><h3 id="openpose-editor"><a href="#openpose-editor" class="headerlink" title="openpose-editor"></a>openpose-editor</h3><ul><li>直接在WebUI里通过摆放骨骼的方式生成OpenPose图像</li><li><a href="https://github.com/fkunn1326/openpose-editor">Openpose Editor for AUTOMATIC1111’s stable-diffusion-webui</a></li></ul><h3 id="Auto-Photoshop-StableDiffusion-Plugin"><a href="#Auto-Photoshop-StableDiffusion-Plugin" class="headerlink" title="Auto-Photoshop-StableDiffusion-Plugin"></a>Auto-Photoshop-StableDiffusion-Plugin</h3><ul><li>Photoshop插件的后端</li><li><a href="https://github.com/AbdullahAlfaraj/Auto-Photoshop-StableDiffusion-Plugin">AbdullahAlfaraj&#x2F;Auto-Photoshop-StableDiffusion-Plugin: A user-friendly plug-in that makes it easy to generate stable diffusion images inside Photoshop using Automatic1111-sd-webui as a backend.</a></li></ul><h3 id="stable-diffusion-webui-localization-zh-CN"><a href="#stable-diffusion-webui-localization-zh-CN" class="headerlink" title="stable-diffusion-webui-localization-zh_CN"></a>stable-diffusion-webui-localization-zh_CN</h3><ul><li>WebUI的中文语言包</li><li><a href="https://github.com/dtlnor/stable-diffusion-webui-localization-zh_CN">dtlnor&#x2F;stable-diffusion-webui-localization-zh_CN: Simplified Chinese translation extension for AUTOMATIC1111‘s stable diffusion webui</a></li></ul><h3 id="sd-webui-additional-networks"><a href="#sd-webui-additional-networks" class="headerlink" title="sd-webui-additional-networks"></a>sd-webui-additional-networks</h3><ul><li>用于融合多个LoRA模型</li><li><strong>建议LoRA搭配这个插件使用</strong></li><li><a href="https://github.com/kohya-ss/sd-webui-additional-networks">kohya-ss&#x2F;sd-webui-additional-networks</a></li></ul><h3 id="deforum-for-automatic1111-webui"><a href="#deforum-for-automatic1111-webui" class="headerlink" title="deforum-for-automatic1111-webui"></a>deforum-for-automatic1111-webui</h3><ul><li>用于使用stable diffusion生成视频</li><li><a href="https://github.com/deforum-art/deforum-for-automatic1111-webui">deforum-art&#x2F;deforum-for-automatic1111-webui: Deforum extension script for AUTOMATIC1111’s Stable Diffusion webui</a></li></ul><h3 id="sd-webui-depth-lib"><a href="#sd-webui-depth-lib" class="headerlink" title="sd-webui-depth-lib"></a>sd-webui-depth-lib</h3><ul><li>预制的手部动作深度图，用于固定和修复手部动作</li><li><strong>有ControlNet后才能使用这个插件</strong></li><li><a href="https://github.com/jexom/sd-webui-depth-lib">jexom&#x2F;sd-webui-depth-lib: Depth map library for use with the Control Net extension for Automatic1111&#x2F;stable-diffusion-webui</a></li></ul><h2 id="Textual-Inversion模型"><a href="#Textual-Inversion模型" class="headerlink" title="Textual Inversion模型"></a>Textual Inversion模型</h2><ul><li>引入新的prompt，并将其与已有的prompt关联起来；</li><li>放置在WebUI的<code>embeddings</code>文件夹下；</li></ul><h3 id="EasyNegative"><a href="#EasyNegative" class="headerlink" title="EasyNegative"></a>EasyNegative</h3><ul><li>用于快速屏蔽负面tag</li><li>配合使用：AbyssOrangeMix3、Counterfeit-V2.5</li><li><a href="https://huggingface.co/datasets/gsdf/EasyNegative">gsdf&#x2F;EasyNegative · Datasets at Hugging Face</a></li><li>Prompt：<code>EASYNEGATIVE</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/datasets/gsdf/EasyNegative/resolve/main/EasyNegative.pt</span><br></pre></td></tr></table></figure><h3 id="Ulzzang-6500"><a href="#Ulzzang-6500" class="headerlink" title="Ulzzang-6500"></a>Ulzzang-6500</h3><ul><li>用于生成 韩国女明星式的 人像图片</li><li>配合使用：ChilloutMix</li><li><a href="https://civitai.com/models/8109">Ulzzang-6500 (Korean doll aesthetic) | Stable Diffusion TextualInversion | Civitai</a></li><li>Prompt：<code>ulzzang-6500-v1.1</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/10107</span><br></pre></td></tr></table></figure><h2 id="LoRA模型"><a href="#LoRA模型" class="headerlink" title="LoRA模型"></a>LoRA模型</h2><ul><li>LoRA用于训练差分模型。用户给出一系列具有相似特征（比如都是某个动漫角色、都是某个绘画风格、都是某个地区的人的脸型，……）的图片，经过训练生成一个几十&#x2F;几百MB的模型</li><li>载入绘画模型，再载入LoRA模型，使用LoRA的Prompt（或是插件），便可生成具有训练数据特征的图片</li><li>特点：速度快，模型小（类似的Dreambooth技术会生成完整模型），准确度高（对“风格”来说更优秀，但对“脸型”来说不如Dreambooth），可组合</li><li>推荐配合<code>sd-webui-additional-networks</code>插件使用<ul><li>使用插件：LoRA模型放到<code>extensions/sd-webui-additional-networks/models/lora</code>下</li><li>不使用插件：LoRA模型放到<code>models/Lora</code>下</li></ul></li></ul><h3 id="doll-likeness"><a href="#doll-likeness" class="headerlink" title="*-doll-likeness"></a>*-doll-likeness</h3><ul><li>配合ChilloutMix绘画模型，生成具有特定地域脸型的人像图片（“伪Cosplay照片”）</li><li>原作者已删除模型，链接来自他人转存，有失效风险</li><li>Prompt：<code>woman, girl</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日本模特脸型</span></span><br><span class="line">wget https://huggingface.co/AnonPerson/ChilloutMix/resolve/main/Japanese-doll-likeness.safetensors</span><br><span class="line"><span class="comment"># 韩国模特脸型</span></span><br><span class="line">wget https://huggingface.co/AnonPerson/ChilloutMix/resolve/main/Korean-doll-likeness.safetensors</span><br><span class="line"><span class="comment"># 中国台湾模特脸型</span></span><br><span class="line">wget https://huggingface.co/AnonPerson/ChilloutMix/resolve/main/Taiwan-doll-likeness.safetensors</span><br></pre></td></tr></table></figure><h3 id="chinese-doll-likeness"><a href="#chinese-doll-likeness" class="headerlink" title="chinese-doll-likeness"></a>chinese-doll-likeness</h3><ul><li>配合ChilloutMix绘画模型，生成具有中国人脸型的人像图片（“伪Cosplay照片”）</li><li><a href="https://civitai.com/models/9434/lora-chinese-doll-likeness">[LORA] Chinese Doll Likeness | Stable Diffusion LORA | Civitai</a></li><li>Prompt：<code>chinese doll</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/11195</span><br></pre></td></tr></table></figure><h3 id="Pastel-Mix"><a href="#Pastel-Mix" class="headerlink" title="Pastel-Mix"></a>Pastel-Mix</h3><ul><li>使图像变为粉彩风格</li><li><a href="https://civitai.com/models/5414/pastel-mix-stylized-anime-model">Pastel-Mix [Stylized Anime Model] | Stable Diffusion Checkpoint | Civitai</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/7397</span><br></pre></td></tr></table></figure><h3 id="Glorious-Azur-Lane-Spring-光荣-凉夜春雪"><a href="#Glorious-Azur-Lane-Spring-光荣-凉夜春雪" class="headerlink" title="Glorious (Azur Lane) Spring 光荣 凉夜春雪"></a>Glorious (Azur Lane) Spring 光荣 凉夜春雪</h3><ul><li>画特定人物（碧蓝航线 光荣 凉夜春雪皮肤），同时少量使用可能可以改善画面细节</li><li><a href="https://civitai.com/models/7537/glorious-azur-lane-spring">Glorious (Azur Lane) Spring 光荣 凉夜春雪 | Stable Diffusion LORA | Civitai</a></li><li>Prompt：<code>blonde hair, cleavage, bare shoulders</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/8855</span><br></pre></td></tr></table></figure><h3 id="Gacha-splash-LORA"><a href="#Gacha-splash-LORA" class="headerlink" title="Gacha splash LORA"></a>Gacha splash LORA</h3><ul><li>使输出的图像更像游戏角色立绘；分为4个不同版本</li><li><a href="https://civitai.com/models/13090/gacha-splash-lora">Gacha splash LORA | Stable Diffusion LORA | Civitai</a></li><li>Prompt：<code>[(white background:1.5)::5], (bottle bottom:0.9), 1 girl, mid shot, full body</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># far shot</span></span><br><span class="line">wget https://civitai.com/api/download/models/20012</span><br><span class="line"><span class="comment"># wide shot</span></span><br><span class="line">wget https://civitai.com/api/download/models/20008</span><br><span class="line"><span class="comment"># mid shot</span></span><br><span class="line">wget https://civitai.com/api/download/models/20009</span><br><span class="line"><span class="comment"># fantasy 2.0</span></span><br><span class="line">wget https://civitai.com/api/download/models/20010</span><br></pre></td></tr></table></figure><h3 id="Anime-Lineart-线稿-x2F-線画-Style"><a href="#Anime-Lineart-线稿-x2F-線画-Style" class="headerlink" title="Anime Lineart (线稿&#x2F;線画) Style"></a>Anime Lineart (线稿&#x2F;線画) Style</h3><ul><li>使Stable Diffusion直接画出图片线稿，而不是填色的图片</li><li><a href="https://civitai.com/models/16014">Anime Lineart (线稿&#x2F;線画) Style | Stable Diffusion LORA | Civitai</a></li><li>Prompt：<code>monochrome, lineart</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/19075</span><br></pre></td></tr></table></figure><h2 id="工具模型"><a href="#工具模型" class="headerlink" title="工具模型"></a>工具模型</h2><ul><li>与绘画不直接相关，主要用于图片后处理、图片内容识别，以及图片放大</li></ul><h3 id="变分自编码器（VAE）"><a href="#变分自编码器（VAE）" class="headerlink" title="变分自编码器（VAE）"></a>变分自编码器（VAE）</h3><ul><li>改变生成结果的概率分布，表现为图片的对比度、饱和度等</li><li>部分模型内置VAE，看到<code>_bakedVAE</code>字样可忽略</li><li>最常用的VAE：NovelAI的VAE，下载：<ul><li>通过磁力链接，见上述NovelAI模型章节：<code>stableckpt/animevae.pt</code></li><li>Huggingface上其他项目的转存</li></ul></li><li>放置在WebUI的<code>models/VAE</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/WarriorMama777/OrangeMixs/resolve/main/VAEs/orangemix.vae.pt</span><br></pre></td></tr></table></figure><h3 id="Deepbooru"><a href="#Deepbooru" class="headerlink" title="Deepbooru"></a>Deepbooru</h3><ul><li>用于识别给出的图片，将图片内容转化为Danbooru的tag</li><li><a href="https://github.com/AUTOMATIC1111/TorchDeepDanbooru">AUTOMATIC1111&#x2F;TorchDeepDanbooru: Pure pytorch implementation of DeepDanbooru</a></li><li>放置在WebUI的<code>models/torch_deepdanbooru</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/AUTOMATIC1111/TorchDeepDanbooru/releases/download/v1/model-resnet_custom_v3.pt</span><br></pre></td></tr></table></figure><h3 id="RealESRGAN（R-ESRGAN4x）"><a href="#RealESRGAN（R-ESRGAN4x）" class="headerlink" title="RealESRGAN（R-ESRGAN4x）"></a>RealESRGAN（R-ESRGAN4x）</h3><ul><li>通用图片放大器，4倍时最佳</li><li><a href="https://github.com/xinntao/Real-ESRGAN">xinntao&#x2F;Real-ESRGAN: Real-ESRGAN aims at developing Practical Algorithms for General Image&#x2F;Video Restoration.</a></li><li>放置在WebUI的<code>models/RealESRGAN</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.1/RealESRNet_x4plus.pth</span><br></pre></td></tr></table></figure><h3 id="RealESRGAN-Anime6B（R-ESRGAN4x-Anime6B）"><a href="#RealESRGAN-Anime6B（R-ESRGAN4x-Anime6B）" class="headerlink" title="RealESRGAN+Anime6B（R-ESRGAN4x + Anime6B）"></a>RealESRGAN+Anime6B（R-ESRGAN4x + Anime6B）</h3><ul><li>专为二次元图片训练的图片放大器，边缘更锐利、速度更快</li><li><a href="https://github.com/xinntao/Real-ESRGAN">xinntao&#x2F;Real-ESRGAN: Real-ESRGAN aims at developing Practical Algorithms for General Image&#x2F;Video Restoration.</a></li><li>放置在WebUI的<code>models/RealESRGAN</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/xinntao/Real-ESRGAN/releases/download/v0.2.2.4/RealESRGAN_x4plus_anime_6B.pth</span><br></pre></td></tr></table></figure><h3 id="GFPGAN、CodeFormer"><a href="#GFPGAN、CodeFormer" class="headerlink" title="GFPGAN、CodeFormer"></a>GFPGAN、CodeFormer</h3><ul><li>用于<strong>真实人脸</strong>的放大和重建</li><li><a href="https://github.com/TencentARC/GFPGAN">TencentARC&#x2F;GFPGAN: GFPGAN aims at developing Practical Algorithms for Real-world Face Restoration.</a></li><li><a href="https://github.com/xinntao/facexlib">xinntao&#x2F;facexlib: FaceXlib aims at providing ready-to-use face-related functions based on current STOA open-source methods.</a></li><li>放置在WebUI的<code>models/GFPGAN</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/TencentARC/GFPGAN/releases/download/v1.3.4/GFPGANv1.4.pth</span><br><span class="line">wget https://github.com/xinntao/facexlib/releases/download/v0.1.0/detection_Resnet50_Final.pth</span><br><span class="line">wget https://github.com/xinntao/facexlib/releases/download/v0.2.2/parsing_parsenet.pth</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/sczhou/CodeFormer">sczhou&#x2F;CodeFormer: [NeurIPS 2022] Towards Robust Blind Face Restoration with Codebook Lookup Transformer</a></li><li>放置在WebUI的<code>models/CodeFormer</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/sczhou/CodeFormer/releases/download/v0.1.0/codeformer.pth</span><br></pre></td></tr></table></figure><h3 id="ControlNet"><a href="#ControlNet" class="headerlink" title="ControlNet"></a>ControlNet</h3><ul><li>用于部分控制Diffusion网络的参数，例如<ul><li>固定生成图片的人物动作（OpenPose）</li><li>通过精细线稿生成图片（Canny）</li><li>通过简笔画生成图片（Scribble）</li><li>通过景深生成图片（Depth）</li><li>…</li></ul></li><li><a href="https://github.com/lllyasviel/ControlNet">lllyasviel&#x2F;ControlNet: Let us control diffusion models!</a></li><li>需要配合插件<code>sd-webui-controlnet</code>使用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ControlNet差分模型，放置在WebUI的extensions/sd-webui-controlnet/models文件夹下</span></span><br><span class="line"><span class="comment"># Canny</span></span><br><span class="line">wget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_canny-fp16.safetensors</span><br><span class="line"><span class="comment"># OpenPose</span></span><br><span class="line">wget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_openpose-fp16.safetensors</span><br><span class="line"><span class="comment"># Scribble</span></span><br><span class="line">wget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_scribble-fp16.safetensors</span><br><span class="line"><span class="comment"># Depth</span></span><br><span class="line">wget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_depth-fp16.safetensors</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenPose需要独立的数据模型，放置在WebUI的models/openpose文件夹下</span></span><br><span class="line">wget https://huggingface.co/lllyasviel/ControlNet/resolve/main/annotator/ckpts/body_pose_model.pth</span><br><span class="line">wget https://huggingface.co/lllyasviel/ControlNet/resolve/main/annotator/ckpts/hand_pose_model.pth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="AI绘画" scheme="http://wiki.zhouweitong.site/categories/AI%E7%BB%98%E7%94%BB/"/>
    
    
    <category term="速查表" scheme="http://wiki.zhouweitong.site/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    
    <category term="Stable Diffusion" scheme="http://wiki.zhouweitong.site/tags/Stable-Diffusion/"/>
    
    <category term="Novel AI" scheme="http://wiki.zhouweitong.site/tags/Novel-AI/"/>
    
    <category term="模型与插件" scheme="http://wiki.zhouweitong.site/tags/%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>静态库与动态链接库</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/Windows/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/Windows/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</id>
    <published>2023-03-09T07:00:00.000Z</published>
    <updated>2023-03-09T07:45:02.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>静态库一般是<code>.lib</code>格式，而动态链接库一般是<code>.dll</code>格式<ul><li>静态库 只能 静态链接，此时静态库的内容将被完全嵌入到程序文件中</li><li>动态链接库可以静态链接，此时程序<strong>在启动时</strong>就需要依赖和加载对应的<code>.dll</code>文件（没有dll程序打不开）</li><li>动态链接库可以动态链接，此时程序<strong>在执行导入函数后</strong>才需要依赖和加载对应的<code>.dll</code>文件（没有dll程序也能打开但功能受限）</li></ul></li></ul><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><ul><li>设置编译后的程序格式：需要在项目设置里将“配置类型”改为“静态库(.lib)”<ul><li>即对应的vcxproj文件内容：</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(Configuration)|$(Platform)&#x27;==&#x27;Debug|x64&#x27;&quot;</span> <span class="attr">Label</span>=<span class="string">&quot;Configuration&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ConfigurationType</span>&gt;</span>StaticLibrary<span class="tag">&lt;/<span class="name">ConfigurationType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义函数和类时无需任何额外的操作<ul><li>实际上就是在写“库”，与在主程序同文件夹下新建<code>xxx.h</code>和<code>xxx.cc</code>并无使用上的区别</li><li>优势：使代码可以跨项目复用</li></ul></li><li>以定义一个类为例，静态库内的代码形式如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序和库共用的头文件，include/example.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IExample</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IExample</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IExample</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">get_B</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库的头文件，static_lib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现为类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span>: <span class="keyword">public</span> IExample</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_iA;</span><br><span class="line">    std::string m_szB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ExampleClass</span>(<span class="type">int</span> in_iA, std::string in_szB): <span class="built_in">m_iA</span>(in_iA), <span class="built_in">m_szB</span>(in_szB) &#123; &#125;;</span><br><span class="line">    ~<span class="built_in">ExampleClass</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_A</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">get_B</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库内函数</span></span><br><span class="line"><span class="function">IExample* <span class="title">createObject</span><span class="params">(<span class="type">int</span> in_iA, std::string in_szB)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库的代码，static_lib.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExampleClass::get_A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_iA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ExampleClass::get_B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_szB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数示例：创建一个对象并返回其指针；对象放在堆上，手动管理其作用域</span></span><br><span class="line"><span class="function">IExample* <span class="title">createObject</span><span class="params">(<span class="type">int</span> in_iA, std::string in_szB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ExampleClass *newObj = <span class="keyword">new</span> <span class="built_in">ExampleClass</span>(in_iA, in_szB);</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量示例</span></span><br><span class="line"><span class="type">int</span> TestC = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="使用静态库的主程序"><a href="#使用静态库的主程序" class="headerlink" title="使用静态库的主程序"></a>使用静态库的主程序</h2><ul><li>需要在链接时指定链接库文件<ul><li>使用<code>#pragma</code>：<code>#pragma comment(lib, &quot;static_lib.lib&quot;)</code></li><li>编辑项目设置并在其中添加文件：项目设置 -&gt; 配置属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 -&gt; 编辑 -&gt; （添加链接库的文件位置）<ul><li>即对应的vcxproj文件内容：</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AdditionalDependencies</span>&gt;</span>static_lib.lib;%(AdditionalDependencies)<span class="tag">&lt;/<span class="name">AdditionalDependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>需要在主程序中使用<code>extern</code>关键字声明静态库中的函数&#x2F;全局变量</li><li>随后调用该函数&#x2F;变量即可</li><li>主程序的代码示例如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入IExample的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/example.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入库中的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> TestC;</span><br><span class="line"><span class="comment">// 引入库内的函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> IExample* <span class="title">createObject</span><span class="params">(<span class="type">int</span> in_iA, std::string in_szB)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数内就能使用类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; TestC &lt;&lt; std::endl;</span><br><span class="line">  IExample *TestD = <span class="built_in">createObject</span>(<span class="number">100</span>, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码同样演示了一种 主程序和库共享接口定义时传递对象的方法：<ul><li>主程序和库同时有接口的定义</li><li>库内将接口实现为类，可对类进行各种操作，并定义一个初始化函数：在堆上实例化子类，并返回接口的指针类型</li><li>主程序调用初始化函数，得到指针，根据接口的定义进行各种操作</li></ul></li><li>示例如下：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口定义IExample -&gt; 静态库引入 -&gt; 实例化为CExample（可以添加新成员变量和成员方法） -&gt; 定义createObject，返回IExample*；</span><br><span class="line">接口定义IExample -&gt; 主程序引入 -&gt; 设置使用静态库 -&gt; 引入createObject -&gt; 获得IExample*类型变量（CExample中新加的成员变量和成员方法不可用）；</span><br></pre></td></tr></table></figure><h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="Windows" scheme="http://wiki.zhouweitong.site/categories/C/Windows/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
    <category term="Windows" scheme="http://wiki.zhouweitong.site/tags/Windows/"/>
    
    <category term="动态链接库" scheme="http://wiki.zhouweitong.site/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
    <category term="静态库" scheme="http://wiki.zhouweitong.site/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>GCC与G++</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/GCC%E4%B8%8EGPlusPlus/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/GCC%E4%B8%8EGPlusPlus/</id>
    <published>2023-03-07T12:00:00.000Z</published>
    <updated>2023-03-07T14:00:41.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一些GCC&#x2F;G++强相关的技巧笔记；</p><h2 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>只有g++才有这个文件</li><li>相当于把STL所有头文件都include一次，可看代码：<ul><li><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/precompiled/stdc%2B%2B.h">gcc&#x2F;stdc++.h at master · gcc-mirror&#x2F;gcc · GitHub</a></li></ul></li></ul><h2 id="start"><a href="#start" class="headerlink" title="_start()"></a>_start()</h2><p>在GCC中，程序的实际入口点是<code>__start()</code>函数，而其中又会调用<code>__libc_start_main()</code>，再在其中调用<code>main()</code>；</p><p>因此，下面的代码也可以作为独立程序成功编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _start()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">5</span>;</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objdump</code>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;_start&gt;:</span><br><span class="line">   0: 55                    push   %rbp</span><br><span class="line">   1: 48 89 e5              mov    %rsp,%rbp</span><br><span class="line">   4: c7 45 fc 00 00 00 00  movl   $0x0,-0x4(%rbp)</span><br><span class="line">   b: c7 45 f8 05 00 00 00  movl   $0x5,-0x8(%rbp)</span><br><span class="line">  12: 8b 45 f8              mov    -0x8(%rbp),%eax</span><br><span class="line">  15: 83 c0 01              add    $0x1,%eax</span><br><span class="line">  18: 89 45 fc              mov    %eax,-0x4(%rbp)</span><br><span class="line">  1b: 90                    nop</span><br><span class="line">  1c: 5d                    pop    %rbp</span><br><span class="line">  1d: c3                    ret    </span><br></pre></td></tr></table></figure><p>可以通过自定义<code>__start()</code>函数实现更复杂的程序启动流程；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
    <category term="GCC" scheme="http://wiki.zhouweitong.site/tags/GCC/"/>
    
    <category term="G++" scheme="http://wiki.zhouweitong.site/tags/G/"/>
    
  </entry>
  
  <entry>
    <title>匈牙利命名法</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/Windows/%E5%8C%88%E7%89%99%E5%88%A9%E5%91%BD%E5%90%8D%E6%B3%95/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/Windows/%E5%8C%88%E7%89%99%E5%88%A9%E5%91%BD%E5%90%8D%E6%B3%95/</id>
    <published>2023-03-07T08:00:00.000Z</published>
    <updated>2023-03-07T12:09:07.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>匈牙利命名法是Windows程序开发时经常用到&#x2F;见到的变量&#x2F;类型命名方法。</p><p>例如：下面是<code>winsock2.h</code>中的一个函数的文档：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT WSAAPI <span class="title">WSAAddressToStringW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPSOCKADDR          lpsaAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD               dwAddressLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPWSAPROTOCOL_INFOW lpProtocolInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out]      LPWSTR              lpszAddressString,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out]      LPDWORD             lpdwAddressStringLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>显然，变量名（类型名）具有某中规律，但：lpsz是什么？LPWSTR又是什么类型？DWORD和LPDWORD有什么区别？可以通过学习匈牙利命名法快速解决这些问题；</p><ul><li>匈牙利命名法分为“匈牙利应用命名法”和“系统匈牙利命名法”两种，可同时使用；</li><li>由 其他前缀（前前缀） + 匈牙利命名法前缀 + 实际变量&#x2F;类名 组成；</li><li>大小写规则（不是必须的）：<ul><li>类（数据类型）的匈牙利命名法前缀大写，类名大写；也即：全部大写；例如：<code>LPWSTR</code>；</li><li>变量（对象）的匈牙利命名法前缀小写，变量名只有首字母大写；例如：<code>lpwStr</code>；</li></ul></li><li>不同程序项目中的前缀的含义不一定相同，但同一个项目中的前缀含义一定相同<ul><li>即：弄懂一个前缀的意思，就能快速了解其他变量或类的类型&#x2F;特征</li></ul></li></ul><h2 id="系统匈牙利命名法"><a href="#系统匈牙利命名法" class="headerlink" title="系统匈牙利命名法"></a>系统匈牙利命名法</h2><ul><li>匈牙利命名法的前缀 标识的是<strong>数据类型</strong></li><li>基础类型<ul><li><code>i</code>：<code>int</code>，整型</li><li><code>u</code>：<code>unsigned</code>，无符号的</li><li><code>b</code>：<code>bool</code>，布尔型</li><li><code>l</code>：<code>long</code>，长的</li><li><code>v</code>：<code>void</code>，空类型</li><li><code>n</code>：number，即<code>short</code>，短整型</li><li><code>f</code>、<code>fp</code>：<code>float</code>，单精度浮点数</li><li><code>d</code>、<code>db</code>：<code>double</code>，双精度浮点数</li><li><code>c</code>、<code>ch</code>：<code>char</code>，字符型</li><li><code>uc</code>、<code>cb</code>（char byte）：无符号字符型</li><li><code>p</code>：<code>pointer</code>，指针</li><li><code>np</code>：<code>near pointer</code>，近程指针</li><li><code>fn</code>：<code>function</code>，函数</li><li><code>fs</code>：<code>file stream</code>，文件流</li><li><code>k</code>：<code>const</code>，常量</li><li><code>e</code>：<code>enum</code>，枚举类型</li><li>……</li></ul></li><li>有时可以在类型后加数字，代表类型的位数，如：16位无符号整形<code>ui16</code></li><li>其他类型<ul><li><code>s</code>：<code>string</code>，字符串</li><li><code>sz</code>：<code>string (with) zero (endings)</code>，以<code>\0</code>结尾的字符串</li><li><code>a</code>、<code>rg</code>：range，即<code>array</code>，数组</li><li><code>by</code>：<code>byte</code>，字节</li><li><code>w</code>：<code>word</code>，字</li><li><code>dw</code>：<code>double word</code>，双字</li><li><code>qw</code>：<code>quarter word</code>，四字</li><li><code>S</code>：<code>struct</code>，结构体</li><li><code>C</code>：<code>Class</code>，类</li><li><code>I</code>：<code>Interface</code>，接口</li><li><code>X</code>：<code>Nested Class</code>，嵌套的类</li><li><code>x</code>：<code>Instance of nested class</code>，嵌套的类的实例</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CRocket：类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CRocket</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// XMotion：类中的类（嵌套的类），IMotion：接口</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">XMotion</span>: <span class="keyword">public</span> IMotion &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">   &#125; m_xUnknown; <span class="comment">// m_xUnknown：嵌套的类XMotion的一个实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Windows API中能够见到许多独特的前缀<ul><li><code>h</code>：<code>handle</code>，句柄</li><li><code>sa</code>：<code>Socket Address</code>，Socket地址</li><li>……</li></ul></li><li>常见的前前缀<ul><li><code>g_</code>：<code>global</code>，全局变量</li><li><code>m_</code>：<code>member</code>，类的成员变量</li><li><code>s_</code>：<code>static</code>，静态变量</li><li>……</li></ul></li></ul><h2 id="匈牙利应用命名法"><a href="#匈牙利应用命名法" class="headerlink" title="匈牙利应用命名法"></a>匈牙利应用命名法</h2><ul><li>匈牙利命名法的前缀 标识的是<strong>变量特征或用处</strong></li><li>一些前缀的例子<ul><li><code>ct</code>：<code>counter</code>，计数器</li><li><code>cb</code>：<code>count (of) bytes</code>，字节数</li><li><code>i</code>：<code>index</code>，下标</li><li><code>w</code>：<code>wide</code>，宽字符</li><li><code>row</code>：<code>row</code>，行号</li><li><code>col</code>：<code>column</code>，列号</li><li><code>d</code>：<code>distance</code>，距离</li><li><code>us</code>：<code>unsafe string</code>，不安全的字符串</li><li>……</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="Windows" scheme="http://wiki.zhouweitong.site/categories/C/Windows/"/>
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="Windows" scheme="http://wiki.zhouweitong.site/tags/Windows/"/>
    
    <category term="匈牙利命名法" scheme="http://wiki.zhouweitong.site/tags/%E5%8C%88%E7%89%99%E5%88%A9%E5%91%BD%E5%90%8D%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>宏函数</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%AE%8F%E5%87%BD%E6%95%B0/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%AE%8F%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-07T05:00:00.000Z</published>
    <updated>2023-03-09T08:06:05.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>宏函数类似于函数，包含函数名、参数和实现，与函数定义差别不大（没有返回值和大括号）<ul><li>可视情况决定函数结尾是否添加分号</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个宏函数，实现三数相加</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM(a, b, c) a + b + c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个函数</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">SUM</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>) + <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">1</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li>也可以将宏函数的参数作为函数名或类名使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGPARAM(func, string) func(string)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">STRINGPARAM</span>(std::printf, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::<span class="built_in">printf</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>甚至可以将宏函数的参数作为宏名使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECTOR(type, name) std::vector<span class="string">&lt;type&gt;</span> name</span></span><br><span class="line"><span class="comment">// 再定义一个宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATACONTAINER(container_type) container_type(int, A); container_type(std::string, B);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DATACONTAINER</span>(VECTOR)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; A; std::vector&lt;std::string&gt; B;</span><br></pre></td></tr></table></figure><ul><li>是的，宏函数也可以接受数量可变的参数：只需要配合使用<code>...</code>和<code>__VA_ARGS__</code>即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT(...) std::printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">OUTPUT</span>(<span class="string">&quot;%d: %d&quot;</span>, num1, num2);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::<span class="built_in">printf</span>(<span class="string">&quot;%d: %d&quot;</span>, num1, num2);</span><br></pre></td></tr></table></figure><ul><li>可变参数可以放在固定参数后面</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWARRAY(type, size, name, ...) std::array<span class="string">&lt;type, size&gt;</span> name = &#123; __VA_ARGS__ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NEWARRAY</span>(<span class="type">int</span>, <span class="number">10</span>, data, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 10&gt; data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>特殊符号：<code>#</code>，字符串化<ul><li><code>#abc</code>会被翻译为<code>&quot;abc&quot;</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT(var) std::cout &lt;&lt; #var &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">OUTPUT</span>(k);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;k&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; k &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>特殊符号：<code>##</code>，token粘贴（标记粘贴）<ul><li><code>A##B</code>会被转换为<code>AB</code>，此后<code>AB</code>可以作为其他宏名&#x2F;变量名等进行替换</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAYS(type, size, name) std::array<span class="string">&lt;type, size&gt;</span> name##_dbg, name##_rel</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ARRAYS</span>(<span class="type">int</span>, <span class="number">10</span>, data);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 10&gt; data_dbg, data_rel;</span><br></pre></td></tr></table></figure><ul><li><code>__VA_ARGS__</code>也支持特殊符号，即<code>#__VA_ARGS__</code>和<code>##__VA_ARGS__</code></li><li>宏与其定义顺序无关；但为保证可读性，还是建议位于文件上方的宏不要依赖文件下方的宏</li><li>宏函数无需写到一行内，复杂的宏可以通过<code>\</code>分割为多行<ul><li>注意：<code>\</code>必须是行内的<strong>最后一个字符</strong>，即使是后面多了一个空格也不行</li><li>注意：给多行的宏函数内添加注释<strong>只能使用</strong><code>/* */</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_REGULATORY(a, b, res) \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Threshold is 100 */</span> \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (a &gt; 100 || b &gt; 100 || a &lt; 0 || b &lt; 0) \</span></span><br><span class="line"><span class="meta">        res = false; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        res = true;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="基础语法" scheme="http://wiki.zhouweitong.site/categories/C/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="宏" scheme="http://wiki.zhouweitong.site/tags/%E5%AE%8F/"/>
    
    <category term="宏函数" scheme="http://wiki.zhouweitong.site/tags/%E5%AE%8F%E5%87%BD%E6%95%B0/"/>
    
    <category term="Macro" scheme="http://wiki.zhouweitong.site/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>array、vector、tuple</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/STL/array%E3%80%81vector%E3%80%81tuple/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/STL/array%E3%80%81vector%E3%80%81tuple/</id>
    <published>2023-03-06T13:00:00.000Z</published>
    <updated>2023-03-07T03:39:34.330Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><code>array</code>：更高级一些的“数组”；固定长度，类型必须一致；</li><li><code>vector</code>：“向量”；可变长度，类型必须一致；</li><li><code>tuple</code>：“元组”；固定长度，类型可以不一致；</li></ul><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><ul><li>特点：<ul><li>支持随机访问，适合线性搜索；</li><li>必须是在编译时确定的大小；</li><li>不支持扩容；</li><li>如果元素的初始化、移动等开销巨大，则会严重影响性能；</li><li>值存放在栈上；</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>定义数组时也可以直接初始化；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 10&gt; arr_int = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>也可以定义二维数组：直接嵌套即可；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;std::array&lt;<span class="type">int</span>, 10&gt;, 10&gt; a;</span><br></pre></td></tr></table></figure><ul><li><code>std::array</code>重载了<code>[]</code>，所以可以像传统数组一样对数组里的某个元素进行赋值；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr_int[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于（看下文）</span></span><br><span class="line">arr_int.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">2</span>;</span><br><span class="line">(a.<span class="built_in">at</span>(<span class="number">0</span>)).<span class="built_in">at</span>(<span class="number">1</span>) = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>成员方法：<ul><li>快速访问：操作符<code>[]</code></li><li>迭代器：除<code>[]</code>外另一种访问元素的方法<ul><li>只要有迭代器的容器都有（或都应该实现）的方法：返回头迭代器的方法<code>x.begin()</code>，返回<strong>尾后</strong>迭代器的方法<code>x.end()</code><ul><li>为什么叫尾后迭代器：实际上指向的是最后一个元素后面的空位</li><li>返回的实际上是<code>std::array&lt;T&gt;::iterator</code>类型，习惯上用auto自动推导类型</li></ul></li><li>迭代器支持的操作：<ul><li>解引用：<code>*</code>，访问迭代器对应的元素，例如<code>*i</code></li><li>比较：<code>&lt; &lt;= &gt; &gt;= == !=</code>，对迭代器的比较是对位置进行比较</li><li>自增自减：<code>++ --</code>，包括前置<code>++i</code>和后置<code>i++</code></li><li>数字加减：<code>+ x</code>，”前移x位“；<code>- x</code>：”后移x位“</li><li>数字加减复合赋值：<code>+= -=</code></li><li>迭代器作差：<code>iter_1 - iter_2</code>：得到两个迭代器的距离<ul><li><strong>距离的数据类型</strong>：<code>std::array&lt;T&gt;::difference_type</code></li></ul></li></ul></li><li>常量（const）的begin和end：<code>cbegin()</code>是常量形式的<code>begin()</code>，<code>cend()</code>是常量形式的<code>end()</code><ul><li>可以使用常量迭代器<strong>禁止通过迭代器修改元素</strong></li><li>常量迭代器的数据类型：<code>std::array&lt;T&gt;::const_iterator</code></li></ul></li><li>反转（reversed）的<code>begin()</code>和<code>end()</code>：<code>rbegin()</code>指向尾元素，<code>rend()</code>指向头元素的前一个元素</li><li>反转常量（const reversed）的begin和end：<code>crbegin()</code>，<code>crend()</code></li><li>注意：只要对元素（包括长度）进行了修改，迭代器即刻失效；</li></ul></li><li>位于：<code>at()</code></li><li>已有元素个数：<code>size()</code></li><li>容量：<code>max_size()</code></li><li>判空：<code>empty()</code></li><li>头尾元素：<code>front()</code>，<code>back()</code></li><li>与另一个同长度同类型的数组交换元素：<code>xxx.swap(yyy)</code></li><li>访问底层的C式数组：<code>data()</code></li><li>运算符：各种比较，<code>== != &lt; &lt;= &gt; &gt;= &lt;=&gt;</code></li></ul></li></ul><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul><li>特点：<ul><li>存储同一种类型的数据；</li><li>可动态扩容；</li><li>数据存储在<strong>堆上</strong></li></ul></li><li>是C++的“默认容器（Default Container）”<ul><li>能够最好地展现STL中“容器”的特征（体现STL中“容器”的设计思想）；</li><li>许多其他STL模板支持甚至使用vector；</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; test&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>两种初始化：<ul><li>构造函数（Constructor）初始化，<code>std::vector&lt;int&gt; a(2, 5);</code></li><li>初始化列表（Initializer List）初始化，<code>std::vector&lt;int&gt; a&#123;2, 5&#125;;</code></li><li>区别与联系：只会发生在参数个数为2的情况下：<ul><li>初始化列表：把大括号内的每一个int当作元素，a实际上为<code>(2, 5)</code></li><li>构造函数初始化：由于重载顺序的问题，会匹配到如下的构造函数：2是重复次数，5是要被重复的元素，a实际上是<code>(5, 5)</code></li><li>其他容器也会存在类似的问题，为避免二义性尽量只在元素重复非常多次的情况下使用构造函数初始化</li></ul></li></ul></li><li>插入和删除：分为两种方式<ul><li>尾部插入和删除（性能较好）：<code>v.push_back(xxx)</code>和<code>v.pop_back()</code></li><li>任意位置插入和删除（需要移动元素，性能较差）：<code>v.insert(pos, xxx)</code>和<code>v.erase(pos)</code><ul><li>pos的类型必须是v的迭代器；</li><li>insert和erase也可以对区间进行操作;</li><li>insert和erase方法的返回值是新的迭代器；</li></ul></li><li>清空所有元素：<code>v.clear()</code><ul><li>注意：删除或清空元素不会回收已分配的空间</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设此时有两个vector</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; b&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置删除</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个（自己的）迭代器区间，删除这段区间内的元素</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个（其他变量的）迭代器区间，将其他变量的某个区间内的元素插入到当前变量中</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li>安放元素：<ul><li>emplace与insert&#x2F;push的区别：在进行“初始化一个对象，再进行插入”的操作时，insert&#x2F;push需要借助中间变量（临时变量），而emplace不需要</li><li><code>v.emplace_back(args...)</code>：在最后安放</li><li><code>v.emplace(pos, args...)</code>：在指定位置安放</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> Id;</span><br><span class="line">  std::string Name;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> input_id, std::string input_name): <span class="built_in">Id</span>(input_id), <span class="built_in">Name</span>(input_name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以这个类为数据类型定义vector</span></span><br><span class="line">std::vector&lt;A&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_back：使用了临时变量</span></span><br><span class="line">data.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">10</span>, <span class="string">&quot;Test1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// emplace_back：不使用临时变量</span></span><br><span class="line">data.<span class="built_in">emplace_back</span>(<span class="number">11</span>, <span class="string">&quot;Test2&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>空间处理：分为查询、扩展和收缩三种操作<ul><li><code>v.size()</code>：查询现有元素个数</li><li><code>v.capacity()</code>：查询无需扩容时能容纳的最大元素数（一般是2的倍数）</li><li><code>v.resize(x, y)</code>：在原vector的最后用y填充，直至v的元素个数为x</li><li><code>v.reserve(x)</code>：将v的内存预分配至x个元素大小</li></ul></li></ul><p>( TODO )</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="STL" scheme="http://wiki.zhouweitong.site/categories/C/STL/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="STL" scheme="http://wiki.zhouweitong.site/tags/STL/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
    <category term="array" scheme="http://wiki.zhouweitong.site/tags/array/"/>
    
    <category term="vector" scheme="http://wiki.zhouweitong.site/tags/vector/"/>
    
    <category term="tuple" scheme="http://wiki.zhouweitong.site/tags/tuple/"/>
    
  </entry>
  
  <entry>
    <title>any、variant</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/STL/any%E3%80%81variant/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/STL/any%E3%80%81variant/</id>
    <published>2023-03-01T10:00:00.000Z</published>
    <updated>2023-03-01T15:21:10.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><ul><li>any的作用：定义一个“能够保存任何类型数据”的变量<ul><li>类似Python中的：<code>a = 10, a = &quot;Hello&quot;</code></li><li>类似于弱类型语言中的变量，但不完全一样</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>可以直接赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::any test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储数据就可以直接赋值</span></span><br><span class="line">test = <span class="number">1</span>;</span><br><span class="line">test = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">test = <span class="number">2.3</span>;</span><br></pre></td></tr></table></figure><ul><li>但是不能直接取值<ul><li><code>std::any</code>：使用<code>std::any_cast&lt;Type&gt;(var)</code>来判断和转换类型<ul><li>Type不是当前var的实际类型，会抛出<code>std::bad_any_cast</code>异常</li><li>也可以使用指针和if，判断返回值是否为nullptr</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最好使用try-catch，像下面这样</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于Python的 except XXExpection as e</span></span><br><span class="line"><span class="built_in">catch</span> (std::bad_any_cast&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not integer.&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>* tmp2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 因为是指针，所以也要对变量取地址</span></span><br><span class="line">tmp2 = std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(&amp;test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not double.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; *tmp2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>any也可以用于引用类型和右值引用</li><li>any在实际应用中可能遇到可读性问题：因为any在上下文中时编码者不会给出明显的类型提示<ul><li>参看如下代码：res最后是<code>const char*</code>类型，而不是<code>std::string</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::any test = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    std::string res = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(test);</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_any_cast&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not std::string.&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* res = std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(test);</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_any_cast&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not const char*.&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="variant"><a href="#variant" class="headerlink" title="variant"></a>variant</h2><ul><li>variant，又称“变体”，作用类似any，但需要提前指定可能会更改的类型</li><li>其本质是一个联合体，可以手动使用联合体模拟一个简单版本的variant数据结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; test;</span><br></pre></td></tr></table></figure><ul><li>与std::any类似，定义之后就可以赋值符合指定的variant类型的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="number">1</span>;</span><br><span class="line">test = <span class="number">2.2</span>;</span><br></pre></td></tr></table></figure><ul><li>与std::any类似，std::variant使用<code>std::get&lt;Type&gt;(var)</code>来判断和转换类型<ul><li>Type也可以是下标；</li><li>Type不是当前var的实际类型，会抛出<code>std::bad_variant_cast</code>异常</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取值，最好使用try-catch判断</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">int</span> tmp = std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(test);</span><br><span class="line"> std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_variant_access&amp; e) &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Not int.&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">double</span> tmp = std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(test);</span><br><span class="line"> std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_variant_access&amp; e) &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Not double.&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样是不可以的，因为没有float存在</span></span><br><span class="line"><span class="comment">// std::get&lt;float&gt;(test);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用下标代替尖括号内的内容，0是int，1是double，以此类推</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">double</span> tmp = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_variant_access&amp; e) &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Not 1.&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>variant由于编程者手动给出了类型，可以规避上述提到的std::any的问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; test = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="comment">// 检测其类型</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> std::string tmp = std::<span class="built_in">get</span>&lt;std::string&gt;(test);</span><br><span class="line"> std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_variant_access&amp; e) &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Not std::string.&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发现此处确实是std::string类型，而不是const char*</span></span><br><span class="line"><span class="comment">// 因此在字符串等处更推荐使用variant</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="STL" scheme="http://wiki.zhouweitong.site/categories/C/STL/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="STL" scheme="http://wiki.zhouweitong.site/tags/STL/"/>
    
    <category term="any" scheme="http://wiki.zhouweitong.site/tags/any/"/>
    
    <category term="variant" scheme="http://wiki.zhouweitong.site/tags/variant/"/>
    
  </entry>
  
  <entry>
    <title>函数与极限</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</id>
    <published>2023-03-01T07:00:00.000Z</published>
    <updated>2023-03-06T11:42:27.998Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数定义</li><li>复合函数<ul><li>注意内层值域&#x3D;外层定义域</li><li>不是任意函数都能复合</li></ul></li><li>反函数<ul><li>注意y到x要一一对应</li><li>性质</li></ul></li><li>初等函数<ul><li>基本初等函数<ul><li>幂函数</li><li>指数函数</li><li>对数函数</li><li>三角函数</li><li>反三角函数</li></ul></li><li>其他初等函数<ul><li>由常数或基本初等函数构成</li><li>由加减乘除或复合运算连接</li><li>能由一个解析式表示</li></ul></li></ul></li><li>函数性质<ul><li>单调性<ul><li>单调增</li><li>单调不减<ul><li>可出现水平线</li></ul></li><li>单调减</li><li>单调不增</li><li>性质<ul><li>注意是严格大于&#x2F;小于还是大于等于&#x2F;小于等于</li></ul></li><li>应用<ul><li>根的个数</li><li>不等式</li></ul></li><li>判定<ul><li>定义法</li><li>导数法</li></ul></li></ul></li><li>奇偶性<ul><li>性质</li><li>应用<ul><li>泰勒展开<ul><li>奇函数 在 x&#x3D;0 的 泰勒展开式中 没有偶次项</li><li>偶函数 在 x&#x3D;0 的 泰勒展开式中 没有奇次项</li></ul></li><li>原函数<ul><li>连续的奇函数 原函数都是偶函数</li><li>连续的偶函数 原函数之一是奇函数<ul><li>函数的原函数有无限多个</li><li>当引入的常数项 C 为 0（最简单的反函数）时，连续偶函数的原函数 f(t) 是奇函数    <img src="/wiki/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/image-20230301142214414.png" alt="image-20230301142214414"></li><li>倒推积分时，注意奇函数的积分下限只能是0</li></ul></li></ul></li></ul></li></ul></li><li>周期性<ul><li>常见的周期函数    <img src="/wiki/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/image-20230301142321368.png" alt="image-20230301142321368"><ul><li>出现三角函数，往往就暗示需要用到周期性</li></ul></li><li>周期性的判定<ul><li>定义法</li><li>周期函数可导，则导函数也是周期函数</li><li>周期函数的 原函数 不一定是周期函数<ul><li>当周期函数在一个周期上的积分为0时，其原函数是周期函数</li><li>反向也成立：若周期函数的原函数是周期函数，则当前周期函数在一个周期上的积分必为0</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><ul><li><p>“三基”</p><ul><li>基本概念</li><li>基本理论</li><li>基本方法</li></ul></li><li><p>常考题型</p></li><li><p>概念、理论<br>- 极限的概念、性质及存在准则</p></li><li><p>方法</p><ul><li>求极限</li><li>确定极限中的参数</li><li>无穷小量阶的比较</li></ul></li><li><p>概念</p></li><li><p>数列极限    <img src="/wiki/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/image-20230301143152958.png" alt="image-20230301143152958"><br>-  几何意义：数列项值的点落在极限的某个邻域区间内<br>- 数列有极限，则数列的部分列也有极限</p><ul><li>特殊情况：奇数项极限存在、偶数项极限存在、两个极限相等，则数列极限存在且也相等；反向成立<ul><li>[[TODO]]</li></ul></li></ul></li><li><p>函数极限<br> -   自变量趋向无穷值    <img src="/wiki/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/image-20230301162132633.png" alt="image-20230301162132633"></p><ul><li>注意趋于无穷的情况：实际上是指绝对值趋于正无穷<br> -   自变量趋向有限值    <img src="/wiki/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/image-20230301162211277.png" alt="image-20230301162211277"></li><li>注意：趋向的点可以没有定义，但点周边的邻域必须处处有定义</li></ul></li><li><p>无穷小</p></li><li><p>性质</p><ul><li>有限个无穷小的和是无穷小</li><li>有限个无穷小的积是无穷小</li><li>无穷小和有界量的乘积是无穷小</li></ul></li><li><p>无穷大</p></li><li><p>概念：绝对值要多大有多大</p></li><li><p>无穷大的比较</p><ul><li>不讨论无穷大的高阶、低阶问题</li><li>x趋于正无穷时，对数函数$\ln{x}$ &lt; 幂函数 $x^a$ &lt; 指数函数$a^x$</li><li>n趋于正无穷时，对数数列$\ln{n}$ &lt; 幂数列$n^a$ &lt; 指数数列$a^n$ &lt; 阶乘数列$n!$ &lt; $n^n$</li></ul></li><li><p>无穷大和无界变量关系</p><ul><li>无穷大：n很大时$x_n$绝对值都很大，强调持续</li><li>无界变量：n很大时存在一个$x_n$绝对值很大，强调存在</li><li>无穷大一定无界，无界不一定无穷大</li><li>两个数列：无穷大x无穷大&#x3D;无穷大；无界x无界≠无界</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="数学" scheme="http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等数学" scheme="http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://wiki.zhouweitong.site/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="函数" scheme="http://wiki.zhouweitong.site/tags/%E5%87%BD%E6%95%B0/"/>
    
    <category term="极限" scheme="http://wiki.zhouweitong.site/tags/%E6%9E%81%E9%99%90/"/>
    
    <category term="高等数学" scheme="http://wiki.zhouweitong.site/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>当今的操作系统</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BD%93%E4%BB%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BD%93%E4%BB%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-03-01T02:30:00.000Z</published>
    <updated>2023-03-06T11:26:32.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="程序是什么？"><a href="#程序是什么？" class="headerlink" title="程序是什么？"></a>程序是什么？</h2><ul><li>程序 &#x3D; 状态机<ul><li>状态：数据（堆和栈） -&gt; 栈帧（含PC寄存器）</li><li>初始状态：刚装入内存时的状态 - <code>main()</code>刚进入</li><li>状态迁移：指令的执行<ul><li>函数调用：看作压栈</li><li>函数返回：看作出栈</li><li>随机数：看作上下限区间内这么多种状态 - 比如0~10之间的整数随机数就有11种状态</li><li>状态机的结束：trap，syscall</li></ul></li><li>也可以认为：程序 &#x3D; 计算+syscall</li></ul></li><li>操作系统 &#x3D; 对象（文件，进程etc.） + API &#x3D; C语言程序</li><li>编译器<ul><li>将源代码级别的状态机转化为二进制代码级别的状态机</li><li>二者的可观测行为要严格一致</li><li>可以这样理解编译器的优化过程：在可观测行为一致时改写代码<ul><li>compiler barrier：需要对内存进行操作</li></ul></li></ul></li></ul><h2 id="今天的操作系统"><a href="#今天的操作系统" class="headerlink" title="今天的操作系统"></a>今天的操作系统</h2><ul><li>“虚拟化”应用广泛</li><li>NUMA</li><li>非对称处理器（大小核：性能核与能效核）</li><li>Intel-VT&#x2F;AMD-V等等</li><li>各种设备</li><li>互联互通</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="操作系统" scheme="http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="http://wiki.zhouweitong.site/tags/OS/"/>
    
    <category term="操作系统" scheme="http://wiki.zhouweitong.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="持续更新" scheme="http://wiki.zhouweitong.site/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>内存</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98/</id>
    <published>2023-02-28T14:55:00.000Z</published>
    <updated>2023-03-06T11:26:32.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h2><ul><li>一般分为如下四个区间<ul><li>代码区<ul><li>有时会将代码区拆成程序代码区和常量存储区</li></ul></li><li>静态&#x2F;全局变量区<ul><li>有时会拆分为静态变量区和全局变量区</li></ul></li><li>栈区：由上向下延申，自动维护<ul><li>即低地址向高地址</li></ul></li><li>堆区：由下向上延申，手动维护<ul><li>即高地址向低地址</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="操作系统" scheme="http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="http://wiki.zhouweitong.site/tags/OS/"/>
    
    <category term="内存" scheme="http://wiki.zhouweitong.site/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统补充知识</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</id>
    <published>2023-02-28T14:50:00.000Z</published>
    <updated>2023-03-06T11:26:32.319Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="数字电路"><a href="#数字电路" class="headerlink" title="数字电路"></a>数字电路</h2><ul><li>触发器（Flip-flop）<ul><li>R-S触发器（Reset-Set）</li><li>有输出1和输出0两种稳定的状态</li><li>可以用于记忆数据</li><li><a href="https://www.cnblogs.com/kkun/archive/2012/11/27/Flip-Flop.html">逻辑电路 - 触发器Flip-Flop - kkun - 博客园</a></li></ul></li></ul><p>##（待细化）</p><ul><li>gdb<ul><li>gdb starti</li><li>gdb layout asm&#x2F;src</li><li>gdb bt</li><li>gdb x&#x2F;</li></ul></li><li>Python<ul><li>z3</li><li>rich</li><li>sage</li><li>sympy</li></ul></li><li>汇编：行为是什么？<ul><li>retq</li></ul></li><li>gcc<ul><li><code>void _start()</code>：是实际上的gcc编译的C语言程序的启动函数</li><li><code>__ASSEMBLER__</code></li><li>汇编代码预编译？</li></ul></li><li>tmux</li><li>strace：分析程序使用了哪些syscall</li><li>time命令：测量程序运行时间</li><li>sort -nk：按照第几列进行数值排序</li><li>dialog：伪GUI，对话框</li><li>busybox，GNU coreutils</li><li>形式语义学</li><li>bash<ul><li>$status</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="操作系统" scheme="http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="http://wiki.zhouweitong.site/tags/OS/"/>
    
    <category term="持续更新" scheme="http://wiki.zhouweitong.site/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程与锁</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</id>
    <published>2023-02-28T14:30:00.000Z</published>
    <updated>2023-03-06T11:26:32.320Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h2><ul><li>需要借助进程和线程<ul><li>进程：资源分配的最小单位</li><li>线程：任务调度的最小单位</li></ul></li><li>多处理器：实际上是并行，同一时间点上同时，因为现在已经是多核CPU的时代</li><li>简单认为：一个程序n个线程，每个线程在不同的CPU核心上<ul><li>线程也有单独的状态机模型，“子状态机”</li><li>non-deterministic finite automaton（NFA），非确定性有限自动机，多线程的程序具有不确定性</li></ul></li><li>直观认识：thread.h<ul><li>基本步骤：create，生成并启动线程；join，等待所有线程返回；</li><li>gcc编译时：<code>-l pthread</code>，文档：<code>man 7 pthreads</code></li><li>thread.h是可以修改的，实现各种不同的功能：超大线程栈、detach运行等</li><li>实际上是POSIX API</li></ul></li><li>线程的特点：共享内存，独立堆栈<ul><li>当然也可以定义线程本地变量：<code>__thread</code></li><li><code>__attribute__((noinline))</code></li></ul></li></ul><h3 id="多线程带来的三个问题"><a href="#多线程带来的三个问题" class="headerlink" title="多线程带来的三个问题"></a>多线程带来的三个问题</h3><ul><li>原子性：使某一条指令独占处理器执行<ul><li>那多线程呢？线程可能会被打断</li><li>多处理器呢？其他处理器也要等</li><li>现代处理器指令集呢？add都不是原子的（可能涉及隐含的mov操作）<ul><li><a href="https://stackoverflow.com/questions/35332057/is-the-following-assembly-atomic-if-not-why">c - Is the following Assembly Atomic, If not, Why? - Stack Overflow</a></li></ul></li><li>使用常见算法进行互斥？许多算法只适用于两个线程的原子性保持</li></ul></li><li>实现原子性：<ul><li>临界区，上锁，解锁；</li><li>使用队列解决，参照Windows API；<ul><li>要进行任务拆分，形成worker线程；</li><li>线程池；</li></ul></li></ul></li><li>执行顺序的丧失：<ul><li>一部分是由编译器优化造成的：内存读写次数的优化</li></ul></li><li>保护执行顺序：<ul><li>编译器屏障——内存屏障（memory barrier）<ul><li><code>asm volatile (&quot;&quot; ::: &quot;memory&quot;);</code></li><li>保持编译后的代码（汇编的语义）与C语言代码的语义一致；</li></ul></li><li>为什么带有缓冲区的printf可以在多线程情况下正常调用？已经考虑到了线程安全；<ul><li>即不会出现 一个长字符串 插入到 另一个长字符串中 的情况</li></ul></li><li>stdatomic.h</li><li>可以手动进行内存同步：<ul><li>设置一个全局变量FLAG，取FLAG中的后两位bit</li><li>（主线程，或者main函数里）FLAG初始化为0</li><li><code>_sync_synchronize()</code>进行全内存同步（确保线程看到的FLAG都是0）</li><li>子线程通过异或修改FLAG的位</li><li>[[TODO]]</li></ul></li></ul></li><li>多处理器情况下可见性的丧失<ul><li>[[TODO]]</li></ul></li></ul><h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><ul><li>使用共享内存实现互斥<ul><li>[[TODO]]</li></ul></li></ul><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><ul><li>原子指令<ul><li>什么叫原子化？：执行过程中不能被打断；</li><li>x86<ul><li>lock指令前缀。为啥是前缀？因为要先去上锁；</li><li><code>xchg</code>，实际上是exchange</li></ul></li><li>其实原子化和自旋锁问题早就有了<ul><li>双路CPU，谁可以访问内存？</li><li>当时可以实现总线锁：CPU和缓存、内存间沟通都需要经过总线，总线加锁就安全了</li></ul></li><li>当代CPU<ul><li>缓存一致性</li><li>会给处理器增加很大性能负担</li></ul></li><li>其实都是load（读取或载入数据） -&gt; exec（执行一些步骤） -&gt; store（把执行结果写回）</li><li>RISC-V：LR&#x2F;SC，检测锁的拥堵</li></ul></li><li>自旋锁（spin lock）- 软件无法完美实现，就靠硬件来做<ul><li>一个线程加锁，其他线程重复询问锁，若仍获取不到锁则等待</li><li>特点：循环等待，也叫忙等</li><li>缺点：原子指令本身就有开销；忙等导致性能损失严重，处理器利用率低下；正在运行的线程可能会被调度，导致锁无法及时释放；</li><li>适用场景<ul><li>争抢锁的概率很小，或者几乎没有；</li><li>在抢占锁的时候禁止调度；</li><li>几乎只在操作系统内核代码里应用；</li></ul></li></ul></li><li>互斥锁（mutex lock） - 用户态无法完美实现，就靠内核态来做<ul><li>性能评价维度：伸缩性（Scalability）</li><li>互斥锁的锁一般由操作系统控制</li><li>一个线程加锁，其他线程询问锁，若获取不到则被调度；</li><li>特点：循环等待，但不忙等；</li><li>与自旋锁之间的区别<ul><li>自旋锁：下限很快（直接进临界区），上限很慢（忙等）</li><li>互斥锁：下限没那么快（进出内核），上限没那么慢（不会忙等）</li></ul></li></ul></li><li>Futex：快速的互斥锁<ul><li>futex &#x3D; fast user mutex</li><li>实际上是改良了的自旋锁和互斥锁</li><li>原子指令上锁<ul><li>上锁成功即直接进入互斥区</li><li>上锁失败自动调用内核API被调度</li></ul></li><li>二八定律</li><li>pthread_mutex</li><li>man futex</li><li>model checker?</li></ul></li><li>“找到你依赖的假设，并大胆地打破它”</li></ul><h2 id="PV问题（大题考点）"><a href="#PV问题（大题考点）" class="headerlink" title="PV问题（大题考点）"></a>PV问题（大题考点）</h2><ul><li>解题的一般流程<ul><li>检查有几类进程？一般每一类进程都对应着自己的函数</li><li>先在函数内部用中文描述进程动作；注意执行次数<ul><li>只做一次</li><li>不断重复：while(1)</li></ul></li><li>理清在执行进程前，要P什么<ul><li>注意：P和V是配对的，有P必有V；当发现需要P时，写完这个P必须先找它对应的V的位置，而不是去分析下一个P</li><li>注意隐含的互斥问题，例如缓冲区访问</li></ul></li><li>PV写完之后去定义信号量（和信号量本身的PV）</li><li>如果存在很多个P，需要检查会不会发生死锁，会发生的话则想办法解决<ul><li>只有多个P存在时才可能发生死锁，因为需要请求和保持条件</li></ul></li></ul></li></ul><h2 id="CPU指令流水线"><a href="#CPU指令流水线" class="headerlink" title="CPU指令流水线"></a>CPU指令流水线</h2><p>[[TODO]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="操作系统" scheme="http://wiki.zhouweitong.site/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="http://wiki.zhouweitong.site/tags/OS/"/>
    
    <category term="进程" scheme="http://wiki.zhouweitong.site/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="http://wiki.zhouweitong.site/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="http://wiki.zhouweitong.site/tags/%E9%94%81/"/>
    
    <category term="互斥" scheme="http://wiki.zhouweitong.site/tags/%E4%BA%92%E6%96%A5/"/>
    
    <category term="操作系统" scheme="http://wiki.zhouweitong.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>Lua版本、特性、数据结构和变量</title>
    <link href="http://wiki.zhouweitong.site/wiki/Lua/Lua%E7%89%88%E6%9C%AC%E3%80%81%E7%89%B9%E6%80%A7%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%98%E9%87%8F/"/>
    <id>http://wiki.zhouweitong.site/wiki/Lua/Lua%E7%89%88%E6%9C%AC%E3%80%81%E7%89%B9%E6%80%A7%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%98%E9%87%8F/</id>
    <published>2023-02-28T06:00:00.000Z</published>
    <updated>2023-03-06T11:42:27.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Lua分支和版本"><a href="#Lua分支和版本" class="headerlink" title="Lua分支和版本"></a>Lua分支和版本</h2><ul><li>Lua有诸多版本和分支，其中最著名的当属以下三个：<ul><li>Lua官方版本：<a href="https://www.lua.org/download.html">Lua: download</a>，由Lua社区维护；<ul><li>Windows版：<a href="http://luabinaries.sourceforge.net/download.html">Lua Binaries Download (sourceforge.net)</a></li><li>Linux版：<code>apt-get install lua5.4</code>就可以安装Lua 5.4（最新的大版本）</li></ul></li><li>LuaJIT：侧重于Lua的解释执行（即时编译）。<a href="https://luajit.org/download.html">Download (luajit.org)</a>；<ul><li>Linux版：同样<code>apt-get install luajit</code></li></ul></li><li>xLua：由腾讯公司开发，用于Unity程序内嵌Lua。<a href="https://github.com/Tencent/xLua">Tencent&#x2F;xLua (github.com)</a></li></ul></li><li>Lua不存在官方创建的、给第三方库提供托管服务的网站（类比npm）。常用的第三方库的获取和安装主要有以下两种办法：<ul><li>从源码安装。这包括：<ul><li>纯Lua库，下载、解压到require加载路径下，导入即可；</li><li>C库，下载、配合Lua源码（<code>lua.h</code>等）进行编译（Linux下会生成<code>.so</code>文件），设置<code>package.cpath</code>，然后导入；<ul><li>C库需要的Lua源码，Linux下可以通过<code>apt-get install liblua5.4-dev</code>来安装；</li></ul></li></ul></li><li>LuaRocks平台，可以当作第三方包管理器（Package Manager）使用<ul><li>建议Linux平台下载源码并编译安装：</li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install liblua5.4-dev</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure><ul><li>IDE：一般很少使用IDE来编写Lua代码，但可以参考：<ul><li>文本编辑器+LSP Server，如NeoVim；</li><li>调试器，如<a href="https://github.com/slembcke/debugger.lua">slembcke&#x2F;debugger.lua (github.com)</a></li><li>一些成型的IDE，但往往不能支持最新版本Lua，如<a href="https://studio.zerobrane.com/">ZeroBrane Studio</a></li></ul></li></ul><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li>Lua是解释型语言；<ul><li>因此，Lua也是有opcode和bytecode的，运行在VM之上；</li><li><a href="https://github.com/lua/lua/blob/master/lopcodes.h">lua&#x2F;lopcodes.h at master · lua&#x2F;lua</a></li><li>luac和luajit也可以编译<code>.lua</code>，但执行仍需解释器（可以理解为类似<code>.py</code>到<code>.pyc</code>的过程）；</li></ul></li><li>Lua解释器本体极小，且完全由C语言写成，因此可以很方便的：<ul><li>嵌入到其他大型程序中，如文本编辑器、游戏、开发工具等等；</li><li>与高性能的C语言程序结合，拓展其功能，如nginx-lua-module；</li><li>使用其编写功能完善的程序，并应用于嵌入式系统中，如openwrt的luci便是cgi+lua；</li></ul></li><li>Lua语言是弱类型语言</li><li>Lua语言是面向过程的语言，但可以模拟面向对象</li><li>Lua的版本与版本之间差异较大<ul><li>运行于官版Lua上的库，可能无法兼容luajit或xLua；</li><li>运行于Lua 5.1上的库，可能无法兼容Lua 5.2（不向后兼容）；</li><li>同样地，运行于Lua 5.2上的库，可能无法兼容Lua 5.1（不向前兼容）；</li></ul></li></ul><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ul><li>由于不同的Lua分支可能在语法上有差异（甚至可能有不同的opcode），所以此处以官方版本语法为准</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释：<code>--</code></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Test</span></span><br></pre></td></tr></table></figure><ul><li>多行注释：<code>--[[ --]]</code></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This</span></span><br><span class="line"><span class="comment">is</span></span><br><span class="line"><span class="comment">Comment</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>Lua共有8个基本类型</li><li><code>nil</code>：表示无效值&#x2F;值不存在，可转换为布尔型的<code>false</code><ul><li>未初始化的变量，访问即可得到其值<code>nil</code></li><li>将<code>nil</code>赋值给变量等同于将该变量删除，此后内存空间会被GC（垃圾回收器）自动回收</li></ul></li><li><code>boolean</code>：布尔型，值为<code>true</code>或者<code>false</code></li><li><code>number</code>：数字类型，保存一切数字数据，为双精度浮点型（即C中的<code>double</code>）</li><li><code>string</code>：字符串。双引号或单引号包裹字符串字面量。</li><li><code>function</code>：函数，类似于C中的函数指针（只不过不需要各种间接访问符）。既可以是Lua中定义的函数，也可以是C插件中定义的函数。</li><li><code>thread</code>：非抢占式协程（用户态线程），变量本身可看作是协程的handler。<ul><li>Lua实现抢占式多线程（甚至是多进程）需要使用第三方库</li><li>协程只能支持并发（时间段内同时）而不支持并行（时间点上同时）</li><li><a href="https://lualanes.github.io/lanes/">Lua Lanes - multithreading in Lua</a></li></ul></li><li><code>table</code>：表，Lua中最重要的数据类型之一，兼具数组和Map的特征，同时可以用于模拟面向对象编程</li><li><code>userdata</code>：纯内存空间。主要用于Lua环境与C插件间的变量交互，例如在Lua中给C插件生成的C语言结构体开辟空间</li><li>判断变量的类型：<code>type(xxx)</code></li></ul><h3 id="变量及其赋值"><a href="#变量及其赋值" class="headerlink" title="变量及其赋值"></a>变量及其赋值</h3><ul><li>Lua变量赋值时均不用指定数据类型。以下是最简单的、合法的变量定义语句：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>变量只有两种作用域类型：局部变量、全局变量。没有被<code>local</code>关键字修饰的变量均是全局变量</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span> <span class="comment">--全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">20</span> <span class="comment">--局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">30</span> <span class="comment">--全局变量，add函数以外仍可以访问</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">40</span> <span class="comment">--局部变量，add函数结束就销毁</span></span><br><span class="line">    b = <span class="number">50</span> <span class="comment">--作用域外的全局变量或局部变量均可被重新赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>赋值语句：分为单值赋值语句和多值赋值语句<ul><li>单值赋值语句：与C语言几乎相同：<code>task.m_1 = task.m_1 + 2</code></li><li>多值赋值语句：可同时定义并初始化多个变量： <code>a, b, c = 10, 2 + 2, 3.14</code></li><li>多值赋值语句的特例：<ul><li>可以用于快速交换两个变量的值：<code>x, y = y, x</code></li><li>变量个数少于值的个数，多余的值会被忽略：<code>a, b = 10, 11, 12</code>，12会被忽略</li><li>变量个数多于值的个数，多余的变量不会被定义</li></ul></li></ul></li></ul><p>[[TODO]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="Lua" scheme="http://wiki.zhouweitong.site/categories/Lua/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="http://wiki.zhouweitong.site/tags/Lua/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>认识CUDA</title>
    <link href="http://wiki.zhouweitong.site/wiki/CUDA/%E8%AE%A4%E8%AF%86CUDA/"/>
    <id>http://wiki.zhouweitong.site/wiki/CUDA/%E8%AE%A4%E8%AF%86CUDA/</id>
    <published>2023-02-28T03:00:00.000Z</published>
    <updated>2023-03-06T11:42:27.996Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="CUDA是？"><a href="#CUDA是？" class="headerlink" title="CUDA是？"></a>CUDA是？</h2><ul><li>是适用于NVIDIA GPU的通用目的GPU（GPGPU）并行编程平台</li><li>安装？：<a href="https://developer.nvidia.com/cuda-downloads">CUDA Toolkit 12.0 Update 1 Downloads | NVIDIA Developer</a></li><li>用什么编译器？：实际上是NVIDIA自己的nvcc<ul><li>CUDA语言是C++的超集，因此可以和C++混编</li><li>nvcc会将非CUDA部分的代码送给其他编译器（如MSVC或clang）编译，自己编译CUDA部分代码</li></ul></li><li>CMake、Visual Studio均支持CUDA项目</li><li>开发环境：Visual Studio + CUDA Toolkit最常见</li></ul><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ul><li>一般含有CUDA代码的源码文件，扩展名改为<code>.cu</code></li><li>头文件：<code>#include &lt;cuda_runtime.h&gt;</code></li><li>入口点<ul><li>程序入口点依然是C++中的<code>int main()</code>函数</li><li>程序不会在入口点就在GPU上执行，而是依然在CPU上执行</li></ul></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>CUDA通过特殊定义的关键字标识代码在CPU上执行，还是在GPU上执行</li><li>修饰函数的关键字，用法：<code>__global__ void func() &#123;&#125;</code></li><li><code>__device__</code>：由GPU调用，在GPU上执行</li><li><code>__global__</code>：由CPU调用，在GPU上执行</li><li><code>__host__</code>：由CPU调用，在CPU上执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="CUDA" scheme="http://wiki.zhouweitong.site/categories/CUDA/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="CUDA" scheme="http://wiki.zhouweitong.site/tags/CUDA/"/>
    
    <category term="NVIDIA" scheme="http://wiki.zhouweitong.site/tags/NVIDIA/"/>
    
    <category term="GPU" scheme="http://wiki.zhouweitong.site/tags/GPU/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>准备工作与K8s部署</title>
    <link href="http://wiki.zhouweitong.site/wiki/K8s/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E4%B8%8EK8s%E9%83%A8%E7%BD%B2/"/>
    <id>http://wiki.zhouweitong.site/wiki/K8s/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E4%B8%8EK8s%E9%83%A8%E7%BD%B2/</id>
    <published>2023-02-27T11:00:00.000Z</published>
    <updated>2023-02-27T15:27:31.565Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Linux操作系统<ul><li>Ubuntu、Debian、CentOS、Fedora、RHEL、openSUSE&#x2F;SLES 等主流Linux发行版</li><li>Fedora CoreOS、VMware Photon OS等“容器专用”OS</li></ul></li><li>足够的RAM和存储：物理机部署时推荐只运行K8s相关程序</li><li>Internet连接，或能够访问特定registry（需要提前搭好registry并在registry中添加K8s组件镜像）</li><li>物理机之间的网络联通（Worker访问Control的API、Worker与Worker之间的网络甚至存储共享）</li><li>安装好部署工具 见下文</li><li>安装好CRI-O标准兼容的容器工具，docker、podman、containerd等均可<ul><li>podman：绝对开源，无服务（无daemon），很适用于Rootless Container模式（低权限），仅支持Linux容器</li><li>docker：最主流，有商业版，传统daemon模式（需要root&#x2F;管理员权限），支持Linux容器和Windows容器</li><li>containerd：最基础，绝对开源，最标准，是K8s、K3s等默认的CRI-O容器工具，支持Linux容器和Windows容器</li></ul></li><li>可以使用带GUI的容器工具<ul><li>Podman Desktop</li><li>Docker Desktop</li><li>Rancher Desktop</li></ul></li></ul><h2 id="该选哪种部署方式？"><a href="#该选哪种部署方式？" class="headerlink" title="该选哪种部署方式？"></a>该选哪种部署方式？</h2><ul><li>大型生产环境：完整的K8s集群<ul><li>使用 kubeadm 工具进行部署</li><li>有两种节点类型：Control Plane（控制平面，也叫Master）和Worker</li><li>适合物理机部署</li><li>需要高配置（稳定运行最好2thread+8GB）</li><li>最好多个物理机（Control Plane和Worker隔离，应用容器只部署在Worker上），最好3台以上（1 Control + 2 Worker）</li></ul></li><li>小型生产环境：K3s<ul><li>由rancher公司开发维护</li><li>直接使用k3s工具进行部署</li><li>有两种节点类型Server和Agent，默认单节点Server</li><li>裸机部署和虚拟机部署均可</li><li>配置需求低（1thread+512MB足够）</li></ul></li><li>本地测试环境：minikube<ul><li>由K8s官方维护</li><li>不建议暴露在公网 很多默认配置都是以localhost或内网为基础的</li><li>默认是单节点 可以扩展为多节点</li></ul></li><li>其他：Microk8s，Canonical公司开发与维护，使用snap部署</li></ul><h2 id="部署K3s"><a href="#部署K3s" class="headerlink" title="部署K3s"></a>部署K3s</h2><ul><li><p>如果需要关闭已有的K3s集群：<code>k3s-killall.sh</code></p></li><li><p>安装</p><ul><li>主节点（Server）<ul><li><code>curl -sfL https://get.k3s.io | sh -</code></li><li>默认安装的selinux规则太旧 手动安装新的。以CoreOS为例：<code>sudo rpm-ostree install https://github.com/k3s-io/k3s-selinux/releases/download/v1.2.stable.2/k3s-selinux-1.2-2.el8.noarch.rpm</code></li></ul></li><li>子节点（Agent）<ul><li>要先找主节点的token，再记录主节点的ip地址<ul><li><code>sudo cat /var/lib/rancher/k3s/server/node-token</code></li><li><code>ip addr</code></li></ul></li><li>然后使用安装命令，加入特殊变量<ul><li><code>curl -sfL https://get.k3s.io | K3S_TOKEN=&quot;&lt;主节点token值&gt;&quot; K3S_URL=&quot;https://&lt;主节点ip地址&gt;:6443&quot; sh -</code></li></ul></li></ul></li></ul></li><li><p>systemd service文件位置</p><ul><li>主节点：<code>/etc/systemd/system/k3s.service</code></li><li>子节点：<code>/etc/systemd/system/k3s-agent.service</code></li></ul></li><li><p>升级</p><ul><li>依然使用curl在线获取升级脚本，版本号可去 <a href="https://github.com/k3s-io/k3s/releases">Releases · k3s-io&#x2F;k3s</a> 查看，使用环境变量 <code>INSTALL_K3S_VERSION</code> 指定新版本</li><li>主节点<ul><li><code>curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=&lt;版本号&gt; sh -</code></li></ul></li><li>子节点<ul><li><code>curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=&lt;版本号&gt; K3S_TOKEN=&quot;&lt;主节点token值&gt;&quot; K3S_URL=&quot;https://&lt;主节点ip地址&gt;:6443&quot; sh -</code></li></ul></li></ul></li></ul><h2 id="部署Minikube"><a href="#部署Minikube" class="headerlink" title="部署Minikube"></a>部署Minikube</h2><ul><li>如果要删掉已有的Minikube集群<ul><li>停止：<code>minikube stop</code></li><li>删除：<code>minikube delete --all</code></li></ul></li><li>借助containerd和podman，启动新集群<ul><li><code>minikube start --driver=podman --container-runtime=containerd --listen-address=0.0.0.0</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="K8s" scheme="http://wiki.zhouweitong.site/categories/K8s/"/>
    
    
    <category term="K8s" scheme="http://wiki.zhouweitong.site/tags/K8s/"/>
    
    <category term="K3s" scheme="http://wiki.zhouweitong.site/tags/K3s/"/>
    
    <category term="Minikube" scheme="http://wiki.zhouweitong.site/tags/Minikube/"/>
    
  </entry>
  
  <entry>
    <title>mangle与demangle</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/mangle%E4%B8%8Edemangle/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/mangle%E4%B8%8Edemangle/</id>
    <published>2023-02-25T13:20:00.000Z</published>
    <updated>2023-03-06T07:28:02.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>Example.cc：测试程序</li><li>Example.s：使用<code>g++ -S</code>编译后的汇编文件</li><li>观察函数名，发现似乎函数名经过了某种编码<ul><li><code>void Test::func_1()</code>：<code>_ZN4Test6func_1Ev</code></li><li><code>static std::string func_2(int in_a)</code>：消失<ul><li>原因：inline</li></ul></li><li><code>Test* Test::func_3(double in_b)</code>：<code>_ZN4Test6func_3Ed</code></li><li><code>int test_2(std::string in_c, uint16_t in_d)</code>：<code>_Z6test_2NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEt</code></li></ul></li><li>原因：mangle<ul><li>因为C++可以函数重载和重写引入的功能</li><li>本质就是对函数的命名空间（比如哪个类或者哪个namespace）、函数名、函数参数进行编码<ul><li>注意：不编码函数返回值</li></ul></li><li>可以被解码</li><li>不同编译器编码规则不同，一般以g++为例</li></ul></li><li>解码：demangle<ul><li>使用工具 c++filt</li><li>包含在binutils软件包中</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>单元测试与模糊测试</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</id>
    <published>2023-02-25T13:00:00.000Z</published>
    <updated>2023-03-06T07:28:02.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>单元测试：Unit Test，特点是作者需要指定正确的输入数据和输出结果</li><li>单元测试的目的在于验证逻辑正确性</li><li>模糊测试：Fuzz Test&#x2F;Monkey Test，特点是由程序库&#x2F;其他工具随机生成输入数据，通过规则校验输出结果</li><li>模糊测试的目的在于验证代码鲁棒性</li></ul><h2 id="单元测试库：Gtest-x2F-Gmock"><a href="#单元测试库：Gtest-x2F-Gmock" class="headerlink" title="单元测试库：Gtest&#x2F;Gmock"></a>单元测试库：Gtest&#x2F;Gmock</h2><ul><li><code>vcpkg install gtest:x64-windows</code></li><li>需要新建项目，或者新建文件<ul><li>[[TODO]]</li></ul></li></ul><h2 id="模糊测试库-LibFuzzer"><a href="#模糊测试库-LibFuzzer" class="headerlink" title="模糊测试库-LibFuzzer"></a>模糊测试库-LibFuzzer</h2><p>[[TODO]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>其他规则</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%85%B6%E4%BB%96%E8%A7%84%E5%88%99/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%85%B6%E4%BB%96%E8%A7%84%E5%88%99/</id>
    <published>2023-02-25T12:50:00.000Z</published>
    <updated>2023-03-06T07:28:02.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>不能在类的析构函数中抛出异常；</li><li>建议父类的析构函数均声明为虚函数；建议有其他虚函数的类其析构函数也要声明为虚函数；</li><li>定义函数时，要做到想清楚以下几点：<ul><li>先验条件（Preconditions）：函数需要什么样的输入？<ul><li>例如：sqrt(x)，x&gt;&#x3D;0</li></ul></li><li>后验条件（Postconditions）：函数保证提供什么样的输出？<ul><li>例如：sin(x)一定返回(-1, 1)</li></ul></li><li>不变量（Invariant）：函数不能改变哪些东西？<ul><li>例如：sin(x)中不会改变x的值</li></ul></li><li>副作用（Side effect）：函数改变了哪些它作用域以外的东西？<ul><li>例如：file.write()改变了写入的文件内容</li></ul></li><li>目的（Propose）：你写的函数是否有清晰的目的？函数是否达到了它的目的？<ul><li>例如：ChangeStudentName()：写它是为了修改学生姓名，它也确实修改了学生姓名</li></ul></li><li>函数名（Name）：函数名是否清晰地传达了函数的目的？<ul><li>例如：Name()一般来说就不是一个好名字——对“Name”做了什么？</li></ul></li><li>函数参数名（Parameter）：函数参数名是否清晰易懂不会混淆？<ul><li>例如：ChangeStudentName(a, b, c)：a、b、c具体是什么东西？</li></ul></li></ul></li><li>不要在仿函数的<code>operator()</code>调用中修改数据成员，即保持其无状态（Stateless）；</li><li>单行定义单个变量时，<code>&amp;</code>或<code>*</code>应紧贴类型名：<code>int* a;</code></li><li>单行定义多个变量时，<code>&amp;</code>或<code>*</code>应紧贴变量名：<code>int *a, &amp;b;</code></li><li>为避免出现冲突，头文件不应该包含<code>using</code>语句；</li><li>[[TODO]]</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    <category term="未写完" scheme="http://wiki.zhouweitong.site/tags/%E6%9C%AA%E5%86%99%E5%AE%8C/"/>
    
  </entry>
  
  <entry>
    <title>函数参数规则</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%84%E5%88%99/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%84%E5%88%99/</id>
    <published>2023-02-25T11:50:00.000Z</published>
    <updated>2023-03-06T07:28:02.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>大体上可以分为三种传递类型：传值、传指针和传引用<ul><li>传值：新建临时变量（形参名即是变量名），使用赋值将外部的参数值传递给临时变量</li><li>传指针：指针本身是基本类型（int或int64）进行传值，而不涉及到指针指向的内存区域的复制</li><li>传引用：相当于给外部的参数值设置单独的别名和访问权限，本质也是传指针，可看作是传指针的语法糖</li></ul></li><li>三种传递类型的优缺点<ul><li>传值：最直接，而且临时变量与外部变量完全无关；复制开销很大，尤其是对于对象等较大的变量时；</li><li>传指针：能节省很大开销，C语言也可以使用；还是发生了传值过程，使用不方便；</li><li>传引用：几乎节省全部开销，能很好与C++的左右值和重载功能相结合；不是所有场合都适合传引用；</li></ul></li><li>综合各优缺点，得出的使用规则：<ul><li>基本类型传值、传引用和传指针均可，但必须是单个变量等级的传递</li><li>对象的传递，包括标准模板库生成的对象，必须传递引用，除非是下面的情况：<ul><li>在需要兼容性的情况下（如Windows API编程）可能不允许传递引用，此时对非基本类型的数据应首先考虑传递指针</li></ul></li></ul></li><li>概括：传引用（常用）-&gt; 传指针（兼容性）-&gt; 传值（基本类型）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
