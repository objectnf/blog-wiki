<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ObjectNotFound Wiki</title>
  
  
  <link href="http://wiki.zhouweitong.site/atom.xml" rel="self"/>
  
  <link href="http://wiki.zhouweitong.site/"/>
  <updated>2023-02-28T03:37:49.146Z</updated>
  <id>http://wiki.zhouweitong.site/</id>
  
  <author>
    <name>ObjectNotFound</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>认识CUDA</title>
    <link href="http://wiki.zhouweitong.site/wiki/CUDA/%E8%AE%A4%E8%AF%86CUDA/"/>
    <id>http://wiki.zhouweitong.site/wiki/CUDA/%E8%AE%A4%E8%AF%86CUDA/</id>
    <published>2023-02-28T03:00:00.000Z</published>
    <updated>2023-02-28T03:37:49.146Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="CUDA是？"><a href="#CUDA是？" class="headerlink" title="CUDA是？"></a>CUDA是？</h2><ul><li>是适用于NVIDIA GPU的通用目的GPU（GPGPU）并行编程平台</li><li>安装？：<a href="https://developer.nvidia.com/cuda-downloads">CUDA Toolkit 12.0 Update 1 Downloads | NVIDIA Developer</a></li><li>用什么编译器？：实际上是NVIDIA自己的nvcc<ul><li>CUDA语言是C++的超集，因此可以和C++混编</li><li>nvcc会将非CUDA部分的代码送给其他编译器（如MSVC或clang）编译，自己编译CUDA部分代码</li></ul></li><li>CMake、Visual Studio均支持CUDA项目</li><li>开发环境：Visual Studio + CUDA Toolkit最常见</li></ul><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ul><li>一般含有CUDA代码的源码文件，扩展名改为<code>.cu</code></li><li>头文件：<code>#include &lt;cuda_runtime.h&gt;</code></li><li>入口点<ul><li>程序入口点依然是C++中的<code>int main()</code>函数</li><li>程序不会在入口点就在GPU上执行，而是依然在CPU上执行</li></ul></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>CUDA通过特殊定义的关键字标识代码在CPU上执行，还是在GPU上执行</li><li>修饰函数的关键字，用法：<code>__global__ void func() &#123;&#125;</code></li><li><code>__device__</code>：由GPU调用，在GPU上执行</li><li><code>__global__</code>：由CPU调用，在GPU上执行</li><li><code>__host__</code>：由CPU调用，在CPU上执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="CUDA" scheme="http://wiki.zhouweitong.site/categories/CUDA/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="CUDA" scheme="http://wiki.zhouweitong.site/tags/CUDA/"/>
    
    <category term="NVIDIA" scheme="http://wiki.zhouweitong.site/tags/NVIDIA/"/>
    
    <category term="GPU" scheme="http://wiki.zhouweitong.site/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>准备工作与K8s部署</title>
    <link href="http://wiki.zhouweitong.site/wiki/K8s/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E4%B8%8EK8s%E9%83%A8%E7%BD%B2/"/>
    <id>http://wiki.zhouweitong.site/wiki/K8s/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E4%B8%8EK8s%E9%83%A8%E7%BD%B2/</id>
    <published>2023-02-27T11:00:00.000Z</published>
    <updated>2023-02-27T15:27:31.565Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Linux操作系统<ul><li>Ubuntu、Debian、CentOS、Fedora、RHEL、openSUSE&#x2F;SLES 等主流Linux发行版</li><li>Fedora CoreOS、VMware Photon OS等“容器专用”OS</li></ul></li><li>足够的RAM和存储：物理机部署时推荐只运行K8s相关程序</li><li>Internet连接，或能够访问特定registry（需要提前搭好registry并在registry中添加K8s组件镜像）</li><li>物理机之间的网络联通（Worker访问Control的API、Worker与Worker之间的网络甚至存储共享）</li><li>安装好部署工具 见下文</li><li>安装好CRI-O标准兼容的容器工具，docker、podman、containerd等均可<ul><li>podman：绝对开源，无服务（无daemon），很适用于Rootless Container模式（低权限），仅支持Linux容器</li><li>docker：最主流，有商业版，传统daemon模式（需要root&#x2F;管理员权限），支持Linux容器和Windows容器</li><li>containerd：最基础，绝对开源，最标准，是K8s、K3s等默认的CRI-O容器工具，支持Linux容器和Windows容器</li></ul></li><li>可以使用带GUI的容器工具<ul><li>Podman Desktop</li><li>Docker Desktop</li><li>Rancher Desktop</li></ul></li></ul><h2 id="该选哪种部署方式？"><a href="#该选哪种部署方式？" class="headerlink" title="该选哪种部署方式？"></a>该选哪种部署方式？</h2><ul><li>大型生产环境：完整的K8s集群<ul><li>使用 kubeadm 工具进行部署</li><li>有两种节点类型：Control Plane（控制平面，也叫Master）和Worker</li><li>适合物理机部署</li><li>需要高配置（稳定运行最好2thread+8GB）</li><li>最好多个物理机（Control Plane和Worker隔离，应用容器只部署在Worker上），最好3台以上（1 Control + 2 Worker）</li></ul></li><li>小型生产环境：K3s<ul><li>由rancher公司开发维护</li><li>直接使用k3s工具进行部署</li><li>有两种节点类型Server和Agent，默认单节点Server</li><li>裸机部署和虚拟机部署均可</li><li>配置需求低（1thread+512MB足够）</li></ul></li><li>本地测试环境：minikube<ul><li>由K8s官方维护</li><li>不建议暴露在公网 很多默认配置都是以localhost或内网为基础的</li><li>默认是单节点 可以扩展为多节点</li></ul></li><li>其他：Microk8s，Canonical公司开发与维护，使用snap部署</li></ul><h2 id="部署K3s"><a href="#部署K3s" class="headerlink" title="部署K3s"></a>部署K3s</h2><ul><li><p>如果需要关闭已有的K3s集群：<code>k3s-killall.sh</code></p></li><li><p>安装</p><ul><li>主节点（Server）<ul><li><code>curl -sfL https://get.k3s.io | sh -</code></li><li>默认安装的selinux规则太旧 手动安装新的。以CoreOS为例：<code>sudo rpm-ostree install https://github.com/k3s-io/k3s-selinux/releases/download/v1.2.stable.2/k3s-selinux-1.2-2.el8.noarch.rpm</code></li></ul></li><li>子节点（Agent）<ul><li>要先找主节点的token，再记录主节点的ip地址<ul><li><code>sudo cat /var/lib/rancher/k3s/server/node-token</code></li><li><code>ip addr</code></li></ul></li><li>然后使用安装命令，加入特殊变量<ul><li><code>curl -sfL https://get.k3s.io | K3S_TOKEN=&quot;&lt;主节点token值&gt;&quot; K3S_URL=&quot;https://&lt;主节点ip地址&gt;:6443&quot; sh -</code></li></ul></li></ul></li></ul></li><li><p>systemd service文件位置</p><ul><li>主节点：<code>/etc/systemd/system/k3s.service</code></li><li>子节点：<code>/etc/systemd/system/k3s-agent.service</code></li></ul></li><li><p>升级</p><ul><li>依然使用curl在线获取升级脚本，版本号可去 <a href="https://github.com/k3s-io/k3s/releases">Releases · k3s-io&#x2F;k3s</a> 查看，使用环境变量 <code>INSTALL_K3S_VERSION</code> 指定新版本</li><li>主节点<ul><li><code>curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=&lt;版本号&gt; sh -</code></li></ul></li><li>子节点<ul><li><code>curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=&lt;版本号&gt; K3S_TOKEN=&quot;&lt;主节点token值&gt;&quot; K3S_URL=&quot;https://&lt;主节点ip地址&gt;:6443&quot; sh -</code></li></ul></li></ul></li></ul><h2 id="部署Minikube"><a href="#部署Minikube" class="headerlink" title="部署Minikube"></a>部署Minikube</h2><ul><li>如果要删掉已有的Minikube集群<ul><li>停止：<code>minikube stop</code></li><li>删除：<code>minikube delete --all</code></li></ul></li><li>借助containerd和podman，启动新集群<ul><li><code>minikube start --driver=podman --container-runtime=containerd --listen-address=0.0.0.0</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="K8s" scheme="http://wiki.zhouweitong.site/categories/K8s/"/>
    
    
    <category term="K8s" scheme="http://wiki.zhouweitong.site/tags/K8s/"/>
    
    <category term="K3s" scheme="http://wiki.zhouweitong.site/tags/K3s/"/>
    
    <category term="Minikube" scheme="http://wiki.zhouweitong.site/tags/Minikube/"/>
    
  </entry>
  
  <entry>
    <title>AI绘画模型和插件汇总</title>
    <link href="http://wiki.zhouweitong.site/wiki/AI%E7%BB%98%E7%94%BB/AI%E7%BB%98%E7%94%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
    <id>http://wiki.zhouweitong.site/wiki/AI%E7%BB%98%E7%94%BB/AI%E7%BB%98%E7%94%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</id>
    <published>2023-02-27T05:00:00.000Z</published>
    <updated>2023-02-28T05:27:13.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="绘画模型（-ckpt-x2F-safetensors）"><a href="#绘画模型（-ckpt-x2F-safetensors）" class="headerlink" title="绘画模型（*.ckpt&#x2F;*.safetensors）"></a>绘画模型（*.ckpt&#x2F;*.safetensors）</h2><h3 id="Novel-AI-泄露版模型"><a href="#Novel-AI-泄露版模型" class="headerlink" title="Novel AI 泄露版模型"></a>Novel AI 泄露版模型</h3><ul><li>基于Stable Diffusion网络结构，使用Danbooru数据集进行多次训练后的权重</li><li>至少需 5.8GiB 存储空间</li><li>磁力链接，使用BitTorrent协议下载</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnet:?xt=urn:btih:5bde442da86265b670a3e5ea3163afad2c6f8ecc</span><br></pre></td></tr></table></figure><ul><li>SFW（Suitable For Work）模型：<code>stableckpt/animesfw-final-pruned</code></li><li>NSFW模型：<code>stableckpt/animefull-final-pruned</code></li></ul><h3 id="Stable-Diffusion-官方模型"><a href="#Stable-Diffusion-官方模型" class="headerlink" title="Stable Diffusion 官方模型"></a>Stable Diffusion 官方模型</h3><ul><li>官方Stable Diffusion，使用多个图片数据集</li><li>Stable Diffusion 1.5<ul><li><a href="https://huggingface.co/runwayml/stable-diffusion-v1-5">runwayml&#x2F;stable-diffusion-v1-5 · Hugging Face</a></li><li>至少需 4.0GB 存储空间</li></ul></li><li>其他Stable Diffusion 1.x版本模型：<a href="https://huggingface.co/CompVis">CompVis (CompVis)</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.ckpt</span><br></pre></td></tr></table></figure><ul><li>Stable Diffusion 2.1<ul><li><a href="https://huggingface.co/stabilityai/stable-diffusion-2-1">stabilityai&#x2F;stable-diffusion-2-1 · Hugging Face</a></li><li>至少需 4.9GB 存储空间</li></ul></li><li>其他Stable Diffusion 2.x版本模型：<a href="https://huggingface.co/stabilityai">stabilityai (Stability AI)</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt</span><br></pre></td></tr></table></figure><h3 id="Waifu-Diffusion"><a href="#Waifu-Diffusion" class="headerlink" title="Waifu Diffusion"></a>Waifu Diffusion</h3><ul><li>使用Stable Diffusion网络结构，精选了Danbooru数据集</li><li>Waifu Diffusion 1.4<ul><li><a href="https://huggingface.co/hakurei/waifu-diffusion-v1-4">hakurei&#x2F;waifu-diffusion-v1-4 · Hugging Face</a></li><li>至少需 4.8GB 存储空间</li></ul></li><li>其他Waifu Diffusion 1.x版本模型：<a href="https://huggingface.co/hakurei">hakurei (Reimu Hakurei)</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/hakurei/waifu-diffusion-v1-4/resolve/main/wd-1-4-anime_e2.ckpt</span><br></pre></td></tr></table></figure><h3 id="Kenshi"><a href="#Kenshi" class="headerlink" title="Kenshi"></a>Kenshi</h3><ul><li>基于Stable Diffusion网络结构，强调“照片感”。是对多个模型的加权融合，包括BoChen模型、WLOP模型等；</li><li>Kenshi01<ul><li><a href="https://huggingface.co/SweetLuna/Kenshi">SweetLuna&#x2F;Kenshi · Hugging Face</a></li><li>至少需 4.0GB 存储空间</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/SweetLuna/Kenshi/resolve/main/KENSHI%2001/KENSHI01_Pruned.ckpt</span><br></pre></td></tr></table></figure><h3 id="AbyssOrangeMix3"><a href="#AbyssOrangeMix3" class="headerlink" title="AbyssOrangeMix3"></a>AbyssOrangeMix3</h3><ul><li>基于Stable Diffusion网络结构，是对多个模型的加权融合，侧重“高质量”和“画面内的纹理效果”</li><li>分为A1（平涂）、A2（厚涂；油画风）、A3（融合）三个版本</li><li>至少需 2.0GB 存储空间</li><li><a href="https://huggingface.co/WarriorMama777/OrangeMixs">WarriorMama777&#x2F;OrangeMixs · Hugging Face</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/WarriorMama777/OrangeMixs/resolve/main/Models/AbyssOrangeMix3/AOM3A3.safetensors</span><br></pre></td></tr></table></figure><h3 id="NeverEnding-Dream"><a href="#NeverEnding-Dream" class="headerlink" title="NeverEnding Dream"></a>NeverEnding Dream</h3><ul><li>基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“好看的人像”及“有生成cosplay照片的能力”</li><li>至少需 4.0GB 存储空间</li><li><a href="https://civitai.com/models/10028/neverending-dream">NeverEnding Dream (NED) | Stable Diffusion Checkpoint | Civitai</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/11925</span><br></pre></td></tr></table></figure><h3 id="ChilloutMix"><a href="#ChilloutMix" class="headerlink" title="ChilloutMix"></a>ChilloutMix</h3><ul><li>基于Stable Diffusion网络结构，是对多个模型的加权融合及补充训练，侧重“2.5D”、“人像”及“cosplay照片生成”</li><li>至少需 4.0GB 存储空间</li><li><a href="https://civitai.com/models/6424/chilloutmix">ChilloutMix | Stable Diffusion Checkpoint | Civitai</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/11745</span><br></pre></td></tr></table></figure><h2 id="WebUI-插件"><a href="#WebUI-插件" class="headerlink" title="WebUI 插件"></a>WebUI 插件</h2><h3 id="a1111-sd-webui-tagcomplete"><a href="#a1111-sd-webui-tagcomplete" class="headerlink" title="a1111-sd-webui-tagcomplete"></a>a1111-sd-webui-tagcomplete</h3><ul><li>给WebUI增加Danbooru tag数据库和自动补全支持</li><li><a href="https://github.com/DominikDoom/a1111-sd-webui-tagcomplete">DominikDoom&#x2F;a1111-sd-webui-tagcomplete: Booru style tag autocompletion for AUTOMATIC1111’s Stable Diffusion web UI</a></li></ul><h3 id="sd-webui-supermerger"><a href="#sd-webui-supermerger" class="headerlink" title="sd-webui-supermerger"></a>sd-webui-supermerger</h3><ul><li>直接加权融合多个模型并进行使用，而不需要先合并网络参数制作模型文件</li><li><a href="https://github.com/hako-mikan/sd-webui-supermerger/">hako-mikan&#x2F;sd-webui-supermerger: model merge extention for stable diffusion web ui</a></li></ul><h3 id="sd-webui-controlnet"><a href="#sd-webui-controlnet" class="headerlink" title="sd-webui-controlnet"></a>sd-webui-controlnet</h3><ul><li>给WebUI增加ControlNet支持</li><li><a href="https://github.com/Mikubill/sd-webui-controlnet">Mikubill&#x2F;sd-webui-controlnet: WebUI extension for ControlNet</a></li></ul><h3 id="openpose-editor"><a href="#openpose-editor" class="headerlink" title="openpose-editor"></a>openpose-editor</h3><ul><li>直接在WebUI里通过摆放骨骼的方式生成OpenPose图像</li><li><a href="https://github.com/fkunn1326/openpose-editor">Openpose Editor for AUTOMATIC1111’s stable-diffusion-webui</a></li></ul><h3 id="Auto-Photoshop-StableDiffusion-Plugin"><a href="#Auto-Photoshop-StableDiffusion-Plugin" class="headerlink" title="Auto-Photoshop-StableDiffusion-Plugin"></a>Auto-Photoshop-StableDiffusion-Plugin</h3><ul><li>Photoshop插件的后端</li><li><a href="https://github.com/AbdullahAlfaraj/Auto-Photoshop-StableDiffusion-Plugin">AbdullahAlfaraj&#x2F;Auto-Photoshop-StableDiffusion-Plugin: A user-friendly plug-in that makes it easy to generate stable diffusion images inside Photoshop using Automatic1111-sd-webui as a backend.</a></li></ul><h2 id="Textual-Inversion模型"><a href="#Textual-Inversion模型" class="headerlink" title="Textual Inversion模型"></a>Textual Inversion模型</h2><ul><li>引入新的prompt，并将其与已有的prompt关联起来；</li><li>放置在WebUI的<code>embeddings</code>文件夹下；</li></ul><h3 id="EasyNegative"><a href="#EasyNegative" class="headerlink" title="EasyNegative"></a>EasyNegative</h3><ul><li>用于快速屏蔽负面tag</li><li>配合使用：AbyssOrangeMix3、Counterfeit-V2.5</li><li><a href="https://huggingface.co/datasets/gsdf/EasyNegative">gsdf&#x2F;EasyNegative · Datasets at Hugging Face</a></li><li>Prompt：<code>EASYNEGATIVE</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/datasets/gsdf/EasyNegative/resolve/main/EasyNegative.pt</span><br></pre></td></tr></table></figure><h3 id="Ulzzang-6500"><a href="#Ulzzang-6500" class="headerlink" title="Ulzzang-6500"></a>Ulzzang-6500</h3><ul><li>用于生成 韩国女明星式的 人像图片</li><li>配合使用：ChilloutMix</li><li><a href="https://civitai.com/models/8109">Ulzzang-6500 (Korean doll aesthetic) | Stable Diffusion TextualInversion | Civitai</a></li><li>Prompt：<code>ulzzang-6500-v1.1</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://civitai.com/api/download/models/10107</span><br></pre></td></tr></table></figure><h2 id="工具模型"><a href="#工具模型" class="headerlink" title="工具模型"></a>工具模型</h2><ul><li>与绘画不直接相关，主要用于图片后处理、图片内容识别，以及图片放大</li></ul><h3 id="变分自编码器（VAE）"><a href="#变分自编码器（VAE）" class="headerlink" title="变分自编码器（VAE）"></a>变分自编码器（VAE）</h3><ul><li>改变生成结果的概率分布</li><li>部分模型内置VAE，看到<code>_bakedVAE</code>字样可忽略</li><li>最常用的VAE：NovelAI的VAE，下载：<ul><li>通过磁力链接，见上述NovelAI模型章节：<code>stableckpt/animevae.pt</code></li><li>Huggingface上其他项目的转存</li></ul></li><li>放置在WebUI的<code>models/VAE</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://huggingface.co/WarriorMama777/OrangeMixs/resolve/main/VAEs/orangemix.vae.pt</span><br></pre></td></tr></table></figure><h3 id="Deepbooru"><a href="#Deepbooru" class="headerlink" title="Deepbooru"></a>Deepbooru</h3><ul><li>用于识别给出的图片，将图片内容转化为Danbooru的tag</li><li><a href="https://github.com/AUTOMATIC1111/TorchDeepDanbooru">AUTOMATIC1111&#x2F;TorchDeepDanbooru: Pure pytorch implementation of DeepDanbooru</a></li><li>放置在WebUI的<code>models/torch_deepdanbooru</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/AUTOMATIC1111/TorchDeepDanbooru/releases/download/v1/model-resnet_custom_v3.pt</span><br></pre></td></tr></table></figure><h3 id="RealESRGAN（R-ESRGAN4x）"><a href="#RealESRGAN（R-ESRGAN4x）" class="headerlink" title="RealESRGAN（R-ESRGAN4x）"></a>RealESRGAN（R-ESRGAN4x）</h3><ul><li>通用图片放大器，4倍时最佳</li><li><a href="https://github.com/xinntao/Real-ESRGAN">xinntao&#x2F;Real-ESRGAN: Real-ESRGAN aims at developing Practical Algorithms for General Image&#x2F;Video Restoration.</a></li><li>放置在WebUI的<code>models/RealESRGAN</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.1/RealESRNet_x4plus.pth</span><br></pre></td></tr></table></figure><h3 id="RealESRGAN-Anime6B（R-ESRGAN4x-Anime6B）"><a href="#RealESRGAN-Anime6B（R-ESRGAN4x-Anime6B）" class="headerlink" title="RealESRGAN+Anime6B（R-ESRGAN4x + Anime6B）"></a>RealESRGAN+Anime6B（R-ESRGAN4x + Anime6B）</h3><ul><li>专为二次元图片训练的图片放大器，边缘更锐利、速度更快</li><li><a href="https://github.com/xinntao/Real-ESRGAN">xinntao&#x2F;Real-ESRGAN: Real-ESRGAN aims at developing Practical Algorithms for General Image&#x2F;Video Restoration.</a></li><li>放置在WebUI的<code>models/RealESRGAN</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/xinntao/Real-ESRGAN/releases/download/v0.2.2.4/RealESRGAN_x4plus_anime_6B.pth</span><br></pre></td></tr></table></figure><h3 id="GFPGAN、CodeFormer"><a href="#GFPGAN、CodeFormer" class="headerlink" title="GFPGAN、CodeFormer"></a>GFPGAN、CodeFormer</h3><ul><li>用于<strong>真实人脸</strong>的放大和重建</li><li><a href="https://github.com/TencentARC/GFPGAN">TencentARC&#x2F;GFPGAN: GFPGAN aims at developing Practical Algorithms for Real-world Face Restoration.</a></li><li><a href="https://github.com/xinntao/facexlib">xinntao&#x2F;facexlib: FaceXlib aims at providing ready-to-use face-related functions based on current STOA open-source methods.</a></li><li>放置在WebUI的<code>models/GFPGAN</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/TencentARC/GFPGAN/releases/download/v1.3.4/GFPGANv1.4.pth</span><br><span class="line">wget https://github.com/xinntao/facexlib/releases/download/v0.1.0/detection_Resnet50_Final.pth</span><br><span class="line">wget https://github.com/xinntao/facexlib/releases/download/v0.2.2/parsing_parsenet.pth</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/sczhou/CodeFormer">sczhou&#x2F;CodeFormer: [NeurIPS 2022] Towards Robust Blind Face Restoration with Codebook Lookup Transformer</a></li><li>放置在WebUI的<code>models/CodeFormer</code>文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/sczhou/CodeFormer/releases/download/v0.1.0/codeformer.pth</span><br></pre></td></tr></table></figure><h3 id="ControlNet"><a href="#ControlNet" class="headerlink" title="ControlNet"></a>ControlNet</h3><ul><li>用于部分控制Diffusion网络的参数，例如<ul><li>固定生成图片的人物动作（OpenPose）</li><li>通过精细线稿生成图片（Canny）</li><li>通过简笔画生成图片（Scribble）</li><li>通过景深生成图片（Depth）</li><li>…</li></ul></li><li><a href="https://github.com/lllyasviel/ControlNet">lllyasviel&#x2F;ControlNet: Let us control diffusion models!</a></li><li>需要配合插件<code>sd-webui-controlnet</code>使用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ControlNet差分模型，放置在WebUI的extensions/sd-webui-controlnet/models文件夹下</span></span><br><span class="line"><span class="comment"># Canny</span></span><br><span class="line">wget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_canny-fp16.safetensors</span><br><span class="line"><span class="comment"># OpenPose</span></span><br><span class="line">wget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_openpose-fp16.safetensors</span><br><span class="line"><span class="comment"># Scribble</span></span><br><span class="line">wget https://huggingface.co/webui/ControlNet-modules-safetensors/resolve/main/control_scribble-fp16.safetensors</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenPose需要独立的数据模型，放置在WebUI的models/openpose文件夹下</span></span><br><span class="line">wget https://huggingface.co/lllyasviel/ControlNet/resolve/main/annotator/ckpts/body_pose_model.pth</span><br><span class="line">wget https://huggingface.co/lllyasviel/ControlNet/resolve/main/annotator/ckpts/hand_pose_model.pth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="AI绘画" scheme="http://wiki.zhouweitong.site/categories/AI%E7%BB%98%E7%94%BB/"/>
    
    
    <category term="速查表" scheme="http://wiki.zhouweitong.site/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    
    <category term="Stable Diffusion" scheme="http://wiki.zhouweitong.site/tags/Stable-Diffusion/"/>
    
    <category term="Novel AI" scheme="http://wiki.zhouweitong.site/tags/Novel-AI/"/>
    
    <category term="模型与插件" scheme="http://wiki.zhouweitong.site/tags/%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>mangle与demangle</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/mangle%E4%B8%8Edemangle/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/mangle%E4%B8%8Edemangle/</id>
    <published>2023-02-25T13:20:00.000Z</published>
    <updated>2023-02-25T13:27:36.805Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>Example.cc：测试程序</li><li>Example.s：使用<code>g++ -S</code>编译后的汇编文件</li><li>观察函数名，发现似乎函数名经过了某种编码<ul><li><code>void Test::func_1()</code>：<code>_ZN4Test6func_1Ev</code></li><li><code>static std::string func_2(int in_a)</code>：消失<ul><li>原因：inline</li></ul></li><li><code>Test* Test::func_3(double in_b)</code>：<code>_ZN4Test6func_3Ed</code></li><li><code>int test_2(std::string in_c, uint16_t in_d)</code>：<code>_Z6test_2NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEt</code></li></ul></li><li>原因：mangle<ul><li>因为C++可以函数重载和重写引入的功能</li><li>本质就是对函数的命名空间（比如哪个类或者哪个namespace）、函数名、函数参数进行编码<ul><li>注意：不编码函数返回值</li></ul></li><li>可以被解码</li><li>不同编译器编码规则不同，一般以g++为例</li></ul></li><li>解码：demangle<ul><li>使用工具 c++filt</li><li>包含在binutils软件包中</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>单元测试与模糊测试</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</id>
    <published>2023-02-25T13:00:00.000Z</published>
    <updated>2023-02-25T13:27:36.805Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>单元测试：Unit Test，特点是作者需要指定正确的输入数据和输出结果</li><li>单元测试的目的在于验证逻辑正确性</li><li>模糊测试：Fuzz Test&#x2F;Monkey Test，特点是由程序库&#x2F;其他工具随机生成输入数据，通过规则校验输出结果</li><li>模糊测试的目的在于验证代码鲁棒性</li></ul><h2 id="单元测试库：Gtest-x2F-Gmock"><a href="#单元测试库：Gtest-x2F-Gmock" class="headerlink" title="单元测试库：Gtest&#x2F;Gmock"></a>单元测试库：Gtest&#x2F;Gmock</h2><ul><li><code>vcpkg install gtest:x64-windows</code></li><li>需要新建项目，或者新建文件<ul><li>[[TODO]]</li></ul></li></ul><h2 id="模糊测试库-LibFuzzer"><a href="#模糊测试库-LibFuzzer" class="headerlink" title="模糊测试库-LibFuzzer"></a>模糊测试库-LibFuzzer</h2><p>[[TODO]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>其他规则</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%85%B6%E4%BB%96%E8%A7%84%E5%88%99/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%85%B6%E4%BB%96%E8%A7%84%E5%88%99/</id>
    <published>2023-02-25T12:50:00.000Z</published>
    <updated>2023-02-25T12:53:48.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>不能在类的析构函数中抛出异常；</li><li>建议父类的析构函数均声明为虚函数；建议有其他虚函数的类其析构函数也要声明为虚函数；</li><li>定义函数时，要做到想清楚以下几点：<ul><li>先验条件（Preconditions）：函数需要什么样的输入？<ul><li>例如：sqrt(x)，x&gt;&#x3D;0</li></ul></li><li>后验条件（Postconditions）：函数保证提供什么样的输出？<ul><li>例如：sin(x)一定返回(-1, 1)</li></ul></li><li>不变量（Invariant）：函数不能改变哪些东西？<ul><li>例如：sin(x)中不会改变x的值</li></ul></li><li>副作用（Side effect）：函数改变了哪些它作用域以外的东西？<ul><li>例如：file.write()改变了写入的文件内容</li></ul></li><li>目的（Propose）：你写的函数是否有清晰的目的？函数是否达到了它的目的？<ul><li>例如：ChangeStudentName()：写它是为了修改学生姓名，它也确实修改了学生姓名</li></ul></li><li>函数名（Name）：函数名是否清晰地传达了函数的目的？<ul><li>例如：Name()一般来说就不是一个好名字——对“Name”做了什么？</li></ul></li><li>函数参数名（Parameter）：函数参数名是否清晰易懂不会混淆？<ul><li>例如：ChangeStudentName(a, b, c)：a、b、c具体是什么东西？</li></ul></li></ul></li><li>不要在仿函数的<code>operator()</code>调用中修改数据成员，即保持其无状态（Stateless）；</li><li>单行定义单个变量时，<code>&amp;</code>或<code>*</code>应紧贴类型名：<code>int* a;</code></li><li>单行定义多个变量时，<code>&amp;</code>或<code>*</code>应紧贴变量名：<code>int *a, &amp;b;</code></li><li>为避免出现冲突，头文件不应该包含<code>using</code>语句；</li><li>[[TODO]]</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>函数参数规则</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%84%E5%88%99/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%84%E5%88%99/</id>
    <published>2023-02-25T11:50:00.000Z</published>
    <updated>2023-02-25T12:00:12.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>大体上可以分为三种传递类型：传值、传指针和传引用<ul><li>传值：新建临时变量（形参名即是变量名），使用赋值将外部的参数值传递给临时变量</li><li>传指针：指针本身是基本类型（int或int64）进行传值，而不涉及到指针指向的内存区域的复制</li><li>传引用：相当于给外部的参数值设置单独的别名和访问权限，本质也是传指针，可看作是传指针的语法糖</li></ul></li><li>三种传递类型的优缺点<ul><li>传值：最直接，而且临时变量与外部变量完全无关；复制开销很大，尤其是对于对象等较大的变量时；</li><li>传指针：能节省很大开销，C语言也可以使用；还是发生了传值过程，使用不方便；</li><li>传引用：几乎节省全部开销，能很好与C++的左右值和重载功能相结合；不是所有场合都适合传引用；</li></ul></li><li>综合各优缺点，得出的使用规则：<ul><li>基本类型传值、传引用和传指针均可，但必须是单个变量等级的传递</li><li>对象的传递，包括标准模板库生成的对象，必须传递引用，除非是下面的情况：<ul><li>在需要兼容性的情况下（如Windows API编程）可能不允许传递引用，此时对非基本类型的数据应首先考虑传递指针</li></ul></li></ul></li><li>概括：传引用（常用）-&gt; 传指针（兼容性）-&gt; 传值（基本类型）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Google编码规范</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/Google%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/Google%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2023-02-25T11:00:00.000Z</published>
    <updated>2023-02-25T11:44:34.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="好的标准？"><a href="#好的标准？" class="headerlink" title="好的标准？"></a>好的标准？</h2><ul><li>标准容易记住，也容易实践；</li><li>积极维护和更新，确保标准符合业务发展和技术发展；</li><li>多消耗<strong>写代码者</strong>的精力，确保<strong>读代码者</strong>的体验；</li><li>标准要整体一致，方便写自动化的格式检查工具；</li><li>参照国际标准，但不需要全盘接纳，可以禁用某些标准库并使用更好用、更统一的第三方库；</li><li>不要使用风险较大的语言功能；</li><li>在优化性能时，允许降低代码可读性、允许使用危险功能；</li><li>避免复杂的类结构和其他数据结构；</li><li>代码规模越大，注意的事情越多，标准也会越多；</li></ul><h2 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h2><ul><li>使用主流C++版本（C++17）开发</li><li>C++20、C++23还在被编译器实现中，部分已经稳定的功能可以使用</li><li>不要使用特定编译器的独有功能，除非特殊说明并附带详细注释</li></ul><h2 id="头文件和文件头"><a href="#头文件和文件头" class="headerlink" title="头文件和文件头"></a>头文件和文件头</h2><ul><li>源码文件建议统一以<code>.cc</code>结尾</li><li>每一个源码文件都应该对应一个与其同名的<code>.h</code>文件<ul><li>单元测试文件除外</li><li>小程序（行数很少，且包含<code>main()</code>函数）除外</li></ul></li><li>头文件应彼此独立<ul><li>需要带有<code>#define</code>类似的 包含保护，避免循环包含 问题</li><li>头文件内应include所有 被该头文件本身 和 被该头文件对应的.cc依赖的 所有其他头文件</li><li>例外：如果是将include用作文本插入，则待插入的文本应单独存为.inc文件，然后在适当位置#include “xxx.inc”</li></ul></li><li>包含保护：#define 项目路径（每一个子路径用下划线分割）_文件名_H_<ul><li>例如：<code>#define SRC_WEB_HTTP_H_</code>，即<code>src/web/http.h</code></li></ul></li><li>不要使用前置声明</li><li>函数小于10行，或必须使用内联函数时，才应该在头文件内定义内联函数</li><li>#include的顺序<ul><li>第一位：优先头文件，例如a.cc对应a.h，则这个位置应该放a.h</li><li>第二位：C系统头，包括C自带的头文件和操作系统等使用C语言格式的头文件（系统路径），可加extern关键字</li><li>第三位：C++系统头，包括C++自带头文件、STL、其他C++库的头文件（系统路径）等</li><li>第四位：其他库的.h文件（不在系统路径）</li><li>第五位：同项目的.h文件（不在系统路径，且除去优先头文件）</li></ul></li><li>[[TODO]]</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/categories/C/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="编码规范" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>CMake基础</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/CMake/CMake%E5%9F%BA%E7%A1%80/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/CMake/CMake%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-25T08:00:00.000Z</published>
    <updated>2023-02-25T14:44:45.514Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li>跨平台的“编译器所需文件的生成器”</li><li>Make是什么<ul><li>相当于自动执行多个文件的编译与链接</li><li>只需一个配置文件，就可根据配置文件自动生成命令然后执行</li><li>同时应用了增量编译的思想：文件没有做出修改就不会重新编译</li><li>只显示自动生成的编译命令而不运行：<code>make --dry-run</code></li></ul></li><li>Make有什么缺点？<ul><li>语法不够复杂，许多高级功能实现不了</li><li>GNU系软件，没有官方的对Windows的支持</li><li>与GCC结合紧密，但与其他编译器结合可能会出现问题</li><li>需要明确指明项目与项目间（或项目与子模块）的依赖关系</li></ul></li><li>CMake解决了这些问题<ul><li>高级和复杂的语法，适应多种情况</li><li>自动检测源文件和头文件的关联</li><li>针对不同平台的不同编译器生成不同的项目文件&#x2F;编译命令</li></ul></li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>需要将配置写在CMakeLists.txt里</li></ul><h3 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h3><ul><li><p>源码混杂编译：In-Source，部分编译文件（如Makefile等）会生成在根目录下</p><ul><li><code>cmake .</code></li></ul></li><li><p>源码分离编译（最常用）：Out-of-Source</p><ul><li>常常是在源码目录里建build文件夹，做shell的工作目录（Working Directory）</li><li>所有编译相关的文件均会放置在build子目录下</li><li>删除build文件夹即可完全重新编译</li><li><code>cd build/ &amp;&amp; cmake ..</code></li></ul></li></ul><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li>对于C++来说：<ul><li>C++是强声明的语言，在没有声明时 是不知道一个名字是变量、函数还是类的</li><li><code>#include</code>是预处理命令，本质上就是文件的插入，相当于把被include的文件的内容复制粘贴过来</li><li>因此会遇到 重复定义问题、循环包含问题 和 include顺序不同导致编译结果不一样 等问题</li><li>解决办法：<ul><li>include顺序固定</li><li>使用宏<code>#pragma once</code></li><li>使用宏<code>#ifdef</code>、<code>#ifndef</code></li><li>使用模块（C++20）</li></ul></li><li>两种include的语法<ul><li>双引号 <code>#include &quot;&quot;</code>：先找工作目录，再找系统目录</li><li>尖括号 <code>#include &lt;&gt;</code>：直接找系统目录</li><li>为什么有双引号include方式还要保留尖括号方式？：可以避免工作目录内同名的其他文件</li></ul></li><li><code>&lt;cxxx&gt;</code>和<code>&lt;xxx.h&gt;</code>没有必然联系，有些头文件中会检测当前语言是否为C++，是的话自动添加<code>extern &quot;C&quot;&#123;&#125;</code></li></ul></li></ul><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ul><li>分为静态库和动态库</li><li>静态库链接时会直接插入到程序中，动态库则只会向程序中插入“插桩”代码（PLT表）</li><li>动态链接库的查找位置<ul><li>Windows：程序同文件夹 -&gt; PATH内目录（用户PATH -&gt; 系统PATH）</li><li>*nix：ELF程序的RPATH -&gt; <code>/usr/lib</code> -&gt; <code>/lib</code></li></ul></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li><code>cmake --version</code>：当前CMake版本号</li><li><code>cmake -H&lt;path1&gt; -B&lt;path2&gt;</code>：使用CMake生成文件。在path1中查找CMakeLists.txt，在path2子目录中存放所有编译文件</li><li><code>cmake -D&lt;flag&gt;</code>：设置CMake编译选项</li><li><code>cmake -G&lt;generator&gt;</code>：切换CMake生成针对哪个编译器的项目文件</li><li>[[TODO]]</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数名是不区分大小写的，但变量名&#x2F;关键字是区分大小写的。关键字一般都是大写，变量名（除系统定义的之外）建议小写</li><li><code>project(xxx)</code>：指定项目名<ul><li>设置项目语言：<code>project(xxx LANGUAGES CXX)</code>；<code>CXX</code>：即C++</li></ul></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(hello_world LANGUAGES CXX)</span><br></pre></td></tr></table></figure><ul><li><code>cmake_minimum_required(VERSION xxx)</code>：指定最低CMake版本号</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSON <span class="number">3.22</span>)</span><br></pre></td></tr></table></figure><ul><li><code>add_executable(AAA, BBB)</code>：把BBB文件编译成AAA，AAA是目标文件名</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello.elf hello.cc)</span><br></pre></td></tr></table></figure><ul><li><code>set(AAA, BBB)</code>：把AAA变量（定义并）内容设置为BBB</li><li><code>file()</code>：查找文件，并将结果写入变量</li><li><code>target_include_directories()</code>：相当于<code>cmake -I</code>，设置头文件查找文件夹</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的语句相当于 -I ./include</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">target</span></span><br><span class="line">    PRIVATE</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="如何给项目添加多个文件？"><a href="#如何给项目添加多个文件？" class="headerlink" title="如何给项目添加多个文件？"></a>如何给项目添加多个文件？</h2><p>将多个文件编译为一个目标时，可使用如下方法</p><ul><li>直接在<code>add_executable</code>里指定文件，<code>add_executable(xxx a.cc b.cc c.h)</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码文件顺序固定</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> </span><br><span class="line">    main.cc</span><br><span class="line">    hello.cc</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>使用变量，不推荐。<code>set(YYY a.cc b.cc c.h) add_executable(XXX $&#123;YYY&#125;)</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以定义单行的变量</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES main.cc)</span><br><span class="line"><span class="comment"># 也可以定义多行的变量</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">        main.cc</span><br><span class="line">        hello.cc</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 定义好的变量可以在接下来的语句中使用</span></span><br><span class="line"><span class="comment"># 比如添加编译目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"><span class="comment"># 注意，现代CMake中已不推荐使用这种变量的方式</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>file()</code>函数动态检测，即使用通配符的自动添加，不推荐：顺序不固定，且易丢失文件。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GLOB：globbing表达式的结果形成列表</span></span><br><span class="line"><span class="comment"># SOURCES：结果写入SOURCES变量</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCES <span class="string">&quot;*.cc&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>使用<code>$&#123;xxx&#125;</code>来使用变量</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>PROJECT_NAME</code>：由<code>project()</code>产生</li><li><code>CMAKE_SOURCE_DIR</code>：源码目录</li><li><code>CMAKE_BINARY_DIR</code>：编译目录</li><li>子文件夹相关变量<ul><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：当前源码目录</li><li><code>CMAKE_CURRENT_BINARY_DIR</code>：当前编译目录</li></ul></li><li>子模块相关变量<ul><li><code>PROJECT_SOURCE_DIR</code>：当前项目源码目录</li><li><code>PROJECT_BINARY_DIR</code>：当前项目编译目录</li></ul></li></ul><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><ul><li>可以将不同模块的源码放置在不同的子目录下<ul><li>头文件除外。头文件应当放置在同一个目录下，如<code>include/</code></li><li>头文件的目录也可以拥有子目录，如<code>include/hello/</code></li></ul></li><li>主项目<code>CMakeLists.txt</code><ul><li><p><code>add_library()</code>：添加子模块，为库</p><ul><li>STATIC：指定库的类型是静态链接库</li></ul></li><li><p><code>target_include_directories()</code>：设置包含子模块的头文件文件夹</p></li><li><p><code>target_link_libraries()</code>：将库链接到 目标ELF文件 中</p></li></ul></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello_library STATIC</span><br><span class="line">    hello/hello.cc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PUBLIC：library自己和引用该library的程序同时能够访问这些头文件</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_library</span><br><span class="line">    PUBLIC</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处的源码文件名不需要包括子模块中的文件名</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello.elf</span><br><span class="line">    main.cc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello.elf</span><br><span class="line">    PRIVATE</span><br><span class="line">        hello_library</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="头文件在子文件夹内怎么办？"><a href="#头文件在子文件夹内怎么办？" class="headerlink" title="头文件在子文件夹内怎么办？"></a>头文件在子文件夹内怎么办？</h2><ol><li>有如下的子模块和文件</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.cc</span><br><span class="line">CMakeLists.txt</span><br><span class="line">mylib/hello.cc</span><br><span class="line">mylib/hello.h</span><br></pre></td></tr></table></figure><p>A. 可以不在<code>CMakeLists.txt</code>文件中写<code>target_include_directories()</code></p><ul><li><code>main.cc</code>中可以按如下方式引入<code>mylib/hello.h</code>：<code>#include &quot;mylib/hello.h&quot;</code></li></ul><p>B. 也可以将<code>target_include_directories()</code>写成</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(hello_library</span><br><span class="line">    PUBLIC</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/mylib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>main.cc</code>中可以按如下方式引入<code>mylib/hello.h</code>：<code>#include &quot;hello.h&quot;</code>或是<code>#include &lt;hello.h&gt;</code></li></ul><ol start="2"><li>有如下的子模块和文件</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.cc</span><br><span class="line">CMakeLists.txt</span><br><span class="line">mylib/hello.cc</span><br><span class="line">include/mylib/hello.h</span><br></pre></td></tr></table></figure><ul><li>如下编写<code>target_include_directories()</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(hello_library</span><br><span class="line">    PUBLIC</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>main.cc</code>中按如下方式引入<code>mylib/hello.h</code>：<code>#include &quot;mylib/hello.h&quot;</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;cs</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    <category term="CMake" scheme="http://wiki.zhouweitong.site/categories/C/CMake/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="CMake" scheme="http://wiki.zhouweitong.site/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>P1-随机事件与概率</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/P1_%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/P1_%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/</id>
    <published>2023-02-24T15:00:00.000Z</published>
    <updated>2023-02-24T15:25:21.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="随机试验"><a href="#随机试验" class="headerlink" title="随机试验"></a>随机试验</h2><p>[[TODO]]</p><h2 id="样本空间"><a href="#样本空间" class="headerlink" title="样本空间"></a>样本空间</h2><p>[[TODO]]</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li>基本事件</li><li>必然事件</li><li>不可能事件</li></ul><h2 id="事件关系"><a href="#事件关系" class="headerlink" title="事件关系"></a>事件关系</h2><ul><li>包含</li><li>相等</li><li>互斥</li><li>对立</li></ul><h2 id="事件运算"><a href="#事件运算" class="headerlink" title="事件运算"></a>事件运算</h2><ul><li>积事件：集合取交<ul><li>取公共部分</li><li>互斥的积为空集</li></ul></li><li>和事件：集合取并<ul><li>取所有覆盖部分</li><li>对立的和为全集</li></ul></li><li>差事件<ul><li>取”一个抠掉另一个后的剩余部分“</li></ul></li></ul><h2 id="运算规律"><a href="#运算规律" class="headerlink" title="运算规律"></a>运算规律</h2><ul><li>不存在“消去率”<ul><li>AB&#x3D;AC并不是B&#x3D;C</li></ul></li><li>交换率</li><li>分配率</li><li>对偶率<ul><li>not(A and B) &#x3D; not(A) or not(B)</li><li>not(A or B) &#x3D; not(A) and not(B)</li><li>not(A - B) &#x3D; not(A) or B</li></ul></li></ul><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><ul><li>性质</li><li>条件概率<ul><li>计算公式： P(B|A) &#x3D; P(AB)&#x2F;P(A)</li><li>用于缩减样本空间</li></ul></li><li>独立性<ul><li>与互斥区分<ul><li>互斥：P(AB)&#x3D;0</li><li>独立：P(AB)&#x3D;P(A)P(B)</li><li>非互斥非独立：P(A or B)&#x3D;P(A)+P(B)-P(AB)</li></ul></li><li>不可能事件与任意其他事件既独立又互斥</li><li>A包含B时，A、B独立</li><li>P(A)&#x3D;0时，P(AB)&#x3D;0</li><li>P(A)&#x3D;1时，P(AB)&#x3D;P(B)</li><li>三个事件相互独立：P(ABC)&#x3D;P(A)P(B)P(C)</li></ul></li><li>五大公式<ul><li>加法公式</li><li>减法公式</li><li>乘法公式</li><li>全概率公式</li><li>贝叶斯公式</li></ul></li><li>概率型<ul><li>古典型概率<ul><li>有限</li><li>等可能</li></ul></li><li>几何型概率</li></ul></li><li>n重泊努利试验<ul><li>从中得到二项分布公式</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>不可能事件（空集）的对立事件（取反）是整个事件集合（全集）</li><li>概率不能得出事件的结论，事件可以得出概率的结论<ul><li>概率为0的事件不一定是不可能事件，不可能事件的概率一定是0</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="数学" scheme="http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="概率论与数理统计" scheme="http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
    <category term="数学" scheme="http://wiki.zhouweitong.site/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="http://wiki.zhouweitong.site/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="概率论" scheme="http://wiki.zhouweitong.site/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    <category term="数理统计" scheme="http://wiki.zhouweitong.site/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="随机事件" scheme="http://wiki.zhouweitong.site/tags/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>UML图</title>
    <link href="http://wiki.zhouweitong.site/wiki/CPlusPlus/UML%E5%9B%BE/"/>
    <id>http://wiki.zhouweitong.site/wiki/CPlusPlus/UML%E5%9B%BE/</id>
    <published>2023-02-24T13:00:00.000Z</published>
    <updated>2023-02-24T15:03:24.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>UML包括许多种类的图，其中使用最广泛的就是类图（Class Diagram）和时序图（Sequence Diagram）。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li>表达类（Class）的结构、类与类之间关系和包（Package）的结构的图；</li></ul><h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h3><ul><li><p>属性（Attribute）：同一个类中的成员变量；<code>&lt;保护符&gt; &lt;属性名&gt;: &lt;属性类型&gt;</code>；</p><ul><li>例如：<code>- name: std::string</code></li></ul></li><li><p>操作（Operation）：同一个类中的成员方法；<code>&lt;保护符&gt; &lt;方法名&gt;(): &lt;返回值类型&gt;</code>；</p><ul><li>例如：<code>+ getName() : std::string</code></li></ul></li><li><p>三种详细等级</p><ul><li>概念型：只写类名 <img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224213326219.png" alt="image-20230224213326219"></li><li>标准型（说明型）：类名、属性名、重要的方法名以及成员可见性。此时可以省略属性和方法的类型。 <img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224213720917.png" alt="image-20230224213720917"></li><li>实现型，怎么详细怎么写，包括类名，属性名、属性类型，所有方法的方法名、方法形参、方法形参的出入类型、方法的返回值类型，成员可见性等。  <img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224213744120.png" alt="image-20230224213744120"></li></ul></li><li><p>四种成员可见性（Visibility）：同 面向对象编程语言中类的成员保护符；</p><ul><li>public：公开，<code>+</code></li><li>private：私有，<code>-</code></li><li>protected：受保护的，<code>#</code></li><li>package：在同一个包内，<code>~</code></li></ul></li><li><p>抽象方法：同面向对象编程语言中类的抽象方法，使用斜体表示 <img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224213929268.png" alt="image-20230224213929268"></p></li><li><p>成员方法的形参：<code>&lt;参数方向&gt; &lt;参数名&gt;: &lt;参数类型&gt;</code></p></li><li><p>三种参数方向类型</p><ul><li>in：仅供输入，类似于函数的普通形参，例如：<code>int test(int a)</code> 此处的 <code>a</code>。</li><li>out：仅供输出，类似于函数将指针&#x2F;引用作为形参，且函数内只修改、不读取该指针&#x2F;引用的值。</li><li>inout：</li><li>既是输入又是输出，类似于函数将指针&#x2F;引用作为形参，读取了该指针&#x2F;引用的值，修改后再写回。</li></ul></li><li><p>参数或属性拥有默认值：在参数后加上<code>=&lt;默认值&gt;</code>即可；  <img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224225816388.png" alt="image-20230224225816388"></p></li><li><p>抽象类&#x2F;接口：类名上方标<code>&lt;&lt;abstract&gt;&gt;</code>&#x2F;<code>&lt;&lt;interface&gt;&gt;</code>；  <img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224225921662.png" alt="image-20230224225921662"></p></li><li><p>对象图</p><ul><li>用于表示已实例化的类，即对象</li><li>标题带下划线，且会用冒号指明实例化自哪个类（对象名: 类名）</li><li>等号右侧的值是实际值&#x2F;期待返回的实际值，而不是默认值</li><li>对象间关系只有关联、依赖、共享聚集和组合聚集</li><li>对象图常常以独立的图的形式出现（即一张图都是对象）</li></ul></li></ul><p><img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224230012159.png" alt="image-20230224230012159"></p><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><ul><li>关联（Association）<ul><li>单纯的一个类和另一个类有数量上的松散关系，两个类彼此是独立的</li><li>这种联系是松散的而不是逻辑的（即不是一个包含另一个或一个继承另一个之类的强联系）</li><li>举例：飞机关联航线，航线关联飞机</li><li>线型：实线，无箭头</li><li>线上写联系的简要描述（文字描述&#x2F;函数名），下同</li><li>数量关系，下同<ul><li>1：一对一</li><li>n：一对n</li><li>0…1：可选，即没有或有1个</li><li>0…n：至少0个（没有），至多n个</li><li>0…*：任意多个</li><li>1…*：至少有1个</li><li>m…n：至少有m个，至多有n个</li></ul></li></ul></li></ul><p><img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224230210668.png" alt="image-20230224230210668"></p><ul><li><p>单项关联（Unidirectional Association）</p><ul><li>只有一个类与另一个类有数量上的逻辑关系</li><li>举例：提现请求与支付宝账号</li><li>类型：实线，普通箭头，箭头从一个类出发指向与其关联的另一个类</li></ul></li><li><p>继承（Inheritance）</p><ul><li>同C++中类的继承，子类获得父类的部分属性和方法并可以重载</li><li>举例：老师继承自人</li><li>类型：实现，空心三角箭头，由子类指向父类</li><li>很少见到继承的数量关系</li></ul></li><li><p>实现（Implement）</p><ul><li>同C++&#x2F;Golang中的抽象类&#x2F;接口的实现，且一般只在有抽象类&#x2F;接口时才会使用</li><li>举例：正方形类实现了形状抽象类</li><li>类型：虚线，空心三角箭头，指向被实现的抽象类&#x2F;接口</li><li>很少见到实现的数量关系</li></ul></li><li><p>依赖（Dependency）</p><ul><li>表示一个类与另一个类有简单的依赖关系，一般是方法上的依赖</li><li>举例：学生类的阅读方法依赖书类</li><li>类型：虚线，普通箭头，指向被依赖的类</li></ul></li><li><p>共享聚集（Aggregation）</p><ul><li>类互相独立但可以聚集为一个新的类。当这个类消失时，聚集成它的类不会消失</li><li>举例：课桌类可由椅子类和桌子类聚集。课桌拆散时桌子、椅子还在</li><li>类型：实线，普通箭头，空心菱形线头。线头在聚集成的类处，箭头指向各个子类</li></ul></li><li><p>组合聚集（Combination）</p><ul><li>子类互相独立但必须依存于组合成的类存在。当组合成的类消失时，这些子类也会一并消失</li><li>举例：公司可由公司的各个部门组合。公司解散后各部门也不复存在</li><li>类型：实线，普通箭头，实心菱形线头。线头在组合成的类处，箭头指向各个子类</li></ul></li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>注释<ul><li>一般放置在图旁边（或包范围内），起解释说明作用；</li></ul></li></ul><p><img src="/wiki/CPlusPlus/UML%E5%9B%BE/image-20230224230250786.png" alt="image-20230224230250786"></p><ul><li>包</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="C++" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="UML" scheme="http://wiki.zhouweitong.site/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>SVN、Git区别</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN%E3%80%81Git%E5%8C%BA%E5%88%AB/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN%E3%80%81Git%E5%8C%BA%E5%88%AB/</id>
    <published>2023-02-24T07:00:00.000Z</published>
    <updated>2023-02-24T13:34:03.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>Git：分布式的（Decentralized）版本控制软件</li><li>SVN：中心化的（Centralized）版本控制软件</li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li>优点：<ul><li>去中心化<ul><li>避免单点故障（服务器下线）导致Repo无法访问；</li><li>不需要服务器也可完成大多数功能；</li><li>可以用本地Git Repo初始化服务器上的Git Repo；</li></ul></li><li>Merge&#x2F;Rebase流程完善<ul><li>适合大量成员共同在单个Repo内开发；</li></ul></li></ul></li><li>缺点：<ul><li>学习曲线陡峭，非计算机专业人士入门困难；</li><li>即使有Git LFS，Git对大文件的支持仍然一般；</li><li><strong>权限控制粒度不细</strong><ul><li>一个用户能访问Repo，就能访问Repo中的所有文件和历史；</li><li>一个用户Clone了完整的Repo，就能将它放到某个Git服务器上开始分析和分发；</li></ul></li></ul></li></ul><h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><ul><li>优点<ul><li>原生支持大文件版本管理，性能高；</li><li>功能简单直接，入门难度低；<ul><li>各SVN GUI软件更加完善、人性化</li></ul></li><li>与Git的正向Delta不同，SVN采用反向Delta，降低存储占用、提升拉取性能；</li><li>SVN本体十分稳定，更新及出现安全问题概率低，有利于进行二次开发；</li><li>权限控制完善<ul><li>支持用户名+密码、用户名+令牌（Token）、LDAP等多种不同认证方式的同时，还可结合Web服务器的功能提供更多验证方式；</li><li>可设置用户和用户组，读写权限可精确到Repo下的单个文件</li></ul></li></ul></li><li>缺点<ul><li>中心化<ul><li>服务器出现问题（单点故障）会导致开发无法继续，或数据（提交历史等）永久丢失；</li><li>可以改造为“多中心”模式：增加类似“服务器间同步”的功能，或使用特殊的分布式文件系统储存服务端文件；<ul><li>例如：<a href="https://www.wandisco.com/#svnmsplus">WANdisco</a> 与 <a href="https://www.visualsvn.com/">VisualSVN</a></li></ul></li></ul></li><li>必须有服务器的存在<ul><li>即使是本地Repo进行开发，也要启动SVN Server；</li><li>失去服务器的情况下操作受限；</li><li>大量成员共同在单个Repo内开发时，服务器有持续较高负载；</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="版本控制" scheme="http://wiki.zhouweitong.site/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="SVN" scheme="http://wiki.zhouweitong.site/tags/SVN/"/>
    
    <category term="Git" scheme="http://wiki.zhouweitong.site/tags/Git/"/>
    
    <category term="版本控制" scheme="http://wiki.zhouweitong.site/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    <category term="Version Control" scheme="http://wiki.zhouweitong.site/tags/Version-Control/"/>
    
    <category term="优缺点" scheme="http://wiki.zhouweitong.site/tags/%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>计组笔记_指令、存储</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_%E6%8C%87%E4%BB%A4%E3%80%81%E5%AD%98%E5%82%A8/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_%E6%8C%87%E4%BB%A4%E3%80%81%E5%AD%98%E5%82%A8/</id>
    <published>2023-02-23T13:00:00.000Z</published>
    <updated>2023-02-27T05:18:19.692Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><ul><li>CPU控制器的主要功能之一：解析指令，协调各部件工作</li><li>一台计算机所有指令的集合称为该计算机的指令系统，也称指令集<ul><li>例如：x86、arm、mips</li></ul></li><li>一条指令通常包括两个部分<ul><li>操作码：要做什么</li><li>地址码：要对谁操作</li></ul></li><li>依照地址码数目分类<ul><li>零地址指令<ul><li>不需要操作数的情况：如nop（空指令）、hlt（停机）等<ul><li>$ OP $</li></ul></li><li>与栈配合使用，数据已预先压在栈顶：如syscall（系统调用）</li></ul></li><li>单地址指令<ul><li>只需要一个操作数：加1、减1、取反等<ul><li>$ OP(x) \rightarrow x $</li><li>x：数据的地址，(x)：地址中的内容（间接访问）</li><li>三次访存：读OP、读x、写x</li></ul></li><li>需要两个操作数，另一个操作数在栈上&#x2F;寄存器中<ul><li>假设隐含在ACC中</li><li>$ (ACC)OP(x) \rightarrow ACC $</li><li>数据压回栈&#x2F;写回寄存器</li><li>两次访存：读OP、读x，ACC是寄存器不算访存</li></ul></li></ul></li><li>二地址指令<ul><li>需要两个操作数，常用于逻辑运算、算术运算等</li><li>$ (A1)OP(A2) \rightarrow A1 $</li><li>数据写回A1地址指向的区域</li><li>四次访存：读OP、读A1、读A2、写A1</li></ul></li><li>三地址指令<ul><li>需要三个操作数，常用于逻辑运算、算术运算</li><li>$ (A1)OP(A2) \rightarrow A3 $</li><li>数据写回新地址A3</li><li>四次访存：读OP、读A1、读A2、写A3</li></ul></li><li>四地址指令<ul><li>与三地址指令不同点在于，新增加了一个“下一条指令的地址“操作数</li><li>$ (A1)OP(A2) \rightarrow A3, A4 $</li></ul></li><li>…… <em>以此类推</em></li></ul></li><li>按长度分类<ul><li>指令字长<ul><li>整个指令的长度可以发生变化<ul><li>定长指令字结构</li><li>变长指令字结构</li></ul></li><li>和操作码长度、操作数长度、操作数个数都有关</li></ul></li><li>操作码长<ul><li>操作码本身的长度可以发生变化<ul><li>定长操作码<ul><li>操作码n位，最多$ 2^n $种</li><li>译码器设计简单，灵活性低</li></ul></li><li>可变长操作码<ul><li>译码器设计复杂，灵活性高</li></ul></li></ul></li></ul></li><li>机器字长<ul><li>进行一次整数运算时所能处理的二进制位数</li><li>即ALU位数</li></ul></li><li>存储字长<ul><li>主存一个存储单元的二进制位数</li><li>即MDR位数</li></ul></li></ul></li><li>按操作类型分类<ul><li>数据传送类<ul><li>内存到寄存器</li><li>寄存器到内存</li></ul></li><li>运算类<ul><li>算术逻辑操作</li><li>移位操作</li></ul></li><li>程序控制类：转移&#x2F;跳转操作<ul><li>实现程序执行流程的变化</li><li>使PC寄存器值发生改变</li></ul></li><li>输入输出类</li></ul></li></ul><h3 id="扩展操作码"><a href="#扩展操作码" class="headerlink" title="扩展操作码"></a>扩展操作码</h3><ul><li>是一种固定指令字长、可变操作码长的指令结构</li><li>以指令固定长为16位，零、一、二、三地址指令均15个为例<ul><li>给指令位分段<ul><li>$ 15&#x3D;2^4-1 $，零地址指令至少需要4个二进制位</li><li>$ 16-15&#x3D;1 $，这一个4位编码可用于表示“扩展”——指令码长于4位</li></ul></li><li>构造指令编码<ul><li>前缀0000～1110为三地址操作码</li><li>前缀1111留作扩展位，表示此时操作码大于4位</li><li>前缀1111 0000～1111 1110为二地址操作码</li><li>前缀1111 1111留作扩展位，表示此时操作码大于8位</li><li>前缀1111 1111 0000～1111 1111 1110为一地址操作码</li><li>前缀1111 1111 1111保留</li><li>1111 1111 1111 0000～1111 1111 1111 1110为零地址操作码</li><li>1111 1111 1111 1111未用</li></ul></li></ul></li><li>习题例子 <img src="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_%E6%8C%87%E4%BB%A4%E3%80%81%E5%AD%98%E5%82%A8/image-20230223212725600.png" alt="image-20230223212725600"></li><li>设计时的要求（类比计算机网络 哈夫曼编码）<ul><li>不允许短码是长码的前缀</li><li>不允许操作码重复</li><li>通常情况下：指令使用频率越高，码长越短</li></ul></li></ul><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><ul><li>目的：确定下一条待执行指令的指令地址</li><li>PC寄存器（程序计数寄存器）始终保存下一条指令的地址</li><li>顺序寻址：取指令操作完成后，PC寄存器值自动 + 当前指令字长<ul><li>如果是变长指令字结构：操作码一定会在第一个存储单元（或者第一个字节&#x2F;第一个能载入寄存器长度的二进制位）中</li><li>CPU判断操作码需要几个操作数（即计算指令字长），以确定如何修改PC</li></ul></li><li>跳跃寻址：由转移指令给出</li></ul><h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><ul><li>目的：确定本条指令的地址码（操作数）指明的真实地址</li><li>怎么确定指令的地址码采用什么方式寻址<ul><li>统一约定</li><li>CPU预设</li><li>在地址码前加入描述寻址方式的位，例如地址0010，地址吗0001 0010（立即寻址0010）<ul><li>形式地址（Address）</li><li>有效地址（Effective Address）</li></ul></li></ul></li><li>隐含寻址</li><li>立即寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>相对寻址</li><li>基址寻址</li><li>变址寻址</li><li>堆栈寻址</li></ul><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><ul><li>DRAM的刷新<ul><li>多久刷新<ul><li>2ms为一个周期</li></ul></li><li>刷新多少</li><li>如何刷新<ul><li>分散刷新</li><li>集中刷新</li><li>异步刷新：最常用</li></ul></li><li>刷新特点<ul><li>内存芯片自动操作 对CPU透明</li><li>类似读RAM 但不需选片</li></ul></li></ul></li></ul><h3 id="主存与CPU的连接"><a href="#主存与CPU的连接" class="headerlink" title="主存与CPU的连接"></a>主存与CPU的连接</h3><ul><li>主存容量扩充<ul><li>位扩展<ul><li>增加同时存储的数据量</li></ul></li><li>字扩展<ul><li>增加能够存储的数据量<ul><li>线选法</li><li>译码器片选法：内存地址连续<ul><li>译码器的输出默认高电平有效，若配合低电平有效的片选信号需要使用两端带圈的线段连接（表示取非）</li></ul></li></ul></li></ul></li><li>字位扩展</li></ul></li></ul><h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><ul><li>磁盘性能指标<ul><li>磁盘容量<ul><li>未格式化容量：物理上的 用于存储用途的 磁化单元总数</li><li>格式化容量：实际存储信息的总量，会去除掉坏块、备用块等等</li><li>格式化容量 &lt; 未格式化容量</li></ul></li><li>记录密度<ul><li>道密度：半径</li><li>位密度：单位圆弧</li><li>面密度：道密度x位密度</li><li>越内侧的磁道位密度越大</li></ul></li><li>平均存取时间：加和<ul><li>寻道时间：机械臂移动</li><li>旋转延迟时间：盘片旋转<ul><li>没有明确给出则按半圈计算</li></ul></li><li>传输时间：磁头在盘片上，盘片继续旋转</li></ul></li><li>数据传输率<ul><li>磁道容量*转速</li></ul></li></ul></li><li>磁盘地址<ul><li>驱动器号</li><li>柱面&#x2F;磁道号</li><li>盘面号</li><li>扇区号</li></ul></li><li>工作过程<ul><li>寻址</li><li>读盘</li><li>写盘</li><li>是独立的操作 有控制字<ul><li>取控制字</li><li>执行控制字</li></ul></li><li>读写串行 不同时进行<ul><li>与主机连接需要串行-并行开关</li></ul></li></ul></li><li>磁盘阵列<ul><li>RAID 廉价冗余磁盘阵列</li><li>RAID 0~6<ul><li>RAID 0：无冗余无校验磁盘阵列<ul><li>相邻扇区依次存放至不同磁盘，提高速度（条带化）</li></ul></li><li>RAID 1：镜像磁盘阵列<ul><li>同一个数据拷贝并放两个磁盘，浪费100%空间</li></ul></li><li>RAID 2：海明码磁盘阵列<ul><li>数据和数据的海明码放两个磁盘，浪费75%空间</li><li>只能纠一位错</li></ul></li><li>RAID 5：无独立校验的奇偶校验磁盘阵列<ul><li>空间浪费：1&#x2F;N，N是磁盘数</li><li>用到了异或特性 不是奇偶校验码 最多一次只能坏一块盘</li></ul></li></ul></li></ul></li></ul><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><ul><li>基于闪存技术Flash Memory，也即E2PROM</li><li>主控：闪存翻译层<ul><li>主机提供逻辑块号 闪存翻译层转换为物理块号</li><li>一个SSD硬盘包含多个闪存芯片</li><li>一个闪存芯片包含多个数据块<ul><li>一般512K一块</li><li>因此属于“块设备”</li></ul></li><li>一个块内包含多个数据页<ul><li>一般0.5K~4K一页</li></ul></li></ul></li><li>读写特性<ul><li>一次读一个块<ul><li>无用数据会被丢弃</li></ul></li><li>一次写一个页</li><li>一次擦除（删除）一个块<ul><li>如果只需擦除块中的几页，需要先将其他页复制到其它块</li></ul></li><li>直观现象：读快写慢</li><li>通过电路选页选块，速度极快</li></ul></li><li>相比机械硬盘来说<ul><li>电路代替盘片旋转和磁头移动，速度大幅提升</li><li>体积小，安静无噪音，抗震</li><li>价格高</li><li>擦除次数过多会磨损 导致损坏<ul><li>引入磨损均衡技术<ul><li>将擦除尽量平均分布在各个块上</li><li>动态磨损均衡：写入时找擦除次数更少的块</li><li>静态磨损均衡：由主控自动监测处理，让老块多读、新块多写</li></ul></li></ul></li><li>正常使用情境下，寿命很长，可以接受</li></ul></li></ul><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><ul><li>内存速度无法匹配CPU速度，导致性能问题，如何解决？<ul><li>[[TODO]]</li></ul></li><li>局部性原理<ul><li>空间局部性：数据<ul><li>数组</li></ul></li><li>时间局部性：指令<ul><li>循环</li></ul></li></ul></li><li>如何让Cache代替部分RAM？或者说如何将RAM拷贝入Cache？：Cache-主存映射方式<ul><li>全相联映射<ul><li>自由存储</li><li>存储时保存完整的标记位，读取时依次检查各Cache块的标记位</li><li>Cache利用率最高</li><li>读取时时间消耗最大</li></ul></li><li>直接映射：完全不相联<ul><li>存放位置与RAM中地址紧密相关</li><li>也记录标记，但标记位数最短</li><li>读取时间最短</li><li>Cache利用率最低</li></ul></li></ul></li></ul><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul><li>由主存和辅存共同组成，统一编址</li><li>应用局部性原理，只有当辅存中的数据需要用到时才会调入内存<ul><li>辅存和主存对编程人员来说边界更加模糊了</li><li>例如：打开文件时无需了解文件的哪些数据在主存哪些数据在辅存、地址各是多少</li></ul></li><li>同样存在数据的替换问题和数据的一致性问题<ul><li>处理一致性问题是只使用回写法：辅存速度太慢，全写法不现实</li></ul></li><li>页式虚拟存储器<ul><li>扩展的页表：逻辑页号，物理页号，辅存页号，有效位（是否已经调入主存），脏位（数据是否被修改且没回写），访问位（配合LRU算法等）</li><li>页 也可以称作 块</li></ul></li><li>段式虚拟存储器<ul><li>段 按照功能划分，不同段的大小可能不同</li><li>段表：需要段号、段的起始地址、段的长度、有效位、脏位等</li></ul></li><li>段页式虚拟存储器<ul><li>既有段表也有页表，先分段再在段内分页</li><li>一个程序一个段表，一个段一个页表</li><li>调入和替换等仍以页为单位</li></ul></li></ul><h3 id="CPU访问内存的大体流程"><a href="#CPU访问内存的大体流程" class="headerlink" title="CPU访问内存的大体流程"></a>CPU访问内存的大体流程</h3><ul><li>程序提供数据的逻辑地址<ul><li>逻辑页号</li><li>页内偏移（页内地址）</li></ul></li><li>CPU依据逻辑页号查找页表<ul><li>先查找TLB，TLB命中则直接获得物理页号</li><li>TLB未命中则访问DRAM中的页表查找，找到后将页表项（键值对）复制到TLB</li></ul></li><li>拼接物理页号和页内偏移得到物理地址</li><li>访问物理地址指向的DRAM块<ul><li>假设1：先找Cache再找DRAM方式</li><li>假设2：拥有L1和L2两级缓存</li><li>从Cache中找寻DRAM数据<ul><li>在L1缓存中查找，若找到则继续</li><li>L1缓存未命中，则在L2缓存中查找，若找到则继续</li></ul></li><li>从DRAM中读取数据<ul><li>L1、L2 Cache均未命中，则读取DRAM中的数据，并将数据替换至L1缓存中</li><li>假设3：使用LRU算法作为Cache替换算法</li><li>[[TODO]]</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="计算机组成" scheme="http://wiki.zhouweitong.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="笔记" scheme="http://wiki.zhouweitong.site/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="http://wiki.zhouweitong.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="Computer Architecture" scheme="http://wiki.zhouweitong.site/tags/Computer-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Wayland下开启Chromium或Edge浏览器的显卡加速</title>
    <link href="http://wiki.zhouweitong.site/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/"/>
    <id>http://wiki.zhouweitong.site/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/</id>
    <published>2023-02-22T12:00:00.000Z</published>
    <updated>2023-02-22T12:56:52.327Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Firefox在X11和Wayland情况下均默认启用显卡加速。在大多数发行版环境下、在显卡支持时，可硬件解码开放标准的编码（如VP9、AV1等），或 标准版权已过期的商用标准的编码（如H.264等）。如果发行版自带或手动安装了支持有授权限制的编码（如H.265）的VA-API，Firefox也会尝试硬件解码这些编码。</p><p>Microsoft Edge与Chromium在X11下均默认启用显卡加速。而在Wayland下，显卡加速仍处于实验状态，需要手动启用。</p><p>下面以Fedora 37 + GNOME（Wayland + XWayland）+ Firefox + Microsoft Edge + Chromium为例，给出查看和启用显卡加速的办法。</p><h2 id="检查是否已启用显卡加速"><a href="#检查是否已启用显卡加速" class="headerlink" title="检查是否已启用显卡加速"></a>检查是否已启用显卡加速</h2><ul><li><p>Firefox：</p><ul><li>访问<code>about:support</code></li><li>“图像” -&gt; “窗口协议” -&gt; 确认对应的表格内容是为“wayland”</li><li>“图像” -&gt; “HARDWARE_VIDEO_DECODING” -&gt; 确认对应的表格中没有“unavailable”字样；</li></ul></li></ul><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230222100008842.png" alt="Firefox 处于Wayland环境下"></p><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230221231645689.png" alt="Firefox 显卡加速开启状态"></p><ul><li><p>Chromium&#x2F;Edge：</p><ul><li>访问<code>chrome://gpu</code>或<code>edge://gpu</code></li><li>“Driver Information” -&gt; “XDG_SESSION_TYPE” -&gt; 确认对应表格内容是“wayland”</li><li>“Graphics Feature Status” -&gt; 确认“Video Decode”为“Hardware accelerated”</li><li>“GpuMemoryBuffers Status” -&gt; 确认所有表格内容<strong>不全是</strong>“Software only”</li></ul></li></ul><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230222103023509.png" alt="Chromium 处于Wayland环境下"></p><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230222105845198.png"></p><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230222105917493.png" alt="Chromium 显卡加速开启状态"></p><h2 id="系统环境配置"><a href="#系统环境配置" class="headerlink" title="系统环境配置"></a>系统环境配置</h2><p>Firefox及Chromium&#x2F;Edge的显卡加速均依靠VA-API和VDPAU支持。</p><ul><li>安装显卡驱动，闭源的官方驱动或是开源的社区驱动均可。</li><li>安装VA-API和VDPAU工具</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y libva libva-utils libvdpau vdpauinfo</span><br></pre></td></tr></table></figure><ul><li><p>因为法律问题，Fedora等发行版中只提供编码受限的FFmpeg、Mesa VA-API、VDPAU支持包等，因此需要开启RPMFusion</p><ul><li>操作流程见 <a href="https://rpmfusion.org/Configuration">Configuration - RPM Fusion</a></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm</span><br></pre></td></tr></table></figure><ul><li>安装FFmpeg</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y ffmpeg</span><br><span class="line"><span class="comment"># 如果已经安装了ffpmeg-free</span></span><br><span class="line">sudo dnf swap -y ffmpeg-free ffmpeg</span><br></pre></td></tr></table></figure><ul><li>开源的驱动大概率是基于Mesa图形库开发的。如果你使用的是开源驱动，则需要安装Mesa的VA-API、VDPAU支持包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y mesa-va-drivers-freeworld mesa-vdpau-drivers-freeworld</span><br><span class="line"><span class="comment"># 如果已经安装了mesa-va-drivers和mesa-vdpau-drivers</span></span><br><span class="line">sudo dnf swap -y mesa-va-drivers mesa-va-drivers-freeworld</span><br><span class="line">sudo dnf swap -y mesa-vdpau-drivers mesa-vdpau-drivers-freeworld</span><br></pre></td></tr></table></figure><ul><li>闭源的驱动大概率内置对VA-API、VDPAU的支持，因此无需执行上述命令；有些闭源驱动需要单独安装自己的VA-API和VDPAU支持包，可参考闭源驱动的官方文档；</li></ul><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y libva-intel-driver</span><br></pre></td></tr></table></figure><ul><li>使用工具检查支持情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查VA-API支持情况</span></span><br><span class="line">vainfo</span><br><span class="line"><span class="comment"># 检查VDPAU支持情况</span></span><br><span class="line">vdpauinfo</span><br></pre></td></tr></table></figure><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230222154209726.png" alt="VA-API支持情况"></p><h2 id="强行开启Firefox硬件加速"><a href="#强行开启Firefox硬件加速" class="headerlink" title="强行开启Firefox硬件加速"></a>强行开启Firefox硬件加速</h2><ul><li>访问<code>about:config</code></li><li>搜索<code>ffmpeg</code>，将结果中的<code>media.ffmpeg.vaapi.enabled</code>改成<code>true</code></li><li>重启Firefox</li></ul><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230222110336876.png" alt="设置Firefox高级选项"></p><h2 id="开启Chromium-x2F-Edge硬件加速"><a href="#开启Chromium-x2F-Edge硬件加速" class="headerlink" title="开启Chromium&#x2F;Edge硬件加速"></a>开启Chromium&#x2F;Edge硬件加速</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>注意：此方法不适用于无GTK4环境安装的Chromium&#x2F;Edge浏览器，例如Flatpak。</p><ul><li>到<code>/usr/share/applications</code>下找到<code>chromium-browser.desktop</code>或<code>microsoft-edge-&#123;beta,dev&#125;.desktop</code></li><li>直接修改或复制一个副本进行修改<ul><li>修改<code>Name=</code>方便标识</li><li>修改<code>Exec=</code>，在原命令的最后面加入如下参数</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为方便解释，此处每行一个参数</span></span><br><span class="line"><span class="comment"># 使用系统GL渲染器</span></span><br><span class="line">--use-gl=egl</span><br><span class="line"><span class="comment"># 启用VA-API支持，启用Ozone平台</span></span><br><span class="line">--enable-features=VaapiVideoDecoder,VaapiIgnoreDriverChecks,UseOzonePlatform</span><br><span class="line"><span class="comment"># 设置Ozone平台使用Wayland作为显示服务</span></span><br><span class="line">--ozone-platform=wayland</span><br><span class="line"><span class="comment"># 强制使用GPU光栅化</span></span><br><span class="line">--force-gpu-rasterization</span><br><span class="line"><span class="comment"># 允许进行光栅化的线程直接读写GPU内存</span></span><br><span class="line">--enable-zerocopy</span><br><span class="line"><span class="comment"># Wayland输入法支持</span></span><br><span class="line">--enable-wayland-ime</span><br><span class="line"><span class="comment"># 使用GTK4库</span></span><br><span class="line">--gtk-version=4</span><br></pre></td></tr></table></figure><ul><li>若在副本中修改，则将副本替换<code>/usr/share/applications</code>下的文件，或保存到<code>~/.local/share/applications</code></li><li>注销当前用户，重新登录（使GNOME重新读取所有Desktop entry）</li><li>使用修改后的Desktop entry启动Chromium&#x2F;Edge</li></ul><h3 id="输入法不能用，如何解决？"><a href="#输入法不能用，如何解决？" class="headerlink" title="输入法不能用，如何解决？"></a>输入法不能用，如何解决？</h3><ul><li>方法一：安装GNOME扩展<a href="https://extensions.gnome.org/extension/261/kimpanel/">Input Method Panel</a>，即可正常使用输入法</li></ul><p><img src="/wiki/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/Wayland%E4%B8%8B%E5%BC%80%E5%90%AFChromium%E6%88%96Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/image-20230222205454826.png" alt="image-20230222205454826"></p><ul><li>方法二：可以使用Chrome扩展<a href="https://chrome.google.com/webstore/detail/google-input-tools/mclkkofklkfljcocdinagocijmpgbhab?hl=zh-CN">Google 输入工具</a>，代替系统输入法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="Linux浏览器" scheme="http://wiki.zhouweitong.site/categories/Linux%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="Linux" scheme="http://wiki.zhouweitong.site/tags/Linux/"/>
    
    <category term="浏览器" scheme="http://wiki.zhouweitong.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="显卡加速" scheme="http://wiki.zhouweitong.site/tags/%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F/"/>
    
    <category term="Chromium" scheme="http://wiki.zhouweitong.site/tags/Chromium/"/>
    
    <category term="Microsoft Edge" scheme="http://wiki.zhouweitong.site/tags/Microsoft-Edge/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记-物理层、数据链路层、网络层</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2023-02-22T10:00:00.000Z</published>
    <updated>2023-02-24T15:14:43.720Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="理论概念"><a href="#理论概念" class="headerlink" title="理论概念"></a>理论概念</h3><ul><li>数据</li><li>信号</li><li>码元<ul><li>通过码元数量计算码元信息量：k进制码元 $ \log_2k $</li></ul></li><li>信源：发送信号</li><li>信宿：接受信号</li><li>信道<ul><li>信道≠电路</li><li>从信道数量上来看<ul><li>串行传输</li><li>并行传输：多信道</li></ul></li><li>从信号方向上来看<ul><li>单向通信：比如现实中光模块接的单模光纤</li><li>半双工通信：比如对讲机</li><li>全双工通信：比如打电话</li></ul></li></ul></li><li>波特（Baud）：单位时间内脉冲的个数<ul><li>即码元</li></ul></li><li>比特（Bit）：信息量的单位<ul><li>即二进制位</li></ul></li><li>速率：也叫数据率，一般指信息传输速率<ul><li>码元传输速率：单位时间（1s内）传输的码元个数，单位为波特</li><li>信息传输速率：单位时间（1s内）传输的比特数，单位为比特每秒（b&#x2F;s或bps）</li><li>波特率转比特率：比特率&#x3D;波特率x码元信息量</li></ul></li><li>带宽：单位是赫兹（Hz），一般是直接给出的物理参数</li><li>失真：也叫噪声<ul><li>较小的失真：信号经过处理后依然可以识别</li><li>较大的失真：信号通过处理也无法再被识别</li></ul></li><li>奈奎斯特定理：注意是定理不是频率，单位bps<ul><li>奈奎斯特率</li><li>避免码间串扰</li><li>理想情况下：无噪声，带宽有限</li><li>极限速率：$ MAX&#x3D;2W \log_2 V $</li></ul></li><li>香农定理：单位bps<ul><li>避免噪声干扰</li><li>非理想情况下：有噪声（一般是白噪声），带宽有限</li><li>极限速率：$ MAX &#x3D; W \log_2 (1 + \frac{S}{N})) $</li><li>[[TODO]]</li></ul></li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>差错控制<ul><li>使用编码计算进行差错控制<ul><li>FEC：前向纠错，发现错误直接纠正</li><li>ARQ：自动重传，发现错误请求重传<ul><li>是主要应用的差错控制技术</li></ul></li></ul></li></ul></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>目的：向传输层提供最大可能交付的、无连接的、简单的数据报服务。</li><li>异构网络互联<ul><li>寻址方法、路由算法、差错处理算法均可能不同</li></ul></li><li>[[TODO]]</li></ul><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><ul><li>IP数据报格式<ul><li>首部：最先发送<ul><li>固定部分：大小相同，20字节，160bit<ul><li>版本 4bit：IPv4？IPv6？</li><li>首部长度 4bit：单位是半字节（4bit），最低为5；长度一定是4bit的整数倍，不足在末尾用填充位填充；</li><li>区分服务 8bit</li><li>总长度 16bit：首部长度+数据部分长度</li><li>标识 16bit</li><li>标志 4bit</li><li>片偏移 12bit</li><li>生存时间 8bit：即TTL值，为防止</li><li>协议 8bit：数据部分的协议类型。TCP：6，UDP：17。</li><li>首部校验和 16bit：只检验首部完整性；每经过一次路由器都要重新计算一次（首部会发生变化）</li><li>源地址 32bit</li><li>目的地址 32bit</li><li>可选字段 0～40bit</li><li>填充位</li></ul></li><li>可变部分：可有可无，大多数时间没有</li></ul></li><li>数据部分：传输层的报文段</li></ul></li><li>IP数据报分片<ul><li>MTU：最大传输单元，数据部分长度大于这个值必须分片</li><li>标识：同一个数据部分的不同分片使用同一个标识值</li><li>标志：共4bit，只有后两个bit有意义<ul><li>中间位DF：为1禁止分片，为0允许分片</li><li>最低位MF：为1表示还有分片，为0表示最后一片&#x2F;没有分片</li></ul></li><li>片偏移：分片在组中的相对位置（第几个片），单位为字节（8bit）；也即偏移的字节数<ul><li>字节数从0开始</li></ul></li><li>注意单位问题：总长度单位为1bit，片偏移单位为8bit，首部单位为4bit，“总1片8首4”</li></ul></li><li>IPv4地址<ul><li>使用点分十进制表示</li><li>IP地址分类<ul><li>IP地址是区域唯一的</li><li>IP地址只可以区分路由器或主机的<strong>接口</strong>：一个主机可能有多个接口</li><li>IP地址由网络号和主机号构成：各占多少位不固定</li><li>特殊的双主机逻辑网络：IP无编号网络<br><a href="https://networklessons.com/cisco/ccie-routing-switching/ip-unnumbered-explained">IP Unnumbered Explained</a></li><li>“类别位”：通过IP地址的前几位划分类型<ul><li>A类：0，0～8为网络号</li><li>B类：10，0～16位为网络号</li><li>C类：110，0～24位为网络号</li><li>D类：1110，多播地址</li><li>E类：1111，保留地址</li></ul></li><li>特殊IP地址：<ul><li>0.0.0.0：可表示任意地址（listen 0.0.0.0）或默认路由（0.0.0.0 route via X.X.X.X），也叫未指明地址</li><li>0.0.0.0&#x2F;8：网络号全0,主机号不为0，表示同一网络下的某个主机</li><li>255.255.255.255：本网广播地址，向它发送相当于向本网所有主机发送</li><li>X.X.X.0：网络号不为0、主机号为0，只用于表示一个网络，不能使用</li><li>X.X.X.255：网络号不为0、主机号位全为1，特定网络的广播地址</li><li>127.0.0.0&#x2F;8：环回地址，用于本地调试</li><li>169.254.0.0&#x2F;16：链路本地地址&#x2F;缺省IP地址，常见于DHCP分配失败时，相当于“目前还没有IP”</li><li><strong>始终注意X.X.X.0&#x2F;24和X.X.X.255&#x2F;24这两种IP地址，算可用地址数时要减去</strong></li></ul></li><li>私有IP地址：<ul><li>10.0.0.0&#x2F;8</li><li>172.16.X.X～172.31.X.X</li><li>192.168.0.0&#x2F;16</li></ul></li><li>记住特殊数字的二进制<ul><li>0：00000000</li><li>255：11111111</li><li>192：11000000</li><li>128：10000000</li><li>10：00001010</li><li>168：10101000</li><li>172：10101100</li><li>127：11111100</li></ul></li></ul></li><li>子网划分<ul><li>目的：便于扩展网络、管理网络、减少子网IP地址浪费；更灵活的控制一个子网中能容纳多少台设备</li><li>将两层IP地址转化为三层IP地址：网络号、子网号和主机号</li><li>子网号对外是透明的，看作是主机号的一部分</li><li>三层IP地址中，主机位最少是2位（去掉全0和全1，可提供给两台设备）</li><li>子网掩码：网络号部分的位为1，主机号部分的位为0</li><li>已知主机地址和子网掩码，求子网地址：二者按位相与（and），结果的四段式10进制就是子网地址</li><li>路由器路由表基本结构<ul><li>目的网络地址：发给谁？</li><li>目的网络地址的子网掩码：他在哪个子网？</li><li>下一跳的地址：通过什么发给他？</li></ul></li><li>路由器路由转发的基本流程<ul><li>找到分组IP地址：发给谁？</li><li>尝试直接交付：子网是不是直接和我连接？</li><li>不能直接交付，查路由表配置，进行IP完全匹配：是不是手动配置了发给他的路线？</li><li>没有配置，查路由表，进行IP前缀匹配（网络号匹配）：是不是手动配置了发给他所在的子网的路线？</li><li>以上均失败，发给默认路由：子网不在我这，是不是分组分配错了？</li><li>默认路由发给该路由器，路由器再发给默认路由，重复直到TTL&#x3D;0，直接丢弃并报错：分组出错，谁也联系不到他</li></ul></li></ul></li><li>CIDR组成超网</li><li>网络地址转换：NAT<ul><li>有流量时会通过路由器的NAT转换表转换为正确的IP地址，再发送信息</li><li>NAT转换表包含端口号</li></ul></li></ul></li><li>IPv6<ul><li>解决IPv4地址不够用的办法<ul><li>NAT</li><li>CIDR</li><li>治标不治本</li></ul></li><li>IPv6的主要目标<ul><li>从根本上解决IP地址不够用的问题</li><li>改进和精简首部格式，使路由器处理速度更快（快速处理&#x2F;转发数据报）</li><li>支持QoS服务模型</li></ul></li><li>IPv6封包格式<ul><li>基本首部，40字节，320bit<ul><li>版本 4bit<ul><li>值为“6”</li></ul></li><li>优先级 8bit<ul><li>标识数据报是否优先处理</li></ul></li><li>流标签 20bit<ul><li>类似IPv4中的标识，但是是“流”，与QoS有关</li></ul></li><li>有效载荷长度 16bit<ul><li>扩展首部+数据部分 大小</li></ul></li><li>下一个首部 8bit<ul><li>基本首部和每个扩展首部各有一个“下一个首部”字段</li><li>如果当前首部不是最后一个首部，该字段指向下一个首部的偏移</li><li>如果当前首部是最后一个首部，该字段指向数据部分的起始偏移</li><li>把所有部分“串在一起”</li></ul></li><li>跳数限制 8bit<ul><li>相当于IPv4中的TTL</li></ul></li><li>源地址 128bit</li><li>目标地址 128bit</li></ul></li><li>有效载荷，最高65535字节，64KB<ul><li>扩展首部：代替IPv4首部中的可变部分</li><li>数据部分</li></ul></li></ul></li><li>与IPv4的区别 <img src="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82/image-20230222175836723.png" alt="image-20230222175836723"></li><li>IPv6地址<ul><li>使用冒号16进制表示</li><li>连续的0可以用一个0代替<ul><li>0000:0000:0000变成0:0:0</li><li>0AAA:B000:000C变成 AAA:B000:C</li><li>缩头不缩尾</li></ul></li><li>双冒号零压缩，多组0用双冒号代替<ul><li>AAAA:0000:0000:0000:BBBB变为AAAA:0:0:0:BBBB再变为AAAA::BBBB</li><li>AAAA:0000:0000:0000:BBBB:0000:0000只能变为AAAA::BBBB:0:0</li><li>双冒号只能使用一次，压缩最前面的多组零</li></ul></li><li>网络号和主机号<ul><li>未指明情况下，网络号为64位（最后16位为子网号），主机号为64位</li><li>可以使用类似CIDR的表示法表示网络号的位数，如：&#x2F;24 代表网络号有24位，其他位是主机号</li></ul></li></ul></li><li>IPv6地址类型<ul><li>单播：一对一，可做源地址和目标地址</li><li>多播：一对多，只能作为目标地址</li><li>不存在广播：广播用多播实现</li><li>任播：本质一对多，实际一对一（一般是发给离本机最近的目标主机）<ul><li>例子：多台主机提供相同服务时使用任播负载均衡</li></ul></li></ul></li><li>IPv6地址划分<ul><li>全球单播：以001位开头，2000::&#x2F;3</li><li>链路本地：FE80::&#x2F;10</li><li>本地环回：::1&#x2F;128</li><li>未指明：::0&#x2F;0，也可写成::&#x2F;0</li><li>唯一本地地址&#x2F;私有地址：FC00::&#x2F;7</li><li>内嵌IPv4的IPv6地址</li></ul></li><li>IPv4向IPv6过渡<ul><li>双栈协议：主机同时使用IPv4和IPv6地址（不同接口）</li><li>隧道技术：IPv6-IPv4-发送，IPv4-IPv6-接收</li></ul></li></ul></li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><ul><li>数据链路层需要本机MAC地址和目标主机MAC地址</li><li>每个主机维护一个ARP高速缓存：ARP表</li><li>维护ARP表<ul><li>已知IP，不知道MAC，发广播ARP请求分组（请求帧）<ul><li>广播ARP请求中，目标主机MAC地址为全1（FF-FF-FF-FF-FF-FF）</li></ul></li><li>目标主机识别到广播ARP请求中的IP地址是自己，发单播（点对点）ARP响应请求（响应帧）</li><li>本机得到响应帧，更新ARP表</li><li>后续的数据分组依照ARP表内的项，填充MAC地址并发送</li></ul></li><li>以上ARP表的维护适用于目标主机和本机在同一个局域网内的情况：较大的网络不适合进行广播寻找主机</li><li>[[TODO]]</li></ul><h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><ul><li>应用层协议，基于UDP</li></ul><h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><ul><li>应用层协议，基于UDP</li><li>一种分布式的、基于距离向量的路由选择协议</li><li>特点：简单，只能用于小范围互联网</li><li>主机维护路由表，存放当前路由器到其他每一个目的网络唯一的最佳距离记录<ul><li>距离一般指 跳数</li><li>距离值小于15为合法，距离值为16表示网络不可达</li><li>路由表重要的表项<ul><li>目的网络地址</li><li>距离值</li><li>下一跳的路由器地址</li></ul></li></ul></li><li>对路由表进行定时更新<ul><li>只和相邻路由器交换信息，相互交换自己的路由表</li><li>每30s交换一次，相邻路由器180s内无响应则判定失联<ul><li>初始情况下，路由器的路由表只包含相邻路由器的、距离为1的路由</li><li>若干次更新后，每个路由器均会获得当前路由器到所有可能的网络的最短距离（小于等于15），也称“收敛”。</li><li>若相邻的路由器之一失联，则从路由表中删除下一跳是该路由器的路由表项</li></ul></li><li>路由表更新算法</li><li>子主题 4</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://wiki.zhouweitong.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="笔记" scheme="http://wiki.zhouweitong.site/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://wiki.zhouweitong.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Network" scheme="http://wiki.zhouweitong.site/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>P1-行列式</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/</id>
    <published>2023-02-22T09:00:00.000Z</published>
    <updated>2023-02-24T15:25:21.407Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>线性代数是数学的其中一个分支。主要研究向量、向量空间（线性空间）、线性变换及有限维度的线性方程组。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[线性代数（数学分支学科）_百度百科](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/800)">[1]</span></a></sup>  <strong>线性</strong>指的是线性关系，即两个或多个变量（数学元素）间的关系程一次形式。例如：n元一次方程组、形如 $f(x+y) &#x3D; f(x) + f(y)$ 的函数关系等。<strong>代数</strong> 指的是用符号代替具体数值进行计算，化具体为抽象。</p><p>本提纲基于教材《工程数学线性代数（第六版）》（同济大学数学系），采用其表述及顺序。</p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><ul><li>行列式是一个数</li><li>区别于矩阵，矩阵是一个数表</li></ul><h3 id="二阶行列式"><a href="#二阶行列式" class="headerlink" title="二阶行列式"></a>二阶行列式</h3><ul><li>计算式共4项</li><li>明确每项的特点<ul><li>不同行不同列元素乘积</li></ul></li><li>明确项与项之间的组合<ul><li>加法或减法</li></ul></li></ul><h3 id="三阶行列式"><a href="#三阶行列式" class="headerlink" title="三阶行列式"></a>三阶行列式</h3><ul><li>速算法<ul><li>各主对角线方向的三个项 减去 各副对角线方向的三个项</li></ul></li></ul><h3 id="逆序数：判断项的正负"><a href="#逆序数：判断项的正负" class="headerlink" title="逆序数：判断项的正负"></a>逆序数：判断项的正负</h3><ul><li>n阶排列<ul><li>n个数</li></ul></li><li>逆序<ul><li>大数在前小数在后</li></ul></li><li>逆序数<ul><li>逆序的总数</li></ul></li><li>奇&#x2F;偶排列<ul><li>逆序数奇&#x2F;偶</li><li>逆序数为0时是偶排列</li></ul></li><li>怎么算<ul><li>选定当前的数</li><li>找当前数后面比他小的数的个数</li><li>依次向后进行这个操作，直到最后一个数</li><li>作和</li><li>t(31542)&#x3D;2+0+2+1&#x3D;5</li></ul></li></ul><h3 id="n阶行列式"><a href="#n阶行列式" class="headerlink" title="n阶行列式"></a>n阶行列式</h3><ul><li>利用逆序数写出项<ul><li>注意判断正负的方法：尽量将行标写成递增的，这样就只用算列标的逆序数</li></ul></li><li>共有 n! 项</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>矩阵的行列式 与其转置矩阵的行列式 值相等</li><li>某行有公因数k，可将k提出行列式外</li><li>两行互换，行列式值变号<ul><li>两行相同，行列式值为0</li><li>两行成比例，行列式值为0</li></ul></li><li>一行是两数之和，可拆成两个行列式相加</li><li>某行k倍加到另一行，行列式值不变</li></ul><h3 id="重要公式"><a href="#重要公式" class="headerlink" title="重要公式"></a>重要公式</h3><ul><li>主对角线&#x2F;上三角&#x2F;下三角行列式<ul><li>结果是主对角线上元素的乘积</li></ul></li><li>副对角线&#x2F;副对角线上三角&#x2F;副对角线下三角行列式<ul><li>副对角线上元素的乘积，并计算符号正负</li></ul></li></ul><p><img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222162859175.png" alt="image-20230222162859175"></p><ul><li>拉普拉斯公式</li></ul><p><img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222162922803.png" alt="image-20230222162922803"></p><ul><li>副对角线拉普拉斯公式，m、n为A、B的行数</li></ul><p><img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222162955878.png" alt="image-20230222162955878"></p><ul><li>范德蒙行列式</li></ul><p><img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222163007608.png" alt="image-20230222163007608"></p><ul><li>爪形行列式<ul><li>一般变成上三角&#x2F;下三角行列式</li></ul></li></ul><h3 id="计算规律"><a href="#计算规律" class="headerlink" title="计算规律"></a>计算规律</h3><ul><li>数字型：行列式中的每个元素都是确定的数字<ul><li>！考虑展开公式</li><li>常用的恒等变形<ul><li>某行k倍加到另一行，行列式值不变</li><li>将每一行（的倍数）都加到第一行</li><li>逐行相加：L2+L3-&gt;L2，L1+L2-&gt;L1</li></ul></li></ul></li><li>抽象型：行列式中有未知数，需要求未知数的值&#x2F;范围<ul><li>！除了考虑行列式性质外还要考虑矩阵的性质</li><li>各种行列式的恒等变形</li><li>矩阵性质<ul><li>1 2 3 <img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222163052337.png" alt="image-20230222163052337"></li><li>4 <img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222163126301.png" alt="image-20230222163126301"><ul><li>注意|A|&#x3D;0的特殊情况，此时等式也成立，但是恒等，无法用于计算或证明</li></ul></li><li>5 6 <img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222163300367.png" alt="image-20230222163300367"></li><li>7 <img src="/wiki/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/P1_%E8%A1%8C%E5%88%97%E5%BC%8F/image-20230222163309976.png" alt="image-20230222163309976"></li></ul></li><li>单位矩阵的恒等变形</li><li>特征值性质</li><li>相似矩阵性质</li></ul></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>特征多项式</li><li>克拉默法则</li><li>矩阵的秩<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/800">线性代数（数学分支学科）_百度百科</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="数学" scheme="http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://wiki.zhouweitong.site/categories/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="数学" scheme="http://wiki.zhouweitong.site/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://wiki.zhouweitong.site/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="行列式" scheme="http://wiki.zhouweitong.site/tags/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    
    <category term="笔记" scheme="http://wiki.zhouweitong.site/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C#基础</title>
    <link href="http://wiki.zhouweitong.site/wiki/CSharp/CSharp%E5%9F%BA%E7%A1%80/"/>
    <id>http://wiki.zhouweitong.site/wiki/CSharp/CSharp%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-21T10:00:00.000Z</published>
    <updated>2023-02-24T13:34:03.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><ul><li>目前最新的版本是C# 11（.Net 7），在研的版本是C# 12（.Net 8）</li><li>.Net版本和C#版本有对应关系：.Net相当于JDK（运行时），C#相当于Java（语言标准）</li><li>.Net经过多次分割和合并<ul><li>开始时.Net仅在Windows平台上开放（.Net Framework 3.x，4.x，目前仍在维护，即.Net Framework 4.8），截止到C# 7</li><li>因此开源的.Net运行时开始发展（Mono，等同于.Net Framework 4.x），截止到C# 7</li><li>.Net Framework 3.x在Windows 7上预装，.Net Framework 4.x 在Windows 8以上系统内预装</li><li>随后Microsoft推出了.Net Core计划，相当于把.Net部分开源，截止到.Net Core 3.1（C# 8）</li><li>之后，Microsoft宣布将.Net完全开源，推出了.Net 5.x（C# 9）、.Net 6.x（C# 10）、.Net 7.x（C# 11）</li></ul></li><li>.Net，.Net Framework和.Net Core的关系：.Net Framework是最“完整”的.Net，包含Windows窗口API、Windows服务API、Web支持等等；.Net Core是最初开源的.Net，.Net是完全开源的.Net，但仍然只有部分功能（可以类比Oracle Glassfish Server，OpenJDK和JDK）</li><li>Unity和C#之间的关系：<ul><li>Unity使用Roslyn编译器，也即.Net官方给出的编译器（<a href="https://github.com/dotnet/roslyn">dotnet&#x2F;roslyn: The Roslyn .NET compiler provides C# and Visual Basic languages with rich code analysis APIs. (github.com)</a>），将C#代码转换为中间码IL</li><li>随后依据平台的不同，使用Mono继续处理IL（IL到机器码）或者使用IL2CPP（IL到C++到机器码）或者使用.Net本身（IL到机器码）</li><li>目前的Unity版本与C#版本的对应关系<ul><li>Unity 2018.4<ul><li>.Net Framework 3.5（C# 4）</li><li>.Net Framework 4.6（C# 7.3）</li></ul></li><li>Unity 2019.4<ul><li>.Net Framework 4.6（C# 7.3）</li></ul></li><li>Unity 2020.3<ul><li>.Net Framework 4.6（C# 8.0）</li></ul></li><li>Unity 2021.3<ul><li>C# 9.0</li></ul></li><li>Unity 2022.2，Unity 2023.1<ul><li>C# 9.0</li></ul></li></ul></li></ul></li></ul><h2 id="环境搭建和使用"><a href="#环境搭建和使用" class="headerlink" title="环境搭建和使用"></a>环境搭建和使用</h2><ul><li>Windows下推荐使用Visual Studio,开启.Net&#x2F;ASP .Net开发功能<ul><li><a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio: 面向软件开发人员和 Teams 的 IDE 和代码编辑器</a></li><li>如果有在Windows上以Mono做开发的需求，可以安装Mono和MonoDevelop：<ul><li><a href="https://www.mono-project.com/download/stable/#download-win">Download - Stable | Mono</a></li><li><a href="https://www.monodevelop.com/download/#fndtn-download-win">Download | MonoDevelop</a></li></ul></li></ul></li><li>Linux下可选择.Net或Mono：<ul><li>Mono需要添加官方源：<a href="https://www.mono-project.com/download/stable/#download-lin">Download - Stable | Mono</a><ul><li><code>apt-get install mono-devel monodevelop</code></li></ul></li><li>.Net同样需要添加官方源：<a href="https://docs.microsoft.com/zh-cn/dotnet/core/install/linux">在 Linux 发行版上安装 .NET - .NET | Microsoft Docs</a><ul><li><code>apt-get install dotnet-sdk-6.0</code></li></ul></li></ul></li></ul><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ul><li>C#程序的基本结构：使用命名空间、定义命名空间、命名空间内定义类、类内定义方法、Main函数入口点</li><li>语句的结尾用分号（;），class、function、namespace算语句块，不需要分号</li><li>Main函数入口点的形式：<code>static void Main(string[] args) &#123;&#125;</code><ul><li>必须是静态函数：static</li><li>一定是无返回值的：void</li><li>参数是可选的，若有参数，则是字符串数组：string[]</li><li>因为是静态函数，所以Main函数中只能直接调用其他静态函数<ul><li>即：函数能静态最好设置为静态</li></ul></li></ul></li><li>示例程序</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExampleClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li><p>也分常量&#x2F;变量类型和字面量（literal）类型</p></li><li><p>不符合“一切皆对象”的哲学：字面量不是对象</p></li><li><p>所有基本类型在定义时会被自动初始化为默认值。（一些编译器认为）如果需要变量在定义时保持其默认值，不应该将其初始化。（另一些编译器认为）变量使用前均应该被初始化。</p><ul><li>即：<code>bool m_a = false;</code> 应该写为 <code>bool m_a;</code></li></ul></li><li><p>值类型：数据存放在栈中，使用时也是直接从栈取数据、向栈写回数据；</p></li><li><p>内置的基本类型：均是值类型</p><ul><li><code>bool</code>：布尔类型，默认值为false</li><li><code>int</code>：32位整型，2^-31到2^31-1，默认值为0</li><li><code>uint</code>：32位无符号整型，0到2^32-1,默认值为0</li><li><code>short</code>：16位整型，-2^15到2^15-1，默认值为0</li><li><code>ushort</code>：16位无符号整型，0到2^16-1，默认值为0</li><li><code>long</code>：64位整型，-2^63到2^63-1,默认值为0L</li><li><code>ulong</code>：64位无符号整型，0到2^64-1，默认值为0UL</li><li><code>sbyte</code>：8位整型，-2^7到2^7-1，默认值为0</li><li><code>byte</code>：8位无符号整型，0到2^8-1，默认值为0</li><li><code>float</code>：32位单精度浮点型，默认值为0.0f</li><li><code>double</code>：64位双精度浮点型，默认值为0.0d</li><li><code>char</code>：16位UNICODE字符，默认值为’\u0000’，即’\0’</li><li><code>decimal</code>:128位整型（有效位数28～29位），默认值0.0M</li></ul></li><li><p>注意基本类型的变量和常量也是对象，提供了一些成员方法</p></li><li><p>引用类型：数据存放在堆中，但会在栈中保存数据的地址。使用时从栈中找地址，再从堆中读数据；</p><ul><li>字符串<code>string</code>是引用类型；</li><li>动态类型<code>dynamic</code>是引用类型；</li><li>对象类型（及其各种子类）<code>object</code>是引用类型：<code>string</code>和<code>dynamic</code>可看作是<code>object</code>的两个常用子类</li></ul></li><li><p>字符串类型：<code>string</code></p><ul><li><code>string</code> 本质上是一个对象</li><li>可以定义字符串数组：<code>string[]</code>，然后用下标去访问需要的字符串</li><li>字符串中部分字符需要反斜线转译，比如 <code>\n</code></li><li>可以使用“逐字字符串”，例如 <code>@&quot;A&quot;</code>，用法类似于Python中的raw string（<code>r&quot;A&quot;</code>），换行符、缩进、空格等都会被原样保留</li></ul></li><li><p>指针类型：与C++一样，使用 <code>*</code></p><ul><li>必须在指定不安全的上下文中使用，即unsafe的函数、变量或命名空间，且需在IDE的项目设置中开启“允许不安全的代码”选项（&#x2F;unsafe）</li><li>定义：<code>int *b = &amp;a;</code></li><li>使用：<code>*b;</code></li></ul></li><li><p>动态类型：<code>dynamic</code></p><ul><li>与C++中的std::any有些类似</li><li>变量的类型可在执行中改变，编译器不会对该变量进行类型检查</li><li>多用于函数的返回值</li></ul></li><li><p>对象类型：<code>object</code></p><ul><li><p><code>object</code>是所有基本类型变量的基类。更确切地说，它是所有类（类型）的终极父类；</p></li><li><p>所以理论上object类型可以“装入”并且“被读出”任意类型的数据</p></li><li><p>两种操作：</p><ul><li>将值类型转换为object类型的引用：装箱</li></ul>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><ul><li>将object类型的引用转化为原来的值类型：拆箱，要注意必须使用强制类型转换，且只能转换为object对象中值的真实类型（否则会抛出<code>InvalidCastExpection</code>异常）</li></ul>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> y = (<span class="built_in">int</span>)obj;</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C#" scheme="http://wiki.zhouweitong.site/categories/C/"/>
    
    
    <category term="编程语言" scheme="http://wiki.zhouweitong.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C#" scheme="http://wiki.zhouweitong.site/tags/C/"/>
    
    <category term="基础入门" scheme="http://wiki.zhouweitong.site/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>自定义Toolbox镜像</title>
    <link href="http://wiki.zhouweitong.site/wiki/Fedora%20Silverblue/Toolbox/%E8%87%AA%E5%AE%9A%E4%B9%89Toolbox%E9%95%9C%E5%83%8F/"/>
    <id>http://wiki.zhouweitong.site/wiki/Fedora%20Silverblue/Toolbox/%E8%87%AA%E5%AE%9A%E4%B9%89Toolbox%E9%95%9C%E5%83%8F/</id>
    <published>2023-02-18T05:38:00.000Z</published>
    <updated>2023-02-21T12:59:49.348Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Toolbox 可看做是Podman的Wrapper，力求将容器与主机的操作系统（Host OS）无缝集成。与Toolbox类似的工具还有Distrobox。它们在牺牲一些容器安全性（端口控制、资源控制、文件的独立性等）的情况下可以做到：</p><ul><li>用户穿透：在容器中使用与当前Host user一样的user与home目录；</li><li>设备穿透：直接使用Host的<code>/dev</code>、<code>/media</code>等；</li><li>网络穿透：直接使用Host网络，获得与主机一致的网络体验；</li><li>服务穿透：通过直接使用Host的<code>/run/user/&lt;uid&gt;</code>和<code>/tmp</code>以及关键服务的Socket，实现在容器中访问主机的显示服务（X11&#x2F;Wayland）、网络服务（Avahi）、D-Bus、systemd journal等；</li></ul><p>因此，Toolbox可以用来：</p><ul><li><p><strong>作为不可变系统的软件安装方式之一。</strong>如Fedora Silverblue、Fedora CoreOS等不可变系统中均预装Toolbox，另一些不可变系统中可能预装Distrobox；</p></li><li><p>使用其他发行版的镜像，<strong>在当前发行版中无缝运行针对其他发行版制作的程序</strong>。如在Fedora下运行只提供Ubuntu deb包的GUI程序；</p></li><li><p>在没有Host的root权限时<strong>创造一个假root环境</strong>。如非privileged的Toolbox容器同样可以使用<code>sudo dnf install</code>安装软件；</p><ul><li>需要镜像中预装sudo，并支持<code>sudo</code>、<code>wheel</code>组获取root权限，且支持<code>NOPASSWD</code>选项；</li></ul></li><li><p>使用不同版本的镜像实现<strong>“旧程序运行在新系统上”或“新程序运行在旧系统上”</strong>，或对程序进行兼容性测试；</p></li><li><p>可以通过对镜像进行自定义，实现<strong>快速且一致的开发环境搭建</strong>；</p></li></ul><h2 id="创建自己的Toolbox镜像"><a href="#创建自己的Toolbox镜像" class="headerlink" title="创建自己的Toolbox镜像"></a>创建自己的Toolbox镜像</h2><p>符合OCI标准的容器镜像均可被Toolbox使用。换言之，依照通常的Docker镜像构建方法就可以构建自己的Toolbox镜像。</p><p>Fedora社区持续维护着Fedora的Toolbox镜像构建文件 <a href="https://src.fedoraproject.org/container/fedora-toolbox">container&#x2F;fedora-toolbox</a>，GitHub上也有社区维护的各主流发行版的Toolbox镜像 <a href="https://github.com/toolbx-images/images">toolbx-images&#x2F;images</a>。</p><p>以Fedora的Toolbox镜像为例，以下是官方给出的Dockerfile示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用fedora:37，而不是fedora-toolbox:37</span></span><br><span class="line"><span class="keyword">FROM</span> registry.fedoraproject.org/fedora:<span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像标签</span></span><br><span class="line"><span class="keyword">ENV</span> NAME=fedora-toolbox VERSION=<span class="number">37</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.github.containers.toolbox=<span class="string">&quot;true&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.redhat.component=<span class="string">&quot;<span class="variable">$NAME</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      name=<span class="string">&quot;<span class="variable">$NAME</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      version=<span class="string">&quot;<span class="variable">$VERSION</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      usage=<span class="string">&quot;This image is meant to be used with the toolbox command&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      summary=<span class="string">&quot;Base image for creating Fedora toolbox containers&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      maintainer=<span class="string">&quot;Debarshi Ray &lt;rishi@fedoraproject.org&gt;&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> README.md /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使dnf安装软件包时 同步安装所有语言的语言文件 及文档文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /etc/rpm/macros.image-language-conf</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;/tsflags=nodocs/d&#x27;</span> /etc/dnf/dnf.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [A] 安装完整的 核心工具（GNU Coreutils）及其语言文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf -y upgrade</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf -y swap coreutils-single coreutils-full</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf -y swap glibc-minimal-langpack glibc-all-langpacks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [B] 通过重装的方式补齐语言和文档</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> missing-docs /</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf -y reinstall $(&lt;missing-docs)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /missing-docs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [C] 安装额外的软件包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> extra-packages /</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf -y install $(&lt;extra-packages)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /extra-packages</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [D] 保证关键文档文件存在</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ensure-files /</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ret_val=0; \</span></span><br><span class="line"><span class="language-bash">  <span class="keyword">while</span> <span class="built_in">read</span> file; <span class="keyword">do</span> \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> ! compgen -G <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt;/dev/null; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">      <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>: No such file or directory&quot;</span> &gt;&amp;2; \</span></span><br><span class="line"><span class="language-bash">      ret_val=1; \</span></span><br><span class="line"><span class="language-bash">      <span class="built_in">break</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span>; \</span></span><br><span class="line"><span class="language-bash">  <span class="keyword">done</span> &lt;ensure-files; \</span></span><br><span class="line"><span class="language-bash">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ret_val</span>&quot;</span> -ne 0 ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">    <span class="literal">false</span>; \</span></span><br><span class="line"><span class="language-bash">  <span class="keyword">fi</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /ensure-files</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf clean all</span></span><br></pre></td></tr></table></figure><p>同时还需要三个额外的文件 <code>ensure-files</code>、<code>extra-packages</code>和<code>missing-docs</code>。</p><p>想增加或删减Toolbox中的镜像，可直接修改<code>extra-packages</code>文件，修改时尽量保证每行只有一个软件包的包名。也可以仿照上述Dockerfile的<code>[C]</code>节，在不修改<code>extra-packages</code>文件时使用自定义文件；</p><p>仿写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> added-packages /</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf -y install $(&lt;added-packages)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /added-packages</span></span><br></pre></td></tr></table></figure><p><code>added-packages</code>例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nodejs</span><br><span class="line">npm</span><br><span class="line">python3-pip</span><br><span class="line">gcc</span><br><span class="line">g++</span><br></pre></td></tr></table></figure><h3 id="给Toolbox镜像增加中文支持"><a href="#给Toolbox镜像增加中文支持" class="headerlink" title="给Toolbox镜像增加中文支持"></a>给Toolbox镜像增加中文支持</h3><p>可以通过修改<code>LANG</code>变量、重新生成语言文件、安装中文字体等方法使Toolbox内的命令行&#x2F;GUI程序支持并默认显示中文。</p><ol><li>添加语言文件：在上述Dockerfile示例的<code>[B]</code>节前添加如下内容</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中文语言</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf install -y  glibc-locale-source glibc-langpack-zh langpacks-zh_CN</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> localedef -c -i zh_CN -f UTF-8 zh_CN.UTF-8</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装字体和输入法：在上述Dockerfile示例的<code>[C]</code>节或<code>[D]</code>节前添加如下内容</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装字体和输入法</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dnf install -y wqy-microhei-fonts wqy-zenhei-fonts fcitx5</span></span><br></pre></td></tr></table></figure><ol start="3"><li>设置<code>LANG</code>环境变量：在上述Dockerfile示例的最后添加如下内容</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> LANG zh_CN.UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="使用Toolbox镜像"><a href="#使用Toolbox镜像" class="headerlink" title="使用Toolbox镜像"></a>使用Toolbox镜像</h2><p>以自定义镜像的tag为<code>a.com/fedora-toolbox-customized:37</code>为例：</p><ol><li>通过<code>podman</code>拉取自定义镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">podman pull a.com/fedora-toolbox-customized:37</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>toolbox</code>创建容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器名可以随意指定</span></span><br><span class="line"><span class="comment"># 当主机为Fedora系统，且容器名为 fedora-toolbox-&lt;主机Fedora版本号&gt; 时，该容器为Toolbox默认容器</span></span><br><span class="line">toolbox create --image a.com/fedora-toolbox-customized:37 fedora-toolbox-37</span><br></pre></td></tr></table></figure><ol start="3"><li>进入容器环境或执行容器内特定程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当主机只有一个Toolbox容器时，会直接进入该容器</span></span><br><span class="line"><span class="comment"># 当Fedora系统的主机有默认容器时，会直接进入默认容器</span></span><br><span class="line">toolbox enter</span><br><span class="line"><span class="comment"># 可以直接指定需要运行的命令</span></span><br><span class="line">toolbox run &lt;命令&gt;</span><br><span class="line"><span class="comment"># 在存在多个Toolbox容器时，可通过命令参数指定运行哪个容器</span></span><br><span class="line">toolbox enter &lt;容器名&gt;</span><br><span class="line">toolbox run --container &lt;容器名&gt; &lt;命令&gt;</span><br></pre></td></tr></table></figure><h2 id="删除Toolbox容器和镜像"><a href="#删除Toolbox容器和镜像" class="headerlink" title="删除Toolbox容器和镜像"></a>删除Toolbox容器和镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要退出所有正在使用Toolbox Shell/命令行程序/GUI程序的窗口</span></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">podman stop &lt;容器名&gt;</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">toolbox <span class="built_in">rm</span> &lt;容器名&gt;</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">podman rmi a.com/fedora-toolbox-customized:37</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="Fedora Silverblue" scheme="http://wiki.zhouweitong.site/categories/Fedora-Silverblue/"/>
    
    <category term="Toolbox" scheme="http://wiki.zhouweitong.site/categories/Fedora-Silverblue/Toolbox/"/>
    
    
    <category term="Linux" scheme="http://wiki.zhouweitong.site/tags/Linux/"/>
    
    <category term="Docker" scheme="http://wiki.zhouweitong.site/tags/Docker/"/>
    
    <category term="Fedora" scheme="http://wiki.zhouweitong.site/tags/Fedora/"/>
    
    <category term="Toolbox" scheme="http://wiki.zhouweitong.site/tags/Toolbox/"/>
    
    <category term="Podman" scheme="http://wiki.zhouweitong.site/tags/Podman/"/>
    
  </entry>
  
  <entry>
    <title>科目一 口诀</title>
    <link href="http://wiki.zhouweitong.site/wiki/%E9%A9%BE%E7%85%A7/%E7%A7%91%E7%9B%AE%E4%B8%80/%E7%A7%91%E7%9B%AE%E4%B8%80%20%E5%8F%A3%E8%AF%80/"/>
    <id>http://wiki.zhouweitong.site/wiki/%E9%A9%BE%E7%85%A7/%E7%A7%91%E7%9B%AE%E4%B8%80/%E7%A7%91%E7%9B%AE%E4%B8%80%20%E5%8F%A3%E8%AF%80/</id>
    <published>2023-02-14T12:30:00.000Z</published>
    <updated>2023-02-14T14:51:08.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><p>申请驾驶证年龄要求</p><ul><li><strong>最小18，最大不限</strong></li><li>70以上，每年体检</li></ul></li><li><p>驾驶证有效期</p><ul><li><strong>6 10 长</strong></li><li>刚拿时6年过期，然后换证10年过期，再换证长期有效</li></ul></li><li><p><strong>遇周期，找12</strong></p><ul><li>驾驶证周期是12个月</li><li>驾驶证实习期是12个月</li></ul></li><li><p><strong>遇时间，找9、3</strong></p><ul><li>选项有90日就选90日</li><li>没有90日就选30日</li></ul></li><li><p><strong>遇有效期，找3年</strong></p><ul><li>准考证有效期3年</li><li>实习期上高速找3年经验者陪同</li><li>因事不能审验延期3年</li></ul></li><li><p>大客中客牵引车，普通驾照也没辙</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="驾照" scheme="http://wiki.zhouweitong.site/categories/%E9%A9%BE%E7%85%A7/"/>
    
    <category term="科目一" scheme="http://wiki.zhouweitong.site/categories/%E9%A9%BE%E7%85%A7/%E7%A7%91%E7%9B%AE%E4%B8%80/"/>
    
    
    <category term="驾照" scheme="http://wiki.zhouweitong.site/tags/%E9%A9%BE%E7%85%A7/"/>
    
    <category term="科目一" scheme="http://wiki.zhouweitong.site/tags/%E7%A7%91%E7%9B%AE%E4%B8%80/"/>
    
    <category term="口诀" scheme="http://wiki.zhouweitong.site/tags/%E5%8F%A3%E8%AF%80/"/>
    
    <category term="理论题" scheme="http://wiki.zhouweitong.site/tags/%E7%90%86%E8%AE%BA%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Arch安装速查表</title>
    <link href="http://wiki.zhouweitong.site/wiki/Arch%20Linux/Arch%E5%AE%89%E8%A3%85%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://wiki.zhouweitong.site/wiki/Arch%20Linux/Arch%E5%AE%89%E8%A3%85%E9%80%9F%E6%9F%A5%E8%A1%A8/</id>
    <published>2023-02-14T10:00:00.000Z</published>
    <updated>2023-02-15T11:25:01.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="LiveCD下载后操作"><a href="#LiveCD下载后操作" class="headerlink" title="LiveCD下载后操作"></a>LiveCD下载后操作</h2><p>无需求时可跳过本节；</p><h3 id="校验ISO镜像"><a href="#校验ISO镜像" class="headerlink" title="校验ISO镜像"></a>校验ISO镜像</h3><ul><li>sha256校验：<a href="https://archlinux.org/download/#checksums">https://archlinux.org/download/#checksums</a>，或者</li><li>pgp校验（必须从 <code>archlinux.org</code> 域名下载pgp签名文件</li></ul><h3 id="烧录ISO镜像"><a href="#烧录ISO镜像" class="headerlink" title="烧录ISO镜像"></a>烧录ISO镜像</h3><p>刻录ISO为光盘 或者 使用软件从ISO镜像制作USB启动盘；</p><ul><li>Rufus；</li><li>balenaEtcher；</li></ul><h2 id="从LiveCD启动机器"><a href="#从LiveCD启动机器" class="headerlink" title="从LiveCD启动机器"></a>从LiveCD启动机器</h2><ul><li>若是UEFI BIOS模式启动，须在BIOS设置中关闭“安全启动”（Secure Boot）；</li></ul><h2 id="LiveCD启动后操作"><a href="#LiveCD启动后操作" class="headerlink" title="LiveCD启动后操作"></a>LiveCD启动后操作</h2><h3 id="修改键盘键位"><a href="#修改键盘键位" class="headerlink" title="修改键盘键位"></a>修改键盘键位</h3><p>标准qwerty键盘时可跳过本节；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得键位布局ID</span></span><br><span class="line"><span class="built_in">ls</span> /usr/share/kbd/keymaps/**/*.map.gz</span><br><span class="line"><span class="comment"># 加载键位布局</span></span><br><span class="line">loadkeys &lt;keymap_id&gt;</span><br></pre></td></tr></table></figure><h3 id="检测启动模式"><a href="#检测启动模式" class="headerlink" title="检测启动模式"></a>检测启动模式</h3><p>熟悉BIOS设置和BIOS启动选项时可跳过本节；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件夹存在：是UEFI BIOS模式</span></span><br><span class="line"><span class="comment"># 文件夹不存在：是Legacy BIOS模式</span></span><br><span class="line"><span class="built_in">ls</span> /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure><h3 id="检查网络设置"><a href="#检查网络设置" class="headerlink" title="检查网络设置"></a>检查网络设置</h3><p>Arch要求必须连接网络才能进行安装;</p><h4 id="检查网络硬件"><a href="#检查网络硬件" class="headerlink" title="检查网络硬件"></a>检查网络硬件</h4><ul><li>以太网：确定网线已经插入</li><li>内置Wi-fi网卡：确保网卡没有物理按钮（可以硬件层面打开或禁用Wi-fi网卡）；或者有物理按钮并切换到启用；</li><li>外置Wi-fi网卡：确保网卡已插入；</li><li>内置SIM卡卡槽：确保已插卡；</li><li>外置SIM卡上网卡：确保已插卡并已插入；</li></ul><h4 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h4><p>首先<code>ip link</code>检查接口是否打开，没有的话<code>ip link set dev &lt;device&gt; up</code>；</p><ul><li>以太网：无特殊操作</li><li>Wi-fi：使用 <code>iwctl</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iwctl device list</span><br><span class="line">iwctl station list</span><br><span class="line">iwctl station &lt;device&gt; scan</span><br><span class="line">iwctl station &lt;device&gt; get-networks</span><br><span class="line">iwctl --passphrase <span class="string">&quot;&lt;password&gt;&quot;</span> station &lt;device&gt; connect &lt;SSID&gt;</span><br><span class="line">iwctl station &lt;device&gt; show</span><br><span class="line"><span class="comment"># iwctl station &lt;device&gt; disconnect</span></span><br></pre></td></tr></table></figure><ul><li>SIM卡移动网络：使用<code>mmcli</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmcli -L</span><br><span class="line">mmcli -m &lt;index&gt; --simple-connect=<span class="string">&quot;apn=&lt;apn&gt;,user=&lt;username&gt;,password=&lt;password&gt;&quot;</span></span><br><span class="line">mmcli -m &lt;index&gt; --simple-disconnect</span><br></pre></td></tr></table></figure><h4 id="检查IP地址"><a href="#检查IP地址" class="headerlink" title="检查IP地址"></a>检查IP地址</h4><p><code>ip addr</code>检查IP地址；</p><ul><li>DHCP自动分配IP的链路：无需特殊操作，IP地址会自动获取</li><li>静态IP的链路：使用<code>ip</code>手动添加地址和路由</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip [-6] addr add &lt;ip&gt;/&lt;prefix&gt; broadcast + dev &lt;device&gt;</span><br><span class="line"><span class="comment"># ip [-6] address del &lt;ip&gt;/&lt;prefix&gt; dev &lt;device&gt;</span></span><br><span class="line"></span><br><span class="line">ip [-6] route</span><br><span class="line">ip [-6] route add &lt;route_ip&gt;/&lt;prefix&gt; via &lt;ip&gt; dev &lt;device&gt;</span><br><span class="line">ip [-6] route add default via &lt;ip&gt; dev &lt;device&gt;</span><br><span class="line"><span class="comment"># ip [-6] route del &lt;route_ip&gt;/&lt;prefix&gt; via &lt;ip&gt; dev &lt;device&gt;</span></span><br></pre></td></tr></table></figure><h4 id="检查互联网连通性"><a href="#检查互联网连通性" class="headerlink" title="检查互联网连通性"></a>检查互联网连通性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 8.8.8.8</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="检查时钟"><a href="#检查时钟" class="headerlink" title="检查时钟"></a>检查时钟</h3><p>自动在联网后触发同步，检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status</span><br></pre></td></tr></table></figure><p>同步失败等情况需手动设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-time <span class="string">&quot;&lt;YYYY-MM-dd HH:mm:ss&gt;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="硬盘和分区设置"><a href="#硬盘和分区设置" class="headerlink" title="硬盘和分区设置"></a>硬盘和分区设置</h3><p>使用<code>fdisk</code>交互式设置分区表；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">fdisk &lt;device&gt;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g：建立GPT分区表</span><br><span class="line">o：建立DOS分区表</span><br><span class="line"></span><br><span class="line">n：新建分区</span><br><span class="line">d：删除分区</span><br><span class="line">p：查询分区表</span><br><span class="line">t：修改分区类型</span><br><span class="line">l：列出支持的分区类型</span><br><span class="line"></span><br><span class="line">w：将分区表更改写入硬盘</span><br><span class="line">q：不保存分区表修改</span><br></pre></td></tr></table></figure><p>设置分区大小时可以直接使用容量值，如<code>+100M</code></p><h4 id="硬盘规划"><a href="#硬盘规划" class="headerlink" title="硬盘规划"></a>硬盘规划</h4><h5 id="EFI分区"><a href="#EFI分区" class="headerlink" title="EFI分区"></a>EFI分区</h5><p>1个，仅UEFI模式时需要</p><ul><li>格式：EFI System</li><li>文件系统：FAT32</li><li>容量：数百MB（300MB）</li><li>挂载点：<code>/boot/efi</code></li><li>Flag: boot</li><li>用途：存储UEFI需要的启动文件</li></ul><h5 id="boot分区"><a href="#boot分区" class="headerlink" title="boot分区"></a>boot分区</h5><p>根分区不是ext4时，推荐单独建立1个ext4格式的boot分区；</p><ul><li>格式：Linux filesystem</li><li>文件系统：ext4</li><li>容量：数百MB（500MB）或数GB（1GB）</li><li>挂载点：<code>/boot</code></li><li>用途：存储所有启动相关的文件，如：GRUB配置、Linux内核（vmlinuz、initrd）等</li></ul><h5 id="swap交换空间"><a href="#swap交换空间" class="headerlink" title="swap交换空间"></a>swap交换空间</h5><p>除非存储空间非常紧缺，否则应该使用swap，推荐直接创建swap分区；</p><p>除了使用swap分区以外，也可以不创建分区而使用swap文件；</p><ul><li>格式：Linux swap</li><li>文件系统：swap</li><li>容量：根据是否需要使用休眠功能（Hibernation）和RAM大小确定：<ul><li>使用休眠功能：休眠时Linux会将整个物理内存保存在硬盘（也即swap）中；<ul><li>RAM &lt;&#x3D; 2GB，swap &gt;&#x3D; 3*RAM</li><li>RAM &gt; 2GB &amp;&amp; RAM &lt;&#x3D; 8GB，swap &gt;&#x3D; 2*RAM</li><li>RAM &gt; 8GB &amp;&amp; RAM &lt;&#x3D; 64GB，swap &gt;&#x3D; 1.5*RAM</li><li>RAM &gt;&#x3D; 64GB，此时使用休眠功能耗时较长，且若是固态硬盘则会快速消耗硬盘寿命，因此不推荐使用休眠功能</li></ul></li><li>不使用休眠功能<ul><li>RAM &lt;&#x3D; 2GB，swap &gt;&#x3D; 2*RAM</li><li>RAM &gt; 2GB &amp;&amp; RAM &lt;&#x3D; 8GB，swap &gt;&#x3D; RAM</li><li>RAM &gt; 8GB，swap &gt;&#x3D; max(8GB, 0.5*RAM)</li></ul></li></ul></li></ul><blockquote><p>TODO：整个安装流程</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="Arch Linux" scheme="http://wiki.zhouweitong.site/categories/Arch-Linux/"/>
    
    
    <category term="Linux" scheme="http://wiki.zhouweitong.site/tags/Linux/"/>
    
    <category term="Arch Linux" scheme="http://wiki.zhouweitong.site/tags/Arch-Linux/"/>
    
    <category term="发行版安装" scheme="http://wiki.zhouweitong.site/tags/%E5%8F%91%E8%A1%8C%E7%89%88%E5%AE%89%E8%A3%85/"/>
    
    <category term="速查表" scheme="http://wiki.zhouweitong.site/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    
  </entry>
  
</feed>
